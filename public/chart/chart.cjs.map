{"version":3,"file":"chart.cjs","sources":["../src/core/core.animator.js","../src/core/core.animation.js","../src/core/core.animations.js","../src/core/core.datasetController.js","../src/controllers/controller.bar.js","../src/controllers/controller.bubble.js","../src/controllers/controller.doughnut.js","../src/controllers/controller.line.js","../src/controllers/controller.polarArea.js","../src/controllers/controller.pie.js","../src/controllers/controller.radar.js","../src/controllers/controller.scatter.js","../src/core/core.adapters.ts","../src/core/core.interaction.js","../src/core/core.layouts.js","../src/platform/platform.base.js","../src/platform/platform.basic.js","../src/platform/platform.dom.js","../src/platform/index.js","../src/core/core.element.ts","../src/core/core.scale.autoskip.js","../src/core/core.scale.js","../src/core/core.typedRegistry.js","../src/core/core.registry.js","../src/core/core.plugins.js","../src/core/core.config.js","../src/core/core.controller.js","../src/elements/element.arc.ts","../src/elements/element.line.js","../src/elements/element.point.ts","../src/elements/element.bar.js","../src/plugins/plugin.colors.ts","../src/plugins/plugin.decimation.js","../src/plugins/plugin.filler/filler.segment.js","../src/plugins/plugin.filler/filler.helper.js","../src/plugins/plugin.filler/filler.options.js","../src/plugins/plugin.filler/filler.target.stack.js","../src/plugins/plugin.filler/simpleArc.js","../src/plugins/plugin.filler/filler.target.js","../src/plugins/plugin.filler/filler.drawing.js","../src/plugins/plugin.filler/index.js","../src/plugins/plugin.legend.js","../src/plugins/plugin.title.js","../src/plugins/plugin.subtitle.js","../src/plugins/plugin.tooltip.js","../src/scales/scale.category.js","../src/scales/scale.linearbase.js","../src/scales/scale.linear.js","../src/scales/scale.logarithmic.js","../src/scales/scale.radialLinear.js","../src/scales/scale.time.js","../src/scales/scale.timeseries.js","../src/index.ts"],"sourcesContent":["import {requestAnimFrame} from '../helpers/helpers.extras.js';\r\n\r\n/**\r\n * @typedef { import('./core.animation.js').default } Animation\r\n * @typedef { import('./core.controller.js').default } Chart\r\n */\r\n\r\n/**\r\n * Please use the module's default export which provides a singleton instance\r\n * Note: class is export for typedoc\r\n */\r\nexport class Animator {\r\n  constructor() {\r\n    this._request = null;\r\n    this._charts = new Map();\r\n    this._running = false;\r\n    this._lastDate = undefined;\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _notify(chart, anims, date, type) {\r\n    const callbacks = anims.listeners[type];\r\n    const numSteps = anims.duration;\r\n\r\n    callbacks.forEach(fn => fn({\r\n      chart,\r\n      initial: anims.initial,\r\n      numSteps,\r\n      currentStep: Math.min(date - anims.start, numSteps)\r\n    }));\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _refresh() {\r\n    if (this._request) {\r\n      return;\r\n    }\r\n    this._running = true;\r\n\r\n    this._request = requestAnimFrame.call(window, () => {\r\n      this._update();\r\n      this._request = null;\r\n\r\n      if (this._running) {\r\n        this._refresh();\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _update(date = Date.now()) {\r\n    let remaining = 0;\r\n\r\n    this._charts.forEach((anims, chart) => {\r\n      if (!anims.running || !anims.items.length) {\r\n        return;\r\n      }\r\n      const items = anims.items;\r\n      let i = items.length - 1;\r\n      let draw = false;\r\n      let item;\r\n\r\n      for (; i >= 0; --i) {\r\n        item = items[i];\r\n\r\n        if (item._active) {\r\n          if (item._total > anims.duration) {\r\n            // if the animation has been updated and its duration prolonged,\r\n            // update to total duration of current animations run (for progress event)\r\n            anims.duration = item._total;\r\n          }\r\n          item.tick(date);\r\n          draw = true;\r\n        } else {\r\n          // Remove the item by replacing it with last item and removing the last\r\n          // A lot faster than splice.\r\n          items[i] = items[items.length - 1];\r\n          items.pop();\r\n        }\r\n      }\r\n\r\n      if (draw) {\r\n        chart.draw();\r\n        this._notify(chart, anims, date, 'progress');\r\n      }\r\n\r\n      if (!items.length) {\r\n        anims.running = false;\r\n        this._notify(chart, anims, date, 'complete');\r\n        anims.initial = false;\r\n      }\r\n\r\n      remaining += items.length;\r\n    });\r\n\r\n    this._lastDate = date;\r\n\r\n    if (remaining === 0) {\r\n      this._running = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _getAnims(chart) {\r\n    const charts = this._charts;\r\n    let anims = charts.get(chart);\r\n    if (!anims) {\r\n      anims = {\r\n        running: false,\r\n        initial: true,\r\n        items: [],\r\n        listeners: {\r\n          complete: [],\r\n          progress: []\r\n        }\r\n      };\r\n      charts.set(chart, anims);\r\n    }\r\n    return anims;\r\n  }\r\n\r\n  /**\r\n\t * @param {Chart} chart\r\n\t * @param {string} event - event name\r\n\t * @param {Function} cb - callback\r\n\t */\r\n  listen(chart, event, cb) {\r\n    this._getAnims(chart).listeners[event].push(cb);\r\n  }\r\n\r\n  /**\r\n\t * Add animations\r\n\t * @param {Chart} chart\r\n\t * @param {Animation[]} items - animations\r\n\t */\r\n  add(chart, items) {\r\n    if (!items || !items.length) {\r\n      return;\r\n    }\r\n    this._getAnims(chart).items.push(...items);\r\n  }\r\n\r\n  /**\r\n\t * Counts number of active animations for the chart\r\n\t * @param {Chart} chart\r\n\t */\r\n  has(chart) {\r\n    return this._getAnims(chart).items.length > 0;\r\n  }\r\n\r\n  /**\r\n\t * Start animating (all charts)\r\n\t * @param {Chart} chart\r\n\t */\r\n  start(chart) {\r\n    const anims = this._charts.get(chart);\r\n    if (!anims) {\r\n      return;\r\n    }\r\n    anims.running = true;\r\n    anims.start = Date.now();\r\n    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);\r\n    this._refresh();\r\n  }\r\n\r\n  running(chart) {\r\n    if (!this._running) {\r\n      return false;\r\n    }\r\n    const anims = this._charts.get(chart);\r\n    if (!anims || !anims.running || !anims.items.length) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n\t * Stop all animations for the chart\r\n\t * @param {Chart} chart\r\n\t */\r\n  stop(chart) {\r\n    const anims = this._charts.get(chart);\r\n    if (!anims || !anims.items.length) {\r\n      return;\r\n    }\r\n    const items = anims.items;\r\n    let i = items.length - 1;\r\n\r\n    for (; i >= 0; --i) {\r\n      items[i].cancel();\r\n    }\r\n    anims.items = [];\r\n    this._notify(chart, anims, Date.now(), 'complete');\r\n  }\r\n\r\n  /**\r\n\t * Remove chart from Animator\r\n\t * @param {Chart} chart\r\n\t */\r\n  remove(chart) {\r\n    return this._charts.delete(chart);\r\n  }\r\n}\r\n\r\n// singleton instance\r\nexport default /* #__PURE__ */ new Animator();\r\n","import effects from '../helpers/helpers.easing.js';\r\nimport {resolve} from '../helpers/helpers.options.js';\r\nimport {color as helpersColor} from '../helpers/helpers.color.js';\r\n\r\nconst transparent = 'transparent';\r\nconst interpolators = {\r\n  boolean(from, to, factor) {\r\n    return factor > 0.5 ? to : from;\r\n  },\r\n  /**\r\n   * @param {string} from\r\n   * @param {string} to\r\n   * @param {number} factor\r\n   */\r\n  color(from, to, factor) {\r\n    const c0 = helpersColor(from || transparent);\r\n    const c1 = c0.valid && helpersColor(to || transparent);\r\n    return c1 && c1.valid\r\n      ? c1.mix(c0, factor).hexString()\r\n      : to;\r\n  },\r\n  number(from, to, factor) {\r\n    return from + (to - from) * factor;\r\n  }\r\n};\r\n\r\nexport default class Animation {\r\n  constructor(cfg, target, prop, to) {\r\n    const currentValue = target[prop];\r\n\r\n    to = resolve([cfg.to, to, currentValue, cfg.from]);\r\n    const from = resolve([cfg.from, currentValue, to]);\r\n\r\n    this._active = true;\r\n    this._fn = cfg.fn || interpolators[cfg.type || typeof from];\r\n    this._easing = effects[cfg.easing] || effects.linear;\r\n    this._start = Math.floor(Date.now() + (cfg.delay || 0));\r\n    this._duration = this._total = Math.floor(cfg.duration);\r\n    this._loop = !!cfg.loop;\r\n    this._target = target;\r\n    this._prop = prop;\r\n    this._from = from;\r\n    this._to = to;\r\n    this._promises = undefined;\r\n  }\r\n\r\n  active() {\r\n    return this._active;\r\n  }\r\n\r\n  update(cfg, to, date) {\r\n    if (this._active) {\r\n      this._notify(false);\r\n\r\n      const currentValue = this._target[this._prop];\r\n      const elapsed = date - this._start;\r\n      const remain = this._duration - elapsed;\r\n      this._start = date;\r\n      this._duration = Math.floor(Math.max(remain, cfg.duration));\r\n      this._total += elapsed;\r\n      this._loop = !!cfg.loop;\r\n      this._to = resolve([cfg.to, to, currentValue, cfg.from]);\r\n      this._from = resolve([cfg.from, currentValue, to]);\r\n    }\r\n  }\r\n\r\n  cancel() {\r\n    if (this._active) {\r\n      // update current evaluated value, for smoother animations\r\n      this.tick(Date.now());\r\n      this._active = false;\r\n      this._notify(false);\r\n    }\r\n  }\r\n\r\n  tick(date) {\r\n    const elapsed = date - this._start;\r\n    const duration = this._duration;\r\n    const prop = this._prop;\r\n    const from = this._from;\r\n    const loop = this._loop;\r\n    const to = this._to;\r\n    let factor;\r\n\r\n    this._active = from !== to && (loop || (elapsed < duration));\r\n\r\n    if (!this._active) {\r\n      this._target[prop] = to;\r\n      this._notify(true);\r\n      return;\r\n    }\r\n\r\n    if (elapsed < 0) {\r\n      this._target[prop] = from;\r\n      return;\r\n    }\r\n\r\n    factor = (elapsed / duration) % 2;\r\n    factor = loop && factor > 1 ? 2 - factor : factor;\r\n    factor = this._easing(Math.min(1, Math.max(0, factor)));\r\n\r\n    this._target[prop] = this._fn(from, to, factor);\r\n  }\r\n\r\n  wait() {\r\n    const promises = this._promises || (this._promises = []);\r\n    return new Promise((res, rej) => {\r\n      promises.push({res, rej});\r\n    });\r\n  }\r\n\r\n  _notify(resolved) {\r\n    const method = resolved ? 'res' : 'rej';\r\n    const promises = this._promises || [];\r\n    for (let i = 0; i < promises.length; i++) {\r\n      promises[i][method]();\r\n    }\r\n  }\r\n}\r\n","import animator from './core.animator.js';\r\nimport Animation from './core.animation.js';\r\nimport defaults from './core.defaults.js';\r\nimport {isArray, isObject} from '../helpers/helpers.core.js';\r\n\r\nexport default class Animations {\r\n  constructor(chart, config) {\r\n    this._chart = chart;\r\n    this._properties = new Map();\r\n    this.configure(config);\r\n  }\r\n\r\n  configure(config) {\r\n    if (!isObject(config)) {\r\n      return;\r\n    }\r\n\r\n    const animationOptions = Object.keys(defaults.animation);\r\n    const animatedProps = this._properties;\r\n\r\n    Object.getOwnPropertyNames(config).forEach(key => {\r\n      const cfg = config[key];\r\n      if (!isObject(cfg)) {\r\n        return;\r\n      }\r\n      const resolved = {};\r\n      for (const option of animationOptions) {\r\n        resolved[option] = cfg[option];\r\n      }\r\n\r\n      (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {\r\n        if (prop === key || !animatedProps.has(prop)) {\r\n          animatedProps.set(prop, resolved);\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n\t * Utility to handle animation of `options`.\r\n\t * @private\r\n\t */\r\n  _animateOptions(target, values) {\r\n    const newOptions = values.options;\r\n    const options = resolveTargetOptions(target, newOptions);\r\n    if (!options) {\r\n      return [];\r\n    }\r\n\r\n    const animations = this._createAnimations(options, newOptions);\r\n    if (newOptions.$shared) {\r\n      // Going to shared options:\r\n      // After all animations are done, assign the shared options object to the element\r\n      // So any new updates to the shared options are observed\r\n      awaitAll(target.options.$animations, newOptions).then(() => {\r\n        target.options = newOptions;\r\n      }, () => {\r\n        // rejected, noop\r\n      });\r\n    }\r\n\r\n    return animations;\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _createAnimations(target, values) {\r\n    const animatedProps = this._properties;\r\n    const animations = [];\r\n    const running = target.$animations || (target.$animations = {});\r\n    const props = Object.keys(values);\r\n    const date = Date.now();\r\n    let i;\r\n\r\n    for (i = props.length - 1; i >= 0; --i) {\r\n      const prop = props[i];\r\n      if (prop.charAt(0) === '$') {\r\n        continue;\r\n      }\r\n\r\n      if (prop === 'options') {\r\n        animations.push(...this._animateOptions(target, values));\r\n        continue;\r\n      }\r\n      const value = values[prop];\r\n      let animation = running[prop];\r\n      const cfg = animatedProps.get(prop);\r\n\r\n      if (animation) {\r\n        if (cfg && animation.active()) {\r\n          // There is an existing active animation, let's update that\r\n          animation.update(cfg, value, date);\r\n          continue;\r\n        } else {\r\n          animation.cancel();\r\n        }\r\n      }\r\n      if (!cfg || !cfg.duration) {\r\n        // not animated, set directly to new value\r\n        target[prop] = value;\r\n        continue;\r\n      }\r\n\r\n      running[prop] = animation = new Animation(cfg, target, prop, value);\r\n      animations.push(animation);\r\n    }\r\n    return animations;\r\n  }\r\n\r\n\r\n  /**\r\n\t * Update `target` properties to new values, using configured animations\r\n\t * @param {object} target - object to update\r\n\t * @param {object} values - new target properties\r\n\t * @returns {boolean|undefined} - `true` if animations were started\r\n\t **/\r\n  update(target, values) {\r\n    if (this._properties.size === 0) {\r\n      // Nothing is animated, just apply the new values.\r\n      Object.assign(target, values);\r\n      return;\r\n    }\r\n\r\n    const animations = this._createAnimations(target, values);\r\n\r\n    if (animations.length) {\r\n      animator.add(this._chart, animations);\r\n      return true;\r\n    }\r\n  }\r\n}\r\n\r\nfunction awaitAll(animations, properties) {\r\n  const running = [];\r\n  const keys = Object.keys(properties);\r\n  for (let i = 0; i < keys.length; i++) {\r\n    const anim = animations[keys[i]];\r\n    if (anim && anim.active()) {\r\n      running.push(anim.wait());\r\n    }\r\n  }\r\n  // @ts-ignore\r\n  return Promise.all(running);\r\n}\r\n\r\nfunction resolveTargetOptions(target, newOptions) {\r\n  if (!newOptions) {\r\n    return;\r\n  }\r\n  let options = target.options;\r\n  if (!options) {\r\n    target.options = newOptions;\r\n    return;\r\n  }\r\n  if (options.$shared) {\r\n    // Going from shared options to distinct one:\r\n    // Create new options object containing the old shared values and start updating that.\r\n    target.options = options = Object.assign({}, options, {$shared: false, $animations: {}});\r\n  }\r\n  return options;\r\n}\r\n","import Animations from './core.animations.js';\r\nimport defaults from './core.defaults.js';\r\nimport {isArray, isFinite, isObject, valueOrDefault, resolveObjectKey, defined} from '../helpers/helpers.core.js';\r\nimport {listenArrayEvents, unlistenArrayEvents} from '../helpers/helpers.collection.js';\r\nimport {createContext, sign} from '../helpers/index.js';\r\n\r\n/**\r\n * @typedef { import('./core.controller.js').default } Chart\r\n * @typedef { import('./core.scale.js').default } Scale\r\n */\r\n\r\nfunction scaleClip(scale, allowedOverflow) {\r\n  const opts = scale && scale.options || {};\r\n  const reverse = opts.reverse;\r\n  const min = opts.min === undefined ? allowedOverflow : 0;\r\n  const max = opts.max === undefined ? allowedOverflow : 0;\r\n  return {\r\n    start: reverse ? max : min,\r\n    end: reverse ? min : max\r\n  };\r\n}\r\n\r\nfunction defaultClip(xScale, yScale, allowedOverflow) {\r\n  if (allowedOverflow === false) {\r\n    return false;\r\n  }\r\n  const x = scaleClip(xScale, allowedOverflow);\r\n  const y = scaleClip(yScale, allowedOverflow);\r\n\r\n  return {\r\n    top: y.end,\r\n    right: x.end,\r\n    bottom: y.start,\r\n    left: x.start\r\n  };\r\n}\r\n\r\nfunction toClip(value) {\r\n  let t, r, b, l;\r\n\r\n  if (isObject(value)) {\r\n    t = value.top;\r\n    r = value.right;\r\n    b = value.bottom;\r\n    l = value.left;\r\n  } else {\r\n    t = r = b = l = value;\r\n  }\r\n\r\n  return {\r\n    top: t,\r\n    right: r,\r\n    bottom: b,\r\n    left: l,\r\n    disabled: value === false\r\n  };\r\n}\r\n\r\nfunction getSortedDatasetIndices(chart, filterVisible) {\r\n  const keys = [];\r\n  const metasets = chart._getSortedDatasetMetas(filterVisible);\r\n  let i, ilen;\r\n\r\n  for (i = 0, ilen = metasets.length; i < ilen; ++i) {\r\n    keys.push(metasets[i].index);\r\n  }\r\n  return keys;\r\n}\r\n\r\nfunction applyStack(stack, value, dsIndex, options = {}) {\r\n  const keys = stack.keys;\r\n  const singleMode = options.mode === 'single';\r\n  let i, ilen, datasetIndex, otherValue;\r\n\r\n  if (value === null) {\r\n    return;\r\n  }\r\n\r\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\r\n    datasetIndex = +keys[i];\r\n    if (datasetIndex === dsIndex) {\r\n      if (options.all) {\r\n        continue;\r\n      }\r\n      break;\r\n    }\r\n    otherValue = stack.values[datasetIndex];\r\n    if (isFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {\r\n      value += otherValue;\r\n    }\r\n  }\r\n  return value;\r\n}\r\n\r\nfunction convertObjectDataToArray(data) {\r\n  const keys = Object.keys(data);\r\n  const adata = new Array(keys.length);\r\n  let i, ilen, key;\r\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\r\n    key = keys[i];\r\n    adata[i] = {\r\n      x: key,\r\n      y: data[key]\r\n    };\r\n  }\r\n  return adata;\r\n}\r\n\r\nfunction isStacked(scale, meta) {\r\n  const stacked = scale && scale.options.stacked;\r\n  return stacked || (stacked === undefined && meta.stack !== undefined);\r\n}\r\n\r\nfunction getStackKey(indexScale, valueScale, meta) {\r\n  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\r\n}\r\n\r\nfunction getUserBounds(scale) {\r\n  const {min, max, minDefined, maxDefined} = scale.getUserBounds();\r\n  return {\r\n    min: minDefined ? min : Number.NEGATIVE_INFINITY,\r\n    max: maxDefined ? max : Number.POSITIVE_INFINITY\r\n  };\r\n}\r\n\r\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\r\n  const subStack = stacks[stackKey] || (stacks[stackKey] = {});\r\n  return subStack[indexValue] || (subStack[indexValue] = {});\r\n}\r\n\r\nfunction getLastIndexInStack(stack, vScale, positive, type) {\r\n  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {\r\n    const value = stack[meta.index];\r\n    if ((positive && value > 0) || (!positive && value < 0)) {\r\n      return meta.index;\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction updateStacks(controller, parsed) {\r\n  const {chart, _cachedMeta: meta} = controller;\r\n  const stacks = chart._stacks || (chart._stacks = {}); // map structure is {stackKey: {datasetIndex: value}}\r\n  const {iScale, vScale, index: datasetIndex} = meta;\r\n  const iAxis = iScale.axis;\r\n  const vAxis = vScale.axis;\r\n  const key = getStackKey(iScale, vScale, meta);\r\n  const ilen = parsed.length;\r\n  let stack;\r\n\r\n  for (let i = 0; i < ilen; ++i) {\r\n    const item = parsed[i];\r\n    const {[iAxis]: index, [vAxis]: value} = item;\r\n    const itemStacks = item._stacks || (item._stacks = {});\r\n    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\r\n    stack[datasetIndex] = value;\r\n\r\n    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);\r\n    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);\r\n\r\n    const visualValues = stack._visualValues || (stack._visualValues = {});\r\n    visualValues[datasetIndex] = value;\r\n  }\r\n}\r\n\r\nfunction getFirstScaleId(chart, axis) {\r\n  const scales = chart.scales;\r\n  return Object.keys(scales).filter(key => scales[key].axis === axis).shift();\r\n}\r\n\r\nfunction createDatasetContext(parent, index) {\r\n  return createContext(parent,\r\n    {\r\n      active: false,\r\n      dataset: undefined,\r\n      datasetIndex: index,\r\n      index,\r\n      mode: 'default',\r\n      type: 'dataset'\r\n    }\r\n  );\r\n}\r\n\r\nfunction createDataContext(parent, index, element) {\r\n  return createContext(parent, {\r\n    active: false,\r\n    dataIndex: index,\r\n    parsed: undefined,\r\n    raw: undefined,\r\n    element,\r\n    index,\r\n    mode: 'default',\r\n    type: 'data'\r\n  });\r\n}\r\n\r\nfunction clearStacks(meta, items) {\r\n  // Not using meta.index here, because it might be already updated if the dataset changed location\r\n  const datasetIndex = meta.controller.index;\r\n  const axis = meta.vScale && meta.vScale.axis;\r\n  if (!axis) {\r\n    return;\r\n  }\r\n\r\n  items = items || meta._parsed;\r\n  for (const parsed of items) {\r\n    const stacks = parsed._stacks;\r\n    if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\r\n      return;\r\n    }\r\n    delete stacks[axis][datasetIndex];\r\n    if (stacks[axis]._visualValues !== undefined && stacks[axis]._visualValues[datasetIndex] !== undefined) {\r\n      delete stacks[axis]._visualValues[datasetIndex];\r\n    }\r\n  }\r\n}\r\n\r\nconst isDirectUpdateMode = (mode) => mode === 'reset' || mode === 'none';\r\nconst cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);\r\nconst createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked\r\n  && {keys: getSortedDatasetIndices(chart, true), values: null};\r\n\r\nexport default class DatasetController {\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = {};\r\n\r\n  /**\r\n   * Element type used to generate a meta dataset (e.g. Chart.element.LineElement).\r\n   */\r\n  static datasetElementType = null;\r\n\r\n  /**\r\n   * Element type used to generate a meta data (e.g. Chart.element.PointElement).\r\n   */\r\n  static dataElementType = null;\r\n\r\n  /**\r\n\t * @param {Chart} chart\r\n\t * @param {number} datasetIndex\r\n\t */\r\n  constructor(chart, datasetIndex) {\r\n    this.chart = chart;\r\n    this._ctx = chart.ctx;\r\n    this.index = datasetIndex;\r\n    this._cachedDataOpts = {};\r\n    this._cachedMeta = this.getMeta();\r\n    this._type = this._cachedMeta.type;\r\n    this.options = undefined;\r\n    /** @type {boolean | object} */\r\n    this._parsing = false;\r\n    this._data = undefined;\r\n    this._objectData = undefined;\r\n    this._sharedOptions = undefined;\r\n    this._drawStart = undefined;\r\n    this._drawCount = undefined;\r\n    this.enableOptionSharing = false;\r\n    this.supportsDecimation = false;\r\n    this.$context = undefined;\r\n    this._syncList = [];\r\n    this.datasetElementType = new.target.datasetElementType;\r\n    this.dataElementType = new.target.dataElementType;\r\n\r\n    this.initialize();\r\n  }\r\n\r\n  initialize() {\r\n    const meta = this._cachedMeta;\r\n    this.configure();\r\n    this.linkScales();\r\n    meta._stacked = isStacked(meta.vScale, meta);\r\n    this.addElements();\r\n\r\n    if (this.options.fill && !this.chart.isPluginEnabled('filler')) {\r\n      console.warn(\"Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options\");\r\n    }\r\n  }\r\n\r\n  updateIndex(datasetIndex) {\r\n    if (this.index !== datasetIndex) {\r\n      clearStacks(this._cachedMeta);\r\n    }\r\n    this.index = datasetIndex;\r\n  }\r\n\r\n  linkScales() {\r\n    const chart = this.chart;\r\n    const meta = this._cachedMeta;\r\n    const dataset = this.getDataset();\r\n\r\n    const chooseId = (axis, x, y, r) => axis === 'x' ? x : axis === 'r' ? r : y;\r\n\r\n    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));\r\n    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));\r\n    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));\r\n    const indexAxis = meta.indexAxis;\r\n    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\r\n    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\r\n    meta.xScale = this.getScaleForId(xid);\r\n    meta.yScale = this.getScaleForId(yid);\r\n    meta.rScale = this.getScaleForId(rid);\r\n    meta.iScale = this.getScaleForId(iid);\r\n    meta.vScale = this.getScaleForId(vid);\r\n  }\r\n\r\n  getDataset() {\r\n    return this.chart.data.datasets[this.index];\r\n  }\r\n\r\n  getMeta() {\r\n    return this.chart.getDatasetMeta(this.index);\r\n  }\r\n\r\n  /**\r\n\t * @param {string} scaleID\r\n\t * @return {Scale}\r\n\t */\r\n  getScaleForId(scaleID) {\r\n    return this.chart.scales[scaleID];\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _getOtherScale(scale) {\r\n    const meta = this._cachedMeta;\r\n    return scale === meta.iScale\r\n      ? meta.vScale\r\n      : meta.iScale;\r\n  }\r\n\r\n  reset() {\r\n    this._update('reset');\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _destroy() {\r\n    const meta = this._cachedMeta;\r\n    if (this._data) {\r\n      unlistenArrayEvents(this._data, this);\r\n    }\r\n    if (meta._stacked) {\r\n      clearStacks(meta);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _dataCheck() {\r\n    const dataset = this.getDataset();\r\n    const data = dataset.data || (dataset.data = []);\r\n    const _data = this._data;\r\n\r\n    // In order to correctly handle data addition/deletion animation (an thus simulate\r\n    // real-time charts), we need to monitor these data modifications and synchronize\r\n    // the internal meta data accordingly.\r\n\r\n    if (isObject(data)) {\r\n      this._data = convertObjectDataToArray(data);\r\n    } else if (_data !== data) {\r\n      if (_data) {\r\n        // This case happens when the user replaced the data array instance.\r\n        unlistenArrayEvents(_data, this);\r\n        // Discard old parsed data and stacks\r\n        const meta = this._cachedMeta;\r\n        clearStacks(meta);\r\n        meta._parsed = [];\r\n      }\r\n      if (data && Object.isExtensible(data)) {\r\n        listenArrayEvents(data, this);\r\n      }\r\n      this._syncList = [];\r\n      this._data = data;\r\n    }\r\n  }\r\n\r\n  addElements() {\r\n    const meta = this._cachedMeta;\r\n\r\n    this._dataCheck();\r\n\r\n    if (this.datasetElementType) {\r\n      meta.dataset = new this.datasetElementType();\r\n    }\r\n  }\r\n\r\n  buildOrUpdateElements(resetNewElements) {\r\n    const meta = this._cachedMeta;\r\n    const dataset = this.getDataset();\r\n    let stackChanged = false;\r\n\r\n    this._dataCheck();\r\n\r\n    // make sure cached _stacked status is current\r\n    const oldStacked = meta._stacked;\r\n    meta._stacked = isStacked(meta.vScale, meta);\r\n\r\n    // detect change in stack option\r\n    if (meta.stack !== dataset.stack) {\r\n      stackChanged = true;\r\n      // remove values from old stack\r\n      clearStacks(meta);\r\n      meta.stack = dataset.stack;\r\n    }\r\n\r\n    // Re-sync meta data in case the user replaced the data array or if we missed\r\n    // any updates and so make sure that we handle number of datapoints changing.\r\n    this._resyncElements(resetNewElements);\r\n\r\n    // if stack changed, update stack values for the whole dataset\r\n    if (stackChanged || oldStacked !== meta._stacked) {\r\n      updateStacks(this, meta._parsed);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * Merges user-supplied and default dataset-level options\r\n\t * @private\r\n\t */\r\n  configure() {\r\n    const config = this.chart.config;\r\n    const scopeKeys = config.datasetScopeKeys(this._type);\r\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);\r\n    this.options = config.createResolver(scopes, this.getContext());\r\n    this._parsing = this.options.parsing;\r\n    this._cachedDataOpts = {};\r\n  }\r\n\r\n  /**\r\n\t * @param {number} start\r\n\t * @param {number} count\r\n\t */\r\n  parse(start, count) {\r\n    const {_cachedMeta: meta, _data: data} = this;\r\n    const {iScale, _stacked} = meta;\r\n    const iAxis = iScale.axis;\r\n\r\n    let sorted = start === 0 && count === data.length ? true : meta._sorted;\r\n    let prev = start > 0 && meta._parsed[start - 1];\r\n    let i, cur, parsed;\r\n\r\n    if (this._parsing === false) {\r\n      meta._parsed = data;\r\n      meta._sorted = true;\r\n      parsed = data;\r\n    } else {\r\n      if (isArray(data[start])) {\r\n        parsed = this.parseArrayData(meta, data, start, count);\r\n      } else if (isObject(data[start])) {\r\n        parsed = this.parseObjectData(meta, data, start, count);\r\n      } else {\r\n        parsed = this.parsePrimitiveData(meta, data, start, count);\r\n      }\r\n\r\n      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || (prev && cur[iAxis] < prev[iAxis]);\r\n      for (i = 0; i < count; ++i) {\r\n        meta._parsed[i + start] = cur = parsed[i];\r\n        if (sorted) {\r\n          if (isNotInOrderComparedToPrev()) {\r\n            sorted = false;\r\n          }\r\n          prev = cur;\r\n        }\r\n      }\r\n      meta._sorted = sorted;\r\n    }\r\n\r\n    if (_stacked) {\r\n      updateStacks(this, parsed);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * Parse array of primitive values\r\n\t * @param {object} meta - dataset meta\r\n\t * @param {array} data - data array. Example [1,3,4]\r\n\t * @param {number} start - start index\r\n\t * @param {number} count - number of items to parse\r\n\t * @returns {object} parsed item - item containing index and a parsed value\r\n\t * for each scale id.\r\n\t * Example: {xScale0: 0, yScale0: 1}\r\n\t * @protected\r\n\t */\r\n  parsePrimitiveData(meta, data, start, count) {\r\n    const {iScale, vScale} = meta;\r\n    const iAxis = iScale.axis;\r\n    const vAxis = vScale.axis;\r\n    const labels = iScale.getLabels();\r\n    const singleScale = iScale === vScale;\r\n    const parsed = new Array(count);\r\n    let i, ilen, index;\r\n\r\n    for (i = 0, ilen = count; i < ilen; ++i) {\r\n      index = i + start;\r\n      parsed[i] = {\r\n        [iAxis]: singleScale || iScale.parse(labels[index], index),\r\n        [vAxis]: vScale.parse(data[index], index)\r\n      };\r\n    }\r\n    return parsed;\r\n  }\r\n\r\n  /**\r\n\t * Parse array of arrays\r\n\t * @param {object} meta - dataset meta\r\n\t * @param {array} data - data array. Example [[1,2],[3,4]]\r\n\t * @param {number} start - start index\r\n\t * @param {number} count - number of items to parse\r\n\t * @returns {object} parsed item - item containing index and a parsed value\r\n\t * for each scale id.\r\n\t * Example: {x: 0, y: 1}\r\n\t * @protected\r\n\t */\r\n  parseArrayData(meta, data, start, count) {\r\n    const {xScale, yScale} = meta;\r\n    const parsed = new Array(count);\r\n    let i, ilen, index, item;\r\n\r\n    for (i = 0, ilen = count; i < ilen; ++i) {\r\n      index = i + start;\r\n      item = data[index];\r\n      parsed[i] = {\r\n        x: xScale.parse(item[0], index),\r\n        y: yScale.parse(item[1], index)\r\n      };\r\n    }\r\n    return parsed;\r\n  }\r\n\r\n  /**\r\n\t * Parse array of objects\r\n\t * @param {object} meta - dataset meta\r\n\t * @param {array} data - data array. Example [{x:1, y:5}, {x:2, y:10}]\r\n\t * @param {number} start - start index\r\n\t * @param {number} count - number of items to parse\r\n\t * @returns {object} parsed item - item containing index and a parsed value\r\n\t * for each scale id. _custom is optional\r\n\t * Example: {xScale0: 0, yScale0: 1, _custom: {r: 10, foo: 'bar'}}\r\n\t * @protected\r\n\t */\r\n  parseObjectData(meta, data, start, count) {\r\n    const {xScale, yScale} = meta;\r\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\r\n    const parsed = new Array(count);\r\n    let i, ilen, index, item;\r\n\r\n    for (i = 0, ilen = count; i < ilen; ++i) {\r\n      index = i + start;\r\n      item = data[index];\r\n      parsed[i] = {\r\n        x: xScale.parse(resolveObjectKey(item, xAxisKey), index),\r\n        y: yScale.parse(resolveObjectKey(item, yAxisKey), index)\r\n      };\r\n    }\r\n    return parsed;\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  getParsed(index) {\r\n    return this._cachedMeta._parsed[index];\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  getDataElement(index) {\r\n    return this._cachedMeta.data[index];\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  applyStack(scale, parsed, mode) {\r\n    const chart = this.chart;\r\n    const meta = this._cachedMeta;\r\n    const value = parsed[scale.axis];\r\n    const stack = {\r\n      keys: getSortedDatasetIndices(chart, true),\r\n      values: parsed._stacks[scale.axis]._visualValues\r\n    };\r\n    return applyStack(stack, value, meta.index, {mode});\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  updateRangeFromParsed(range, scale, parsed, stack) {\r\n    const parsedValue = parsed[scale.axis];\r\n    let value = parsedValue === null ? NaN : parsedValue;\r\n    const values = stack && parsed._stacks[scale.axis];\r\n    if (stack && values) {\r\n      stack.values = values;\r\n      value = applyStack(stack, parsedValue, this._cachedMeta.index);\r\n    }\r\n    range.min = Math.min(range.min, value);\r\n    range.max = Math.max(range.max, value);\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  getMinMax(scale, canStack) {\r\n    const meta = this._cachedMeta;\r\n    const _parsed = meta._parsed;\r\n    const sorted = meta._sorted && scale === meta.iScale;\r\n    const ilen = _parsed.length;\r\n    const otherScale = this._getOtherScale(scale);\r\n    const stack = createStack(canStack, meta, this.chart);\r\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\r\n    const {min: otherMin, max: otherMax} = getUserBounds(otherScale);\r\n    let i, parsed;\r\n\r\n    function _skip() {\r\n      parsed = _parsed[i];\r\n      const otherValue = parsed[otherScale.axis];\r\n      return !isFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;\r\n    }\r\n\r\n    for (i = 0; i < ilen; ++i) {\r\n      if (_skip()) {\r\n        continue;\r\n      }\r\n      this.updateRangeFromParsed(range, scale, parsed, stack);\r\n      if (sorted) {\r\n        // if the data is sorted, we don't need to check further from this end of array\r\n        break;\r\n      }\r\n    }\r\n    if (sorted) {\r\n      // in the sorted case, find first non-skipped value from other end of array\r\n      for (i = ilen - 1; i >= 0; --i) {\r\n        if (_skip()) {\r\n          continue;\r\n        }\r\n        this.updateRangeFromParsed(range, scale, parsed, stack);\r\n        break;\r\n      }\r\n    }\r\n    return range;\r\n  }\r\n\r\n  getAllParsedValues(scale) {\r\n    const parsed = this._cachedMeta._parsed;\r\n    const values = [];\r\n    let i, ilen, value;\r\n\r\n    for (i = 0, ilen = parsed.length; i < ilen; ++i) {\r\n      value = parsed[i][scale.axis];\r\n      if (isFinite(value)) {\r\n        values.push(value);\r\n      }\r\n    }\r\n    return values;\r\n  }\r\n\r\n  /**\r\n\t * @return {number|boolean}\r\n\t * @protected\r\n\t */\r\n  getMaxOverflow() {\r\n    return false;\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  getLabelAndValue(index) {\r\n    const meta = this._cachedMeta;\r\n    const iScale = meta.iScale;\r\n    const vScale = meta.vScale;\r\n    const parsed = this.getParsed(index);\r\n    return {\r\n      label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',\r\n      value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''\r\n    };\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _update(mode) {\r\n    const meta = this._cachedMeta;\r\n    this.update(mode || 'default');\r\n    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));\r\n  }\r\n\r\n  /**\r\n\t * @param {string} mode\r\n\t */\r\n  update(mode) {} // eslint-disable-line no-unused-vars\r\n\r\n  draw() {\r\n    const ctx = this._ctx;\r\n    const chart = this.chart;\r\n    const meta = this._cachedMeta;\r\n    const elements = meta.data || [];\r\n    const area = chart.chartArea;\r\n    const active = [];\r\n    const start = this._drawStart || 0;\r\n    const count = this._drawCount || (elements.length - start);\r\n    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;\r\n    let i;\r\n\r\n    if (meta.dataset) {\r\n      meta.dataset.draw(ctx, area, start, count);\r\n    }\r\n\r\n    for (i = start; i < start + count; ++i) {\r\n      const element = elements[i];\r\n      if (element.hidden) {\r\n        continue;\r\n      }\r\n      if (element.active && drawActiveElementsOnTop) {\r\n        active.push(element);\r\n      } else {\r\n        element.draw(ctx, area);\r\n      }\r\n    }\r\n\r\n    for (i = 0; i < active.length; ++i) {\r\n      active[i].draw(ctx, area);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * Returns a set of predefined style properties that should be used to represent the dataset\r\n\t * or the data if the index is specified\r\n\t * @param {number} index - data index\r\n\t * @param {boolean} [active] - true if hover\r\n\t * @return {object} style object\r\n\t */\r\n  getStyle(index, active) {\r\n    const mode = active ? 'active' : 'default';\r\n    return index === undefined && this._cachedMeta.dataset\r\n      ? this.resolveDatasetElementOptions(mode)\r\n      : this.resolveDataElementOptions(index || 0, mode);\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  getContext(index, active, mode) {\r\n    const dataset = this.getDataset();\r\n    let context;\r\n    if (index >= 0 && index < this._cachedMeta.data.length) {\r\n      const element = this._cachedMeta.data[index];\r\n      context = element.$context ||\r\n        (element.$context = createDataContext(this.getContext(), index, element));\r\n      context.parsed = this.getParsed(index);\r\n      context.raw = dataset.data[index];\r\n      context.index = context.dataIndex = index;\r\n    } else {\r\n      context = this.$context ||\r\n        (this.$context = createDatasetContext(this.chart.getContext(), this.index));\r\n      context.dataset = dataset;\r\n      context.index = context.datasetIndex = this.index;\r\n    }\r\n\r\n    context.active = !!active;\r\n    context.mode = mode;\r\n    return context;\r\n  }\r\n\r\n  /**\r\n\t * @param {string} [mode]\r\n\t * @protected\r\n\t */\r\n  resolveDatasetElementOptions(mode) {\r\n    return this._resolveElementOptions(this.datasetElementType.id, mode);\r\n  }\r\n\r\n  /**\r\n\t * @param {number} index\r\n\t * @param {string} [mode]\r\n\t * @protected\r\n\t */\r\n  resolveDataElementOptions(index, mode) {\r\n    return this._resolveElementOptions(this.dataElementType.id, mode, index);\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _resolveElementOptions(elementType, mode = 'default', index) {\r\n    const active = mode === 'active';\r\n    const cache = this._cachedDataOpts;\r\n    const cacheKey = elementType + '-' + mode;\r\n    const cached = cache[cacheKey];\r\n    const sharing = this.enableOptionSharing && defined(index);\r\n    if (cached) {\r\n      return cloneIfNotShared(cached, sharing);\r\n    }\r\n    const config = this.chart.config;\r\n    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);\r\n    const prefixes = active ? [`${elementType}Hover`, 'hover', elementType, ''] : [elementType, ''];\r\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\r\n    const names = Object.keys(defaults.elements[elementType]);\r\n    // context is provided as a function, and is called only if needed,\r\n    // so we don't create a context for each element if not needed.\r\n    const context = () => this.getContext(index, active, mode);\r\n    const values = config.resolveNamedOptions(scopes, names, context, prefixes);\r\n\r\n    if (values.$shared) {\r\n      // `$shared` indicates this set of options can be shared between multiple elements.\r\n      // Sharing is used to reduce number of properties to change during animation.\r\n      values.$shared = sharing;\r\n\r\n      // We cache options by `mode`, which can be 'active' for example. This enables us\r\n      // to have the 'active' element options and 'default' options to switch between\r\n      // when interacting.\r\n      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\r\n    }\r\n\r\n    return values;\r\n  }\r\n\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _resolveAnimations(index, transition, active) {\r\n    const chart = this.chart;\r\n    const cache = this._cachedDataOpts;\r\n    const cacheKey = `animation-${transition}`;\r\n    const cached = cache[cacheKey];\r\n    if (cached) {\r\n      return cached;\r\n    }\r\n    let options;\r\n    if (chart.options.animation !== false) {\r\n      const config = this.chart.config;\r\n      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);\r\n      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\r\n      options = config.createResolver(scopes, this.getContext(index, active, transition));\r\n    }\r\n    const animations = new Animations(chart, options && options.animations);\r\n    if (options && options._cacheable) {\r\n      cache[cacheKey] = Object.freeze(animations);\r\n    }\r\n    return animations;\r\n  }\r\n\r\n  /**\r\n\t * Utility for getting the options object shared between elements\r\n\t * @protected\r\n\t */\r\n  getSharedOptions(options) {\r\n    if (!options.$shared) {\r\n      return;\r\n    }\r\n    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\r\n  }\r\n\r\n  /**\r\n\t * Utility for determining if `options` should be included in the updated properties\r\n\t * @protected\r\n\t */\r\n  includeOptions(mode, sharedOptions) {\r\n    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\r\n  }\r\n\r\n  /**\r\n   * @todo v4, rename to getSharedOptions and remove excess functions\r\n   */\r\n  _getSharedOptions(start, mode) {\r\n    const firstOpts = this.resolveDataElementOptions(start, mode);\r\n    const previouslySharedOptions = this._sharedOptions;\r\n    const sharedOptions = this.getSharedOptions(firstOpts);\r\n    const includeOptions = this.includeOptions(mode, sharedOptions) || (sharedOptions !== previouslySharedOptions);\r\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\r\n    return {sharedOptions, includeOptions};\r\n  }\r\n\r\n  /**\r\n\t * Utility for updating an element with new properties, using animations when appropriate.\r\n\t * @protected\r\n\t */\r\n  updateElement(element, index, properties, mode) {\r\n    if (isDirectUpdateMode(mode)) {\r\n      Object.assign(element, properties);\r\n    } else {\r\n      this._resolveAnimations(index, mode).update(element, properties);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * Utility to animate the shared options, that are potentially affecting multiple elements.\r\n\t * @protected\r\n\t */\r\n  updateSharedOptions(sharedOptions, mode, newOptions) {\r\n    if (sharedOptions && !isDirectUpdateMode(mode)) {\r\n      this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _setStyle(element, index, mode, active) {\r\n    element.active = active;\r\n    const options = this.getStyle(index, active);\r\n    this._resolveAnimations(index, mode, active).update(element, {\r\n      // When going from active to inactive, we need to update to the shared options.\r\n      // This way the once hovered element will end up with the same original shared options instance, after animation.\r\n      options: (!active && this.getSharedOptions(options)) || options\r\n    });\r\n  }\r\n\r\n  removeHoverStyle(element, datasetIndex, index) {\r\n    this._setStyle(element, index, 'active', false);\r\n  }\r\n\r\n  setHoverStyle(element, datasetIndex, index) {\r\n    this._setStyle(element, index, 'active', true);\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _removeDatasetHoverStyle() {\r\n    const element = this._cachedMeta.dataset;\r\n\r\n    if (element) {\r\n      this._setStyle(element, undefined, 'active', false);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _setDatasetHoverStyle() {\r\n    const element = this._cachedMeta.dataset;\r\n\r\n    if (element) {\r\n      this._setStyle(element, undefined, 'active', true);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _resyncElements(resetNewElements) {\r\n    const data = this._data;\r\n    const elements = this._cachedMeta.data;\r\n\r\n    // Apply changes detected through array listeners\r\n    for (const [method, arg1, arg2] of this._syncList) {\r\n      this[method](arg1, arg2);\r\n    }\r\n    this._syncList = [];\r\n\r\n    const numMeta = elements.length;\r\n    const numData = data.length;\r\n    const count = Math.min(numData, numMeta);\r\n\r\n    if (count) {\r\n      // TODO: It is not optimal to always parse the old data\r\n      // This is done because we are not detecting direct assignments:\r\n      // chart.data.datasets[0].data[5] = 10;\r\n      // chart.data.datasets[0].data[5].y = 10;\r\n      this.parse(0, count);\r\n    }\r\n\r\n    if (numData > numMeta) {\r\n      this._insertElements(numMeta, numData - numMeta, resetNewElements);\r\n    } else if (numData < numMeta) {\r\n      this._removeElements(numData, numMeta - numData);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _insertElements(start, count, resetNewElements = true) {\r\n    const meta = this._cachedMeta;\r\n    const data = meta.data;\r\n    const end = start + count;\r\n    let i;\r\n\r\n    const move = (arr) => {\r\n      arr.length += count;\r\n      for (i = arr.length - 1; i >= end; i--) {\r\n        arr[i] = arr[i - count];\r\n      }\r\n    };\r\n    move(data);\r\n\r\n    for (i = start; i < end; ++i) {\r\n      data[i] = new this.dataElementType();\r\n    }\r\n\r\n    if (this._parsing) {\r\n      move(meta._parsed);\r\n    }\r\n    this.parse(start, count);\r\n\r\n    if (resetNewElements) {\r\n      this.updateElements(data, start, count, 'reset');\r\n    }\r\n  }\r\n\r\n  updateElements(element, start, count, mode) {} // eslint-disable-line no-unused-vars\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _removeElements(start, count) {\r\n    const meta = this._cachedMeta;\r\n    if (this._parsing) {\r\n      const removed = meta._parsed.splice(start, count);\r\n      if (meta._stacked) {\r\n        clearStacks(meta, removed);\r\n      }\r\n    }\r\n    meta.data.splice(start, count);\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n   */\r\n  _sync(args) {\r\n    if (this._parsing) {\r\n      this._syncList.push(args);\r\n    } else {\r\n      const [method, arg1, arg2] = args;\r\n      this[method](arg1, arg2);\r\n    }\r\n    this.chart._dataChanges.push([this.index, ...args]);\r\n  }\r\n\r\n  _onDataPush() {\r\n    const count = arguments.length;\r\n    this._sync(['_insertElements', this.getDataset().data.length - count, count]);\r\n  }\r\n\r\n  _onDataPop() {\r\n    this._sync(['_removeElements', this._cachedMeta.data.length - 1, 1]);\r\n  }\r\n\r\n  _onDataShift() {\r\n    this._sync(['_removeElements', 0, 1]);\r\n  }\r\n\r\n  _onDataSplice(start, count) {\r\n    if (count) {\r\n      this._sync(['_removeElements', start, count]);\r\n    }\r\n    const newCount = arguments.length - 2;\r\n    if (newCount) {\r\n      this._sync(['_insertElements', start, newCount]);\r\n    }\r\n  }\r\n\r\n  _onDataUnshift() {\r\n    this._sync(['_insertElements', 0, arguments.length]);\r\n  }\r\n}\r\n","import DatasetController from '../core/core.datasetController.js';\r\nimport {\r\n  _arrayUnique, isArray, isNullOrUndef,\r\n  valueOrDefault, resolveObjectKey, sign, defined\r\n} from '../helpers/index.js';\r\n\r\nfunction getAllScaleValues(scale, type) {\r\n  if (!scale._cache.$bar) {\r\n    const visibleMetas = scale.getMatchingVisibleMetas(type);\r\n    let values = [];\r\n\r\n    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {\r\n      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));\r\n    }\r\n    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));\r\n  }\r\n  return scale._cache.$bar;\r\n}\r\n\r\n/**\r\n * Computes the \"optimal\" sample size to maintain bars equally sized while preventing overlap.\r\n * @private\r\n */\r\nfunction computeMinSampleSize(meta) {\r\n  const scale = meta.iScale;\r\n  const values = getAllScaleValues(scale, meta.type);\r\n  let min = scale._length;\r\n  let i, ilen, curr, prev;\r\n  const updateMinAndPrev = () => {\r\n    if (curr === 32767 || curr === -32768) {\r\n      // Ignore truncated pixels\r\n      return;\r\n    }\r\n    if (defined(prev)) {\r\n      // curr - prev === 0 is ignored\r\n      min = Math.min(min, Math.abs(curr - prev) || min);\r\n    }\r\n    prev = curr;\r\n  };\r\n\r\n  for (i = 0, ilen = values.length; i < ilen; ++i) {\r\n    curr = scale.getPixelForValue(values[i]);\r\n    updateMinAndPrev();\r\n  }\r\n\r\n  prev = undefined;\r\n  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {\r\n    curr = scale.getPixelForTick(i);\r\n    updateMinAndPrev();\r\n  }\r\n\r\n  return min;\r\n}\r\n\r\n/**\r\n * Computes an \"ideal\" category based on the absolute bar thickness or, if undefined or null,\r\n * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This\r\n * mode currently always generates bars equally sized (until we introduce scriptable options?).\r\n * @private\r\n */\r\nfunction computeFitCategoryTraits(index, ruler, options, stackCount) {\r\n  const thickness = options.barThickness;\r\n  let size, ratio;\r\n\r\n  if (isNullOrUndef(thickness)) {\r\n    size = ruler.min * options.categoryPercentage;\r\n    ratio = options.barPercentage;\r\n  } else {\r\n    // When bar thickness is enforced, category and bar percentages are ignored.\r\n    // Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')\r\n    // and deprecate barPercentage since this value is ignored when thickness is absolute.\r\n    size = thickness * stackCount;\r\n    ratio = 1;\r\n  }\r\n\r\n  return {\r\n    chunk: size / stackCount,\r\n    ratio,\r\n    start: ruler.pixels[index] - (size / 2)\r\n  };\r\n}\r\n\r\n/**\r\n * Computes an \"optimal\" category that globally arranges bars side by side (no gap when\r\n * percentage options are 1), based on the previous and following categories. This mode\r\n * generates bars with different widths when data are not evenly spaced.\r\n * @private\r\n */\r\nfunction computeFlexCategoryTraits(index, ruler, options, stackCount) {\r\n  const pixels = ruler.pixels;\r\n  const curr = pixels[index];\r\n  let prev = index > 0 ? pixels[index - 1] : null;\r\n  let next = index < pixels.length - 1 ? pixels[index + 1] : null;\r\n  const percent = options.categoryPercentage;\r\n\r\n  if (prev === null) {\r\n    // first data: its size is double based on the next point or,\r\n    // if it's also the last data, we use the scale size.\r\n    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\r\n  }\r\n\r\n  if (next === null) {\r\n    // last data: its size is also double based on the previous point.\r\n    next = curr + curr - prev;\r\n  }\r\n\r\n  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\r\n  const size = Math.abs(next - prev) / 2 * percent;\r\n\r\n  return {\r\n    chunk: size / stackCount,\r\n    ratio: options.barPercentage,\r\n    start\r\n  };\r\n}\r\n\r\nfunction parseFloatBar(entry, item, vScale, i) {\r\n  const startValue = vScale.parse(entry[0], i);\r\n  const endValue = vScale.parse(entry[1], i);\r\n  const min = Math.min(startValue, endValue);\r\n  const max = Math.max(startValue, endValue);\r\n  let barStart = min;\r\n  let barEnd = max;\r\n\r\n  if (Math.abs(min) > Math.abs(max)) {\r\n    barStart = max;\r\n    barEnd = min;\r\n  }\r\n\r\n  // Store `barEnd` (furthest away from origin) as parsed value,\r\n  // to make stacking straight forward\r\n  item[vScale.axis] = barEnd;\r\n\r\n  item._custom = {\r\n    barStart,\r\n    barEnd,\r\n    start: startValue,\r\n    end: endValue,\r\n    min,\r\n    max\r\n  };\r\n}\r\n\r\nfunction parseValue(entry, item, vScale, i) {\r\n  if (isArray(entry)) {\r\n    parseFloatBar(entry, item, vScale, i);\r\n  } else {\r\n    item[vScale.axis] = vScale.parse(entry, i);\r\n  }\r\n  return item;\r\n}\r\n\r\nfunction parseArrayOrPrimitive(meta, data, start, count) {\r\n  const iScale = meta.iScale;\r\n  const vScale = meta.vScale;\r\n  const labels = iScale.getLabels();\r\n  const singleScale = iScale === vScale;\r\n  const parsed = [];\r\n  let i, ilen, item, entry;\r\n\r\n  for (i = start, ilen = start + count; i < ilen; ++i) {\r\n    entry = data[i];\r\n    item = {};\r\n    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\r\n    parsed.push(parseValue(entry, item, vScale, i));\r\n  }\r\n  return parsed;\r\n}\r\n\r\nfunction isFloatBar(custom) {\r\n  return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\r\n}\r\n\r\nfunction barSign(size, vScale, actualBase) {\r\n  if (size !== 0) {\r\n    return sign(size);\r\n  }\r\n  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\r\n}\r\n\r\nfunction borderProps(properties) {\r\n  let reverse, start, end, top, bottom;\r\n  if (properties.horizontal) {\r\n    reverse = properties.base > properties.x;\r\n    start = 'left';\r\n    end = 'right';\r\n  } else {\r\n    reverse = properties.base < properties.y;\r\n    start = 'bottom';\r\n    end = 'top';\r\n  }\r\n  if (reverse) {\r\n    top = 'end';\r\n    bottom = 'start';\r\n  } else {\r\n    top = 'start';\r\n    bottom = 'end';\r\n  }\r\n  return {start, end, reverse, top, bottom};\r\n}\r\n\r\nfunction setBorderSkipped(properties, options, stack, index) {\r\n  let edge = options.borderSkipped;\r\n  const res = {};\r\n\r\n  if (!edge) {\r\n    properties.borderSkipped = res;\r\n    return;\r\n  }\r\n\r\n  if (edge === true) {\r\n    properties.borderSkipped = {top: true, right: true, bottom: true, left: true};\r\n    return;\r\n  }\r\n\r\n  const {start, end, reverse, top, bottom} = borderProps(properties);\r\n\r\n  if (edge === 'middle' && stack) {\r\n    properties.enableBorderRadius = true;\r\n    if ((stack._top || 0) === index) {\r\n      edge = top;\r\n    } else if ((stack._bottom || 0) === index) {\r\n      edge = bottom;\r\n    } else {\r\n      res[parseEdge(bottom, start, end, reverse)] = true;\r\n      edge = top;\r\n    }\r\n  }\r\n\r\n  res[parseEdge(edge, start, end, reverse)] = true;\r\n  properties.borderSkipped = res;\r\n}\r\n\r\nfunction parseEdge(edge, a, b, reverse) {\r\n  if (reverse) {\r\n    edge = swap(edge, a, b);\r\n    edge = startEnd(edge, b, a);\r\n  } else {\r\n    edge = startEnd(edge, a, b);\r\n  }\r\n  return edge;\r\n}\r\n\r\nfunction swap(orig, v1, v2) {\r\n  return orig === v1 ? v2 : orig === v2 ? v1 : orig;\r\n}\r\n\r\nfunction startEnd(v, start, end) {\r\n  return v === 'start' ? start : v === 'end' ? end : v;\r\n}\r\n\r\nfunction setInflateAmount(properties, {inflateAmount}, ratio) {\r\n  properties.inflateAmount = inflateAmount === 'auto'\r\n    ? ratio === 1 ? 0.33 : 0\r\n    : inflateAmount;\r\n}\r\n\r\nexport default class BarController extends DatasetController {\r\n\r\n  static id = 'bar';\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = {\r\n    datasetElementType: false,\r\n    dataElementType: 'bar',\r\n\r\n    categoryPercentage: 0.8,\r\n    barPercentage: 0.9,\r\n    grouped: true,\r\n\r\n    animations: {\r\n      numbers: {\r\n        type: 'number',\r\n        properties: ['x', 'y', 'base', 'width', 'height']\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static overrides = {\r\n    scales: {\r\n      _index_: {\r\n        type: 'category',\r\n        offset: true,\r\n        grid: {\r\n          offset: true\r\n        }\r\n      },\r\n      _value_: {\r\n        type: 'linear',\r\n        beginAtZero: true,\r\n      }\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n\t * Overriding primitive data parsing since we support mixed primitive/array\r\n\t * data for float bars\r\n\t * @protected\r\n\t */\r\n  parsePrimitiveData(meta, data, start, count) {\r\n    return parseArrayOrPrimitive(meta, data, start, count);\r\n  }\r\n\r\n  /**\r\n\t * Overriding array data parsing since we support mixed primitive/array\r\n\t * data for float bars\r\n\t * @protected\r\n\t */\r\n  parseArrayData(meta, data, start, count) {\r\n    return parseArrayOrPrimitive(meta, data, start, count);\r\n  }\r\n\r\n  /**\r\n\t * Overriding object data parsing since we support mixed primitive/array\r\n\t * value-scale data for float bars\r\n\t * @protected\r\n\t */\r\n  parseObjectData(meta, data, start, count) {\r\n    const {iScale, vScale} = meta;\r\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\r\n    const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;\r\n    const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;\r\n    const parsed = [];\r\n    let i, ilen, item, obj;\r\n    for (i = start, ilen = start + count; i < ilen; ++i) {\r\n      obj = data[i];\r\n      item = {};\r\n      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);\r\n      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));\r\n    }\r\n    return parsed;\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  updateRangeFromParsed(range, scale, parsed, stack) {\r\n    super.updateRangeFromParsed(range, scale, parsed, stack);\r\n    const custom = parsed._custom;\r\n    if (custom && scale === this._cachedMeta.vScale) {\r\n      // float bar: only one end of the bar is considered by `super`\r\n      range.min = Math.min(range.min, custom.min);\r\n      range.max = Math.max(range.max, custom.max);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @return {number|boolean}\r\n\t * @protected\r\n\t */\r\n  getMaxOverflow() {\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  getLabelAndValue(index) {\r\n    const meta = this._cachedMeta;\r\n    const {iScale, vScale} = meta;\r\n    const parsed = this.getParsed(index);\r\n    const custom = parsed._custom;\r\n    const value = isFloatBar(custom)\r\n      ? '[' + custom.start + ', ' + custom.end + ']'\r\n      : '' + vScale.getLabelForValue(parsed[vScale.axis]);\r\n\r\n    return {\r\n      label: '' + iScale.getLabelForValue(parsed[iScale.axis]),\r\n      value\r\n    };\r\n  }\r\n\r\n  initialize() {\r\n    this.enableOptionSharing = true;\r\n\r\n    super.initialize();\r\n\r\n    const meta = this._cachedMeta;\r\n    meta.stack = this.getDataset().stack;\r\n  }\r\n\r\n  update(mode) {\r\n    const meta = this._cachedMeta;\r\n    this.updateElements(meta.data, 0, meta.data.length, mode);\r\n  }\r\n\r\n  updateElements(bars, start, count, mode) {\r\n    const reset = mode === 'reset';\r\n    const {index, _cachedMeta: {vScale}} = this;\r\n    const base = vScale.getBasePixel();\r\n    const horizontal = vScale.isHorizontal();\r\n    const ruler = this._getRuler();\r\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\r\n\r\n    for (let i = start; i < start + count; i++) {\r\n      const parsed = this.getParsed(i);\r\n      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {base, head: base} : this._calculateBarValuePixels(i);\r\n      const ipixels = this._calculateBarIndexPixels(i, ruler);\r\n      const stack = (parsed._stacks || {})[vScale.axis];\r\n\r\n      const properties = {\r\n        horizontal,\r\n        base: vpixels.base,\r\n        enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index === stack._top || index === stack._bottom),\r\n        x: horizontal ? vpixels.head : ipixels.center,\r\n        y: horizontal ? ipixels.center : vpixels.head,\r\n        height: horizontal ? ipixels.size : Math.abs(vpixels.size),\r\n        width: horizontal ? Math.abs(vpixels.size) : ipixels.size\r\n      };\r\n\r\n      if (includeOptions) {\r\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);\r\n      }\r\n      const options = properties.options || bars[i].options;\r\n      setBorderSkipped(properties, options, stack, index);\r\n      setInflateAmount(properties, options, ruler.ratio);\r\n      this.updateElement(bars[i], i, properties, mode);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * Returns the stacks based on groups and bar visibility.\r\n\t * @param {number} [last] - The dataset index\r\n\t * @param {number} [dataIndex] - The data index of the ruler\r\n\t * @returns {string[]} The list of stack IDs\r\n\t * @private\r\n\t */\r\n  _getStacks(last, dataIndex) {\r\n    const {iScale} = this._cachedMeta;\r\n    const metasets = iScale.getMatchingVisibleMetas(this._type)\r\n      .filter(meta => meta.controller.options.grouped);\r\n    const stacked = iScale.options.stacked;\r\n    const stacks = [];\r\n\r\n    const skipNull = (meta) => {\r\n      const parsed = meta.controller.getParsed(dataIndex);\r\n      const val = parsed && parsed[meta.vScale.axis];\r\n\r\n      if (isNullOrUndef(val) || isNaN(val)) {\r\n        return true;\r\n      }\r\n    };\r\n\r\n    for (const meta of metasets) {\r\n      if (dataIndex !== undefined && skipNull(meta)) {\r\n        continue;\r\n      }\r\n\r\n      // stacked   | meta.stack\r\n      //           | found | not found | undefined\r\n      // false     |   x   |     x     |     x\r\n      // true      |       |     x     |\r\n      // undefined |       |     x     |     x\r\n      if (stacked === false || stacks.indexOf(meta.stack) === -1 ||\r\n\t\t\t\t(stacked === undefined && meta.stack === undefined)) {\r\n        stacks.push(meta.stack);\r\n      }\r\n      if (meta.index === last) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    // No stacks? that means there is no visible data. Let's still initialize an `undefined`\r\n    // stack where possible invisible bars will be located.\r\n    // https://github.com/chartjs/Chart.js/issues/6368\r\n    if (!stacks.length) {\r\n      stacks.push(undefined);\r\n    }\r\n\r\n    return stacks;\r\n  }\r\n\r\n  /**\r\n\t * Returns the effective number of stacks based on groups and bar visibility.\r\n\t * @private\r\n\t */\r\n  _getStackCount(index) {\r\n    return this._getStacks(undefined, index).length;\r\n  }\r\n\r\n  /**\r\n\t * Returns the stack index for the given dataset based on groups and bar visibility.\r\n\t * @param {number} [datasetIndex] - The dataset index\r\n\t * @param {string} [name] - The stack name to find\r\n   * @param {number} [dataIndex]\r\n\t * @returns {number} The stack index\r\n\t * @private\r\n\t */\r\n  _getStackIndex(datasetIndex, name, dataIndex) {\r\n    const stacks = this._getStacks(datasetIndex, dataIndex);\r\n    const index = (name !== undefined)\r\n      ? stacks.indexOf(name)\r\n      : -1; // indexOf returns -1 if element is not present\r\n\r\n    return (index === -1)\r\n      ? stacks.length - 1\r\n      : index;\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _getRuler() {\r\n    const opts = this.options;\r\n    const meta = this._cachedMeta;\r\n    const iScale = meta.iScale;\r\n    const pixels = [];\r\n    let i, ilen;\r\n\r\n    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {\r\n      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));\r\n    }\r\n\r\n    const barThickness = opts.barThickness;\r\n    const min = barThickness || computeMinSampleSize(meta);\r\n\r\n    return {\r\n      min,\r\n      pixels,\r\n      start: iScale._startPixel,\r\n      end: iScale._endPixel,\r\n      stackCount: this._getStackCount(),\r\n      scale: iScale,\r\n      grouped: opts.grouped,\r\n      // bar thickness ratio used for non-grouped bars\r\n      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\r\n    };\r\n  }\r\n\r\n  /**\r\n\t * Note: pixel values are not clamped to the scale area.\r\n\t * @private\r\n\t */\r\n  _calculateBarValuePixels(index) {\r\n    const {_cachedMeta: {vScale, _stacked, index: datasetIndex}, options: {base: baseValue, minBarLength}} = this;\r\n    const actualBase = baseValue || 0;\r\n    const parsed = this.getParsed(index);\r\n    const custom = parsed._custom;\r\n    const floating = isFloatBar(custom);\r\n    let value = parsed[vScale.axis];\r\n    let start = 0;\r\n    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;\r\n    let head, size;\r\n\r\n    if (length !== value) {\r\n      start = length - value;\r\n      length = value;\r\n    }\r\n\r\n    if (floating) {\r\n      value = custom.barStart;\r\n      length = custom.barEnd - custom.barStart;\r\n      // bars crossing origin are not stacked\r\n      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {\r\n        start = 0;\r\n      }\r\n      start += value;\r\n    }\r\n\r\n    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;\r\n    let base = vScale.getPixelForValue(startValue);\r\n\r\n    if (this.chart.getDataVisibility(index)) {\r\n      head = vScale.getPixelForValue(start + length);\r\n    } else {\r\n      // When not visible, no height\r\n      head = base;\r\n    }\r\n\r\n    size = head - base;\r\n\r\n    if (Math.abs(size) < minBarLength) {\r\n      size = barSign(size, vScale, actualBase) * minBarLength;\r\n      if (value === actualBase) {\r\n        base -= size / 2;\r\n      }\r\n      const startPixel = vScale.getPixelForDecimal(0);\r\n      const endPixel = vScale.getPixelForDecimal(1);\r\n      const min = Math.min(startPixel, endPixel);\r\n      const max = Math.max(startPixel, endPixel);\r\n      base = Math.max(Math.min(base, max), min);\r\n      head = base + size;\r\n\r\n      if (_stacked && !floating) {\r\n        // visual data coordinates after applying minBarLength\r\n        parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);\r\n      }\r\n    }\r\n\r\n    if (base === vScale.getPixelForValue(actualBase)) {\r\n      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;\r\n      base += halfGrid;\r\n      size -= halfGrid;\r\n    }\r\n\r\n    return {\r\n      size,\r\n      base,\r\n      head,\r\n      center: head + size / 2\r\n    };\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _calculateBarIndexPixels(index, ruler) {\r\n    const scale = ruler.scale;\r\n    const options = this.options;\r\n    const skipNull = options.skipNull;\r\n    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);\r\n    let center, size;\r\n    if (ruler.grouped) {\r\n      const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;\r\n      const range = options.barThickness === 'flex'\r\n        ? computeFlexCategoryTraits(index, ruler, options, stackCount)\r\n        : computeFitCategoryTraits(index, ruler, options, stackCount);\r\n\r\n      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);\r\n      center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\r\n      size = Math.min(maxBarThickness, range.chunk * range.ratio);\r\n    } else {\r\n      // For non-grouped bar charts, exact pixel values are used\r\n      center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);\r\n      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\r\n    }\r\n\r\n    return {\r\n      base: center - size / 2,\r\n      head: center + size / 2,\r\n      center,\r\n      size\r\n    };\r\n  }\r\n\r\n  draw() {\r\n    const meta = this._cachedMeta;\r\n    const vScale = meta.vScale;\r\n    const rects = meta.data;\r\n    const ilen = rects.length;\r\n    let i = 0;\r\n\r\n    for (; i < ilen; ++i) {\r\n      if (this.getParsed(i)[vScale.axis] !== null) {\r\n        rects[i].draw(this._ctx);\r\n      }\r\n    }\r\n  }\r\n\r\n}\r\n","import DatasetController from '../core/core.datasetController.js';\r\nimport {valueOrDefault} from '../helpers/helpers.core.js';\r\n\r\nexport default class BubbleController extends DatasetController {\r\n\r\n  static id = 'bubble';\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = {\r\n    datasetElementType: false,\r\n    dataElementType: 'point',\r\n\r\n    animations: {\r\n      numbers: {\r\n        type: 'number',\r\n        properties: ['x', 'y', 'borderWidth', 'radius']\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static overrides = {\r\n    scales: {\r\n      x: {\r\n        type: 'linear'\r\n      },\r\n      y: {\r\n        type: 'linear'\r\n      }\r\n    }\r\n  };\r\n\r\n  initialize() {\r\n    this.enableOptionSharing = true;\r\n    super.initialize();\r\n  }\r\n\r\n  /**\r\n\t * Parse array of primitive values\r\n\t * @protected\r\n\t */\r\n  parsePrimitiveData(meta, data, start, count) {\r\n    const parsed = super.parsePrimitiveData(meta, data, start, count);\r\n    for (let i = 0; i < parsed.length; i++) {\r\n      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;\r\n    }\r\n    return parsed;\r\n  }\r\n\r\n  /**\r\n\t * Parse array of arrays\r\n\t * @protected\r\n\t */\r\n  parseArrayData(meta, data, start, count) {\r\n    const parsed = super.parseArrayData(meta, data, start, count);\r\n    for (let i = 0; i < parsed.length; i++) {\r\n      const item = data[start + i];\r\n      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);\r\n    }\r\n    return parsed;\r\n  }\r\n\r\n  /**\r\n\t * Parse array of objects\r\n\t * @protected\r\n\t */\r\n  parseObjectData(meta, data, start, count) {\r\n    const parsed = super.parseObjectData(meta, data, start, count);\r\n    for (let i = 0; i < parsed.length; i++) {\r\n      const item = data[start + i];\r\n      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);\r\n    }\r\n    return parsed;\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  getMaxOverflow() {\r\n    const data = this._cachedMeta.data;\r\n\r\n    let max = 0;\r\n    for (let i = data.length - 1; i >= 0; --i) {\r\n      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\r\n    }\r\n    return max > 0 && max;\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  getLabelAndValue(index) {\r\n    const meta = this._cachedMeta;\r\n    const labels = this.chart.data.labels || [];\r\n    const {xScale, yScale} = meta;\r\n    const parsed = this.getParsed(index);\r\n    const x = xScale.getLabelForValue(parsed.x);\r\n    const y = yScale.getLabelForValue(parsed.y);\r\n    const r = parsed._custom;\r\n\r\n    return {\r\n      label: labels[index] || '',\r\n      value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'\r\n    };\r\n  }\r\n\r\n  update(mode) {\r\n    const points = this._cachedMeta.data;\r\n\r\n    // Update Points\r\n    this.updateElements(points, 0, points.length, mode);\r\n  }\r\n\r\n  updateElements(points, start, count, mode) {\r\n    const reset = mode === 'reset';\r\n    const {iScale, vScale} = this._cachedMeta;\r\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\r\n    const iAxis = iScale.axis;\r\n    const vAxis = vScale.axis;\r\n\r\n    for (let i = start; i < start + count; i++) {\r\n      const point = points[i];\r\n      const parsed = !reset && this.getParsed(i);\r\n      const properties = {};\r\n      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\r\n      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\r\n\r\n      properties.skip = isNaN(iPixel) || isNaN(vPixel);\r\n\r\n      if (includeOptions) {\r\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\r\n\r\n        if (reset) {\r\n          properties.options.radius = 0;\r\n        }\r\n      }\r\n\r\n      this.updateElement(point, i, properties, mode);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @param {number} index\r\n\t * @param {string} [mode]\r\n\t * @protected\r\n\t */\r\n  resolveDataElementOptions(index, mode) {\r\n    const parsed = this.getParsed(index);\r\n    let values = super.resolveDataElementOptions(index, mode);\r\n\r\n    // In case values were cached (and thus frozen), we need to clone the values\r\n    if (values.$shared) {\r\n      values = Object.assign({}, values, {$shared: false});\r\n    }\r\n\r\n    // Custom radius resolution\r\n    const radius = values.radius;\r\n    if (mode !== 'active') {\r\n      values.radius = 0;\r\n    }\r\n    values.radius += valueOrDefault(parsed && parsed._custom, radius);\r\n\r\n    return values;\r\n  }\r\n}\r\n","import DatasetController from '../core/core.datasetController.js';\r\nimport {isObject, resolveObjectKey, toPercentage, toDimension, valueOrDefault} from '../helpers/helpers.core.js';\r\nimport {formatNumber} from '../helpers/helpers.intl.js';\r\nimport {toRadians, PI, TAU, HALF_PI, _angleBetween} from '../helpers/helpers.math.js';\r\n\r\n/**\r\n * @typedef { import('../core/core.controller.js').default } Chart\r\n */\r\n\r\nfunction getRatioAndOffset(rotation, circumference, cutout) {\r\n  let ratioX = 1;\r\n  let ratioY = 1;\r\n  let offsetX = 0;\r\n  let offsetY = 0;\r\n  // If the chart's circumference isn't a full circle, calculate size as a ratio of the width/height of the arc\r\n  if (circumference < TAU) {\r\n    const startAngle = rotation;\r\n    const endAngle = startAngle + circumference;\r\n    const startX = Math.cos(startAngle);\r\n    const startY = Math.sin(startAngle);\r\n    const endX = Math.cos(endAngle);\r\n    const endY = Math.sin(endAngle);\r\n    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\r\n    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\r\n    const maxX = calcMax(0, startX, endX);\r\n    const maxY = calcMax(HALF_PI, startY, endY);\r\n    const minX = calcMin(PI, startX, endX);\r\n    const minY = calcMin(PI + HALF_PI, startY, endY);\r\n    ratioX = (maxX - minX) / 2;\r\n    ratioY = (maxY - minY) / 2;\r\n    offsetX = -(maxX + minX) / 2;\r\n    offsetY = -(maxY + minY) / 2;\r\n  }\r\n  return {ratioX, ratioY, offsetX, offsetY};\r\n}\r\n\r\nexport default class DoughnutController extends DatasetController {\r\n\r\n  static id = 'doughnut';\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = {\r\n    datasetElementType: false,\r\n    dataElementType: 'arc',\r\n    animation: {\r\n      // Boolean - Whether we animate the rotation of the Doughnut\r\n      animateRotate: true,\r\n      // Boolean - Whether we animate scaling the Doughnut from the centre\r\n      animateScale: false\r\n    },\r\n    animations: {\r\n      numbers: {\r\n        type: 'number',\r\n        properties: ['circumference', 'endAngle', 'innerRadius', 'outerRadius', 'startAngle', 'x', 'y', 'offset', 'borderWidth', 'spacing']\r\n      },\r\n    },\r\n    // The percentage of the chart that we cut out of the middle.\r\n    cutout: '50%',\r\n\r\n    // The rotation of the chart, where the first data arc begins.\r\n    rotation: 0,\r\n\r\n    // The total circumference of the chart.\r\n    circumference: 360,\r\n\r\n    // The outr radius of the chart\r\n    radius: '100%',\r\n\r\n    // Spacing between arcs\r\n    spacing: 0,\r\n\r\n    indexAxis: 'r',\r\n  };\r\n\r\n  static descriptors = {\r\n    _scriptable: (name) => name !== 'spacing',\r\n    _indexable: (name) => name !== 'spacing' && !name.startsWith('borderDash') && !name.startsWith('hoverBorderDash'),\r\n  };\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static overrides = {\r\n    aspectRatio: 1,\r\n\r\n    // Need to override these to give a nice default\r\n    plugins: {\r\n      legend: {\r\n        labels: {\r\n          generateLabels(chart) {\r\n            const data = chart.data;\r\n            if (data.labels.length && data.datasets.length) {\r\n              const {labels: {pointStyle, color}} = chart.legend.options;\r\n\r\n              return data.labels.map((label, i) => {\r\n                const meta = chart.getDatasetMeta(0);\r\n                const style = meta.controller.getStyle(i);\r\n\r\n                return {\r\n                  text: label,\r\n                  fillStyle: style.backgroundColor,\r\n                  strokeStyle: style.borderColor,\r\n                  fontColor: color,\r\n                  lineWidth: style.borderWidth,\r\n                  pointStyle: pointStyle,\r\n                  hidden: !chart.getDataVisibility(i),\r\n\r\n                  // Extra data used for toggling the correct item\r\n                  index: i\r\n                };\r\n              });\r\n            }\r\n            return [];\r\n          }\r\n        },\r\n\r\n        onClick(e, legendItem, legend) {\r\n          legend.chart.toggleDataVisibility(legendItem.index);\r\n          legend.chart.update();\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  constructor(chart, datasetIndex) {\r\n    super(chart, datasetIndex);\r\n\r\n    this.enableOptionSharing = true;\r\n    this.innerRadius = undefined;\r\n    this.outerRadius = undefined;\r\n    this.offsetX = undefined;\r\n    this.offsetY = undefined;\r\n  }\r\n\r\n  linkScales() {}\r\n\r\n  /**\r\n\t * Override data parsing, since we are not using scales\r\n\t */\r\n  parse(start, count) {\r\n    const data = this.getDataset().data;\r\n    const meta = this._cachedMeta;\r\n\r\n    if (this._parsing === false) {\r\n      meta._parsed = data;\r\n    } else {\r\n      let getter = (i) => +data[i];\r\n\r\n      if (isObject(data[start])) {\r\n        const {key = 'value'} = this._parsing;\r\n        getter = (i) => +resolveObjectKey(data[i], key);\r\n      }\r\n\r\n      let i, ilen;\r\n      for (i = start, ilen = start + count; i < ilen; ++i) {\r\n        meta._parsed[i] = getter(i);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _getRotation() {\r\n    return toRadians(this.options.rotation - 90);\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _getCircumference() {\r\n    return toRadians(this.options.circumference);\r\n  }\r\n\r\n  /**\r\n\t * Get the maximal rotation & circumference extents\r\n\t * across all visible datasets.\r\n\t */\r\n  _getRotationExtents() {\r\n    let min = TAU;\r\n    let max = -TAU;\r\n\r\n    for (let i = 0; i < this.chart.data.datasets.length; ++i) {\r\n      if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {\r\n        const controller = this.chart.getDatasetMeta(i).controller;\r\n        const rotation = controller._getRotation();\r\n        const circumference = controller._getCircumference();\r\n\r\n        min = Math.min(min, rotation);\r\n        max = Math.max(max, rotation + circumference);\r\n      }\r\n    }\r\n\r\n    return {\r\n      rotation: min,\r\n      circumference: max - min,\r\n    };\r\n  }\r\n\r\n  /**\r\n\t * @param {string} mode\r\n\t */\r\n  update(mode) {\r\n    const chart = this.chart;\r\n    const {chartArea} = chart;\r\n    const meta = this._cachedMeta;\r\n    const arcs = meta.data;\r\n    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;\r\n    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\r\n    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);\r\n    const chartWeight = this._getRingWeight(this.index);\r\n\r\n    // Compute the maximal rotation & circumference limits.\r\n    // If we only consider our dataset, this can cause problems when two datasets\r\n    // are both less than a circle with different rotations (starting angles)\r\n    const {circumference, rotation} = this._getRotationExtents();\r\n    const {ratioX, ratioY, offsetX, offsetY} = getRatioAndOffset(rotation, circumference, cutout);\r\n    const maxWidth = (chartArea.width - spacing) / ratioX;\r\n    const maxHeight = (chartArea.height - spacing) / ratioY;\r\n    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\r\n    const outerRadius = toDimension(this.options.radius, maxRadius);\r\n    const innerRadius = Math.max(outerRadius * cutout, 0);\r\n    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();\r\n    this.offsetX = offsetX * outerRadius;\r\n    this.offsetY = offsetY * outerRadius;\r\n\r\n    meta.total = this.calculateTotal();\r\n\r\n    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);\r\n    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);\r\n\r\n    this.updateElements(arcs, 0, arcs.length, mode);\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _circumference(i, reset) {\r\n    const opts = this.options;\r\n    const meta = this._cachedMeta;\r\n    const circumference = this._getCircumference();\r\n    if ((reset && opts.animation.animateRotate) || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\r\n      return 0;\r\n    }\r\n    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);\r\n  }\r\n\r\n  updateElements(arcs, start, count, mode) {\r\n    const reset = mode === 'reset';\r\n    const chart = this.chart;\r\n    const chartArea = chart.chartArea;\r\n    const opts = chart.options;\r\n    const animationOpts = opts.animation;\r\n    const centerX = (chartArea.left + chartArea.right) / 2;\r\n    const centerY = (chartArea.top + chartArea.bottom) / 2;\r\n    const animateScale = reset && animationOpts.animateScale;\r\n    const innerRadius = animateScale ? 0 : this.innerRadius;\r\n    const outerRadius = animateScale ? 0 : this.outerRadius;\r\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\r\n    let startAngle = this._getRotation();\r\n    let i;\r\n\r\n    for (i = 0; i < start; ++i) {\r\n      startAngle += this._circumference(i, reset);\r\n    }\r\n\r\n    for (i = start; i < start + count; ++i) {\r\n      const circumference = this._circumference(i, reset);\r\n      const arc = arcs[i];\r\n      const properties = {\r\n        x: centerX + this.offsetX,\r\n        y: centerY + this.offsetY,\r\n        startAngle,\r\n        endAngle: startAngle + circumference,\r\n        circumference,\r\n        outerRadius,\r\n        innerRadius\r\n      };\r\n      if (includeOptions) {\r\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);\r\n      }\r\n      startAngle += circumference;\r\n\r\n      this.updateElement(arc, i, properties, mode);\r\n    }\r\n  }\r\n\r\n  calculateTotal() {\r\n    const meta = this._cachedMeta;\r\n    const metaData = meta.data;\r\n    let total = 0;\r\n    let i;\r\n\r\n    for (i = 0; i < metaData.length; i++) {\r\n      const value = meta._parsed[i];\r\n      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\r\n        total += Math.abs(value);\r\n      }\r\n    }\r\n\r\n    return total;\r\n  }\r\n\r\n  calculateCircumference(value) {\r\n    const total = this._cachedMeta.total;\r\n    if (total > 0 && !isNaN(value)) {\r\n      return TAU * (Math.abs(value) / total);\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  getLabelAndValue(index) {\r\n    const meta = this._cachedMeta;\r\n    const chart = this.chart;\r\n    const labels = chart.data.labels || [];\r\n    const value = formatNumber(meta._parsed[index], chart.options.locale);\r\n\r\n    return {\r\n      label: labels[index] || '',\r\n      value,\r\n    };\r\n  }\r\n\r\n  getMaxBorderWidth(arcs) {\r\n    let max = 0;\r\n    const chart = this.chart;\r\n    let i, ilen, meta, controller, options;\r\n\r\n    if (!arcs) {\r\n      // Find the outmost visible dataset\r\n      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\r\n        if (chart.isDatasetVisible(i)) {\r\n          meta = chart.getDatasetMeta(i);\r\n          arcs = meta.data;\r\n          controller = meta.controller;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!arcs) {\r\n      return 0;\r\n    }\r\n\r\n    for (i = 0, ilen = arcs.length; i < ilen; ++i) {\r\n      options = controller.resolveDataElementOptions(i);\r\n      if (options.borderAlign !== 'inner') {\r\n        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\r\n      }\r\n    }\r\n    return max;\r\n  }\r\n\r\n  getMaxOffset(arcs) {\r\n    let max = 0;\r\n\r\n    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {\r\n      const options = this.resolveDataElementOptions(i);\r\n      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\r\n    }\r\n    return max;\r\n  }\r\n\r\n  /**\r\n\t * Get radius length offset of the dataset in relation to the visible datasets weights. This allows determining the inner and outer radius correctly\r\n\t * @private\r\n\t */\r\n  _getRingWeightOffset(datasetIndex) {\r\n    let ringWeightOffset = 0;\r\n\r\n    for (let i = 0; i < datasetIndex; ++i) {\r\n      if (this.chart.isDatasetVisible(i)) {\r\n        ringWeightOffset += this._getRingWeight(i);\r\n      }\r\n    }\r\n\r\n    return ringWeightOffset;\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _getRingWeight(datasetIndex) {\r\n    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);\r\n  }\r\n\r\n  /**\r\n\t * Returns the sum of all visible data set weights.\r\n\t * @private\r\n\t */\r\n  _getVisibleDatasetWeightTotal() {\r\n    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\r\n  }\r\n}\r\n","import DatasetController from '../core/core.datasetController.js';\r\nimport {isNullOrUndef} from '../helpers/index.js';\r\nimport {isNumber} from '../helpers/helpers.math.js';\r\nimport {_getStartAndCountOfVisiblePoints, _scaleRangesChanged} from '../helpers/helpers.extras.js';\r\n\r\nexport default class LineController extends DatasetController {\r\n\r\n  static id = 'line';\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = {\r\n    datasetElementType: 'line',\r\n    dataElementType: 'point',\r\n\r\n    showLine: true,\r\n    spanGaps: false,\r\n  };\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static overrides = {\r\n    scales: {\r\n      _index_: {\r\n        type: 'category',\r\n      },\r\n      _value_: {\r\n        type: 'linear',\r\n      },\r\n    }\r\n  };\r\n\r\n  initialize() {\r\n    this.enableOptionSharing = true;\r\n    this.supportsDecimation = true;\r\n    super.initialize();\r\n  }\r\n\r\n  update(mode) {\r\n    const meta = this._cachedMeta;\r\n    const {dataset: line, data: points = [], _dataset} = meta;\r\n    // @ts-ignore\r\n    const animationsDisabled = this.chart._animationsDisabled;\r\n    let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\r\n\r\n    this._drawStart = start;\r\n    this._drawCount = count;\r\n\r\n    if (_scaleRangesChanged(meta)) {\r\n      start = 0;\r\n      count = points.length;\r\n    }\r\n\r\n    // Update Line\r\n    line._chart = this.chart;\r\n    line._datasetIndex = this.index;\r\n    line._decimated = !!_dataset._decimated;\r\n    line.points = points;\r\n\r\n    const options = this.resolveDatasetElementOptions(mode);\r\n    if (!this.options.showLine) {\r\n      options.borderWidth = 0;\r\n    }\r\n    options.segment = this.options.segment;\r\n    this.updateElement(line, undefined, {\r\n      animated: !animationsDisabled,\r\n      options\r\n    }, mode);\r\n\r\n    // Update Points\r\n    this.updateElements(points, start, count, mode);\r\n  }\r\n\r\n  updateElements(points, start, count, mode) {\r\n    const reset = mode === 'reset';\r\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\r\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\r\n    const iAxis = iScale.axis;\r\n    const vAxis = vScale.axis;\r\n    const {spanGaps, segment} = this.options;\r\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\r\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\r\n    const end = start + count;\r\n    const pointsCount = points.length;\r\n    let prevParsed = start > 0 && this.getParsed(start - 1);\r\n\r\n    for (let i = 0; i < pointsCount; ++i) {\r\n      const point = points[i];\r\n      const properties = directUpdate ? point : {};\r\n\r\n      if (i < start || i >= end) {\r\n        properties.skip = true;\r\n        continue;\r\n      }\r\n\r\n      const parsed = this.getParsed(i);\r\n      const nullData = isNullOrUndef(parsed[vAxis]);\r\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\r\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\r\n\r\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\r\n      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;\r\n      if (segment) {\r\n        properties.parsed = parsed;\r\n        properties.raw = _dataset.data[i];\r\n      }\r\n\r\n      if (includeOptions) {\r\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\r\n      }\r\n\r\n      if (!directUpdate) {\r\n        this.updateElement(point, i, properties, mode);\r\n      }\r\n\r\n      prevParsed = parsed;\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  getMaxOverflow() {\r\n    const meta = this._cachedMeta;\r\n    const dataset = meta.dataset;\r\n    const border = dataset.options && dataset.options.borderWidth || 0;\r\n    const data = meta.data || [];\r\n    if (!data.length) {\r\n      return border;\r\n    }\r\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\r\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\r\n    return Math.max(border, firstPoint, lastPoint) / 2;\r\n  }\r\n\r\n  draw() {\r\n    const meta = this._cachedMeta;\r\n    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\r\n    super.draw();\r\n  }\r\n}\r\n","import DatasetController from '../core/core.datasetController.js';\r\nimport {toRadians, PI, formatNumber, _parseObjectDataRadialScale} from '../helpers/index.js';\r\n\r\nexport default class PolarAreaController extends DatasetController {\r\n\r\n  static id = 'polarArea';\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = {\r\n    dataElementType: 'arc',\r\n    animation: {\r\n      animateRotate: true,\r\n      animateScale: true\r\n    },\r\n    animations: {\r\n      numbers: {\r\n        type: 'number',\r\n        properties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius']\r\n      },\r\n    },\r\n    indexAxis: 'r',\r\n    startAngle: 0,\r\n  };\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static overrides = {\r\n    aspectRatio: 1,\r\n\r\n    plugins: {\r\n      legend: {\r\n        labels: {\r\n          generateLabels(chart) {\r\n            const data = chart.data;\r\n            if (data.labels.length && data.datasets.length) {\r\n              const {labels: {pointStyle, color}} = chart.legend.options;\r\n\r\n              return data.labels.map((label, i) => {\r\n                const meta = chart.getDatasetMeta(0);\r\n                const style = meta.controller.getStyle(i);\r\n\r\n                return {\r\n                  text: label,\r\n                  fillStyle: style.backgroundColor,\r\n                  strokeStyle: style.borderColor,\r\n                  fontColor: color,\r\n                  lineWidth: style.borderWidth,\r\n                  pointStyle: pointStyle,\r\n                  hidden: !chart.getDataVisibility(i),\r\n\r\n                  // Extra data used for toggling the correct item\r\n                  index: i\r\n                };\r\n              });\r\n            }\r\n            return [];\r\n          }\r\n        },\r\n\r\n        onClick(e, legendItem, legend) {\r\n          legend.chart.toggleDataVisibility(legendItem.index);\r\n          legend.chart.update();\r\n        }\r\n      }\r\n    },\r\n\r\n    scales: {\r\n      r: {\r\n        type: 'radialLinear',\r\n        angleLines: {\r\n          display: false\r\n        },\r\n        beginAtZero: true,\r\n        grid: {\r\n          circular: true\r\n        },\r\n        pointLabels: {\r\n          display: false\r\n        },\r\n        startAngle: 0\r\n      }\r\n    }\r\n  };\r\n\r\n  constructor(chart, datasetIndex) {\r\n    super(chart, datasetIndex);\r\n\r\n    this.innerRadius = undefined;\r\n    this.outerRadius = undefined;\r\n  }\r\n\r\n  getLabelAndValue(index) {\r\n    const meta = this._cachedMeta;\r\n    const chart = this.chart;\r\n    const labels = chart.data.labels || [];\r\n    const value = formatNumber(meta._parsed[index].r, chart.options.locale);\r\n\r\n    return {\r\n      label: labels[index] || '',\r\n      value,\r\n    };\r\n  }\r\n\r\n  parseObjectData(meta, data, start, count) {\r\n    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\r\n  }\r\n\r\n  update(mode) {\r\n    const arcs = this._cachedMeta.data;\r\n\r\n    this._updateRadius();\r\n    this.updateElements(arcs, 0, arcs.length, mode);\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   */\r\n  getMinMax() {\r\n    const meta = this._cachedMeta;\r\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\r\n\r\n    meta.data.forEach((element, index) => {\r\n      const parsed = this.getParsed(index).r;\r\n\r\n      if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {\r\n        if (parsed < range.min) {\r\n          range.min = parsed;\r\n        }\r\n\r\n        if (parsed > range.max) {\r\n          range.max = parsed;\r\n        }\r\n      }\r\n    });\r\n\r\n    return range;\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _updateRadius() {\r\n    const chart = this.chart;\r\n    const chartArea = chart.chartArea;\r\n    const opts = chart.options;\r\n    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\r\n\r\n    const outerRadius = Math.max(minSize / 2, 0);\r\n    const innerRadius = Math.max(opts.cutoutPercentage ? (outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\r\n    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\r\n\r\n    this.outerRadius = outerRadius - (radiusLength * this.index);\r\n    this.innerRadius = this.outerRadius - radiusLength;\r\n  }\r\n\r\n  updateElements(arcs, start, count, mode) {\r\n    const reset = mode === 'reset';\r\n    const chart = this.chart;\r\n    const opts = chart.options;\r\n    const animationOpts = opts.animation;\r\n    const scale = this._cachedMeta.rScale;\r\n    const centerX = scale.xCenter;\r\n    const centerY = scale.yCenter;\r\n    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;\r\n    let angle = datasetStartAngle;\r\n    let i;\r\n\r\n    const defaultAngle = 360 / this.countVisibleElements();\r\n\r\n    for (i = 0; i < start; ++i) {\r\n      angle += this._computeAngle(i, mode, defaultAngle);\r\n    }\r\n    for (i = start; i < start + count; i++) {\r\n      const arc = arcs[i];\r\n      let startAngle = angle;\r\n      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);\r\n      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;\r\n      angle = endAngle;\r\n\r\n      if (reset) {\r\n        if (animationOpts.animateScale) {\r\n          outerRadius = 0;\r\n        }\r\n        if (animationOpts.animateRotate) {\r\n          startAngle = endAngle = datasetStartAngle;\r\n        }\r\n      }\r\n\r\n      const properties = {\r\n        x: centerX,\r\n        y: centerY,\r\n        innerRadius: 0,\r\n        outerRadius,\r\n        startAngle,\r\n        endAngle,\r\n        options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)\r\n      };\r\n\r\n      this.updateElement(arc, i, properties, mode);\r\n    }\r\n  }\r\n\r\n  countVisibleElements() {\r\n    const meta = this._cachedMeta;\r\n    let count = 0;\r\n\r\n    meta.data.forEach((element, index) => {\r\n      if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {\r\n        count++;\r\n      }\r\n    });\r\n\r\n    return count;\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _computeAngle(index, mode, defaultAngle) {\r\n    return this.chart.getDataVisibility(index)\r\n      ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle)\r\n      : 0;\r\n  }\r\n}\r\n","import DoughnutController from './controller.doughnut.js';\r\n\r\n// Pie charts are Doughnut chart with different defaults\r\nexport default class PieController extends DoughnutController {\r\n\r\n  static id = 'pie';\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = {\r\n    // The percentage of the chart that we cut out of the middle.\r\n    cutout: 0,\r\n\r\n    // The rotation of the chart, where the first data arc begins.\r\n    rotation: 0,\r\n\r\n    // The total circumference of the chart.\r\n    circumference: 360,\r\n\r\n    // The outr radius of the chart\r\n    radius: '100%'\r\n  };\r\n}\r\n","import DatasetController from '../core/core.datasetController.js';\r\nimport {_parseObjectDataRadialScale} from '../helpers/index.js';\r\n\r\nexport default class RadarController extends DatasetController {\r\n\r\n  static id = 'radar';\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = {\r\n    datasetElementType: 'line',\r\n    dataElementType: 'point',\r\n    indexAxis: 'r',\r\n    showLine: true,\r\n    elements: {\r\n      line: {\r\n        fill: 'start'\r\n      }\r\n    },\r\n  };\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static overrides = {\r\n    aspectRatio: 1,\r\n\r\n    scales: {\r\n      r: {\r\n        type: 'radialLinear',\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  getLabelAndValue(index) {\r\n    const vScale = this._cachedMeta.vScale;\r\n    const parsed = this.getParsed(index);\r\n\r\n    return {\r\n      label: vScale.getLabels()[index],\r\n      value: '' + vScale.getLabelForValue(parsed[vScale.axis])\r\n    };\r\n  }\r\n\r\n  parseObjectData(meta, data, start, count) {\r\n    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\r\n  }\r\n\r\n  update(mode) {\r\n    const meta = this._cachedMeta;\r\n    const line = meta.dataset;\r\n    const points = meta.data || [];\r\n    const labels = meta.iScale.getLabels();\r\n\r\n    // Update Line\r\n    line.points = points;\r\n    // In resize mode only point locations change, so no need to set the points or options.\r\n    if (mode !== 'resize') {\r\n      const options = this.resolveDatasetElementOptions(mode);\r\n      if (!this.options.showLine) {\r\n        options.borderWidth = 0;\r\n      }\r\n\r\n      const properties = {\r\n        _loop: true,\r\n        _fullLoop: labels.length === points.length,\r\n        options\r\n      };\r\n\r\n      this.updateElement(line, undefined, properties, mode);\r\n    }\r\n\r\n    // Update Points\r\n    this.updateElements(points, 0, points.length, mode);\r\n  }\r\n\r\n  updateElements(points, start, count, mode) {\r\n    const scale = this._cachedMeta.rScale;\r\n    const reset = mode === 'reset';\r\n\r\n    for (let i = start; i < start + count; i++) {\r\n      const point = points[i];\r\n      const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);\r\n      const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);\r\n\r\n      const x = reset ? scale.xCenter : pointPosition.x;\r\n      const y = reset ? scale.yCenter : pointPosition.y;\r\n\r\n      const properties = {\r\n        x,\r\n        y,\r\n        angle: pointPosition.angle,\r\n        skip: isNaN(x) || isNaN(y),\r\n        options\r\n      };\r\n\r\n      this.updateElement(point, i, properties, mode);\r\n    }\r\n  }\r\n}\r\n","import DatasetController from '../core/core.datasetController.js';\r\nimport {isNullOrUndef} from '../helpers/index.js';\r\nimport {isNumber} from '../helpers/helpers.math.js';\r\nimport {_getStartAndCountOfVisiblePoints, _scaleRangesChanged} from '../helpers/helpers.extras.js';\r\n\r\nexport default class ScatterController extends DatasetController {\r\n\r\n  static id = 'scatter';\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = {\r\n    datasetElementType: false,\r\n    dataElementType: 'point',\r\n    showLine: false,\r\n    fill: false\r\n  };\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static overrides = {\r\n\r\n    interaction: {\r\n      mode: 'point'\r\n    },\r\n\r\n    scales: {\r\n      x: {\r\n        type: 'linear'\r\n      },\r\n      y: {\r\n        type: 'linear'\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  getLabelAndValue(index) {\r\n    const meta = this._cachedMeta;\r\n    const labels = this.chart.data.labels || [];\r\n    const {xScale, yScale} = meta;\r\n    const parsed = this.getParsed(index);\r\n    const x = xScale.getLabelForValue(parsed.x);\r\n    const y = yScale.getLabelForValue(parsed.y);\r\n\r\n    return {\r\n      label: labels[index] || '',\r\n      value: '(' + x + ', ' + y + ')'\r\n    };\r\n  }\r\n\r\n  update(mode) {\r\n    const meta = this._cachedMeta;\r\n    const {data: points = []} = meta;\r\n    // @ts-ignore\r\n    const animationsDisabled = this.chart._animationsDisabled;\r\n    let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\r\n\r\n    this._drawStart = start;\r\n    this._drawCount = count;\r\n\r\n    if (_scaleRangesChanged(meta)) {\r\n      start = 0;\r\n      count = points.length;\r\n    }\r\n\r\n    if (this.options.showLine) {\r\n\r\n      const {dataset: line, _dataset} = meta;\r\n\r\n      // Update Line\r\n      line._chart = this.chart;\r\n      line._datasetIndex = this.index;\r\n      line._decimated = !!_dataset._decimated;\r\n      line.points = points;\r\n\r\n      const options = this.resolveDatasetElementOptions(mode);\r\n      options.segment = this.options.segment;\r\n      this.updateElement(line, undefined, {\r\n        animated: !animationsDisabled,\r\n        options\r\n      }, mode);\r\n    }\r\n\r\n    // Update Points\r\n    this.updateElements(points, start, count, mode);\r\n  }\r\n\r\n  addElements() {\r\n    const {showLine} = this.options;\r\n\r\n    if (!this.datasetElementType && showLine) {\r\n      this.datasetElementType = this.chart.registry.getElement('line');\r\n    }\r\n\r\n    super.addElements();\r\n  }\r\n\r\n  updateElements(points, start, count, mode) {\r\n    const reset = mode === 'reset';\r\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\r\n    const firstOpts = this.resolveDataElementOptions(start, mode);\r\n    const sharedOptions = this.getSharedOptions(firstOpts);\r\n    const includeOptions = this.includeOptions(mode, sharedOptions);\r\n    const iAxis = iScale.axis;\r\n    const vAxis = vScale.axis;\r\n    const {spanGaps, segment} = this.options;\r\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\r\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\r\n    let prevParsed = start > 0 && this.getParsed(start - 1);\r\n\r\n    for (let i = start; i < start + count; ++i) {\r\n      const point = points[i];\r\n      const parsed = this.getParsed(i);\r\n      const properties = directUpdate ? point : {};\r\n      const nullData = isNullOrUndef(parsed[vAxis]);\r\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\r\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\r\n\r\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\r\n      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;\r\n      if (segment) {\r\n        properties.parsed = parsed;\r\n        properties.raw = _dataset.data[i];\r\n      }\r\n\r\n      if (includeOptions) {\r\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\r\n      }\r\n\r\n      if (!directUpdate) {\r\n        this.updateElement(point, i, properties, mode);\r\n      }\r\n\r\n      prevParsed = parsed;\r\n    }\r\n\r\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  getMaxOverflow() {\r\n    const meta = this._cachedMeta;\r\n    const data = meta.data || [];\r\n\r\n    if (!this.options.showLine) {\r\n      let max = 0;\r\n      for (let i = data.length - 1; i >= 0; --i) {\r\n        max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\r\n      }\r\n      return max > 0 && max;\r\n    }\r\n\r\n    const dataset = meta.dataset;\r\n    const border = dataset.options && dataset.options.borderWidth || 0;\r\n\r\n    if (!data.length) {\r\n      return border;\r\n    }\r\n\r\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\r\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\r\n    return Math.max(border, firstPoint, lastPoint) / 2;\r\n  }\r\n}\r\n","/**\r\n * @namespace Chart._adapters\r\n * @since 2.8.0\r\n * @private\r\n */\r\n\r\nimport type {AnyObject} from '../types/basic.js';\r\nimport type {ChartOptions} from '../types/index.js';\r\n\r\nexport type TimeUnit = 'millisecond' | 'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year';\r\n\r\nexport interface DateAdapter<T extends AnyObject = AnyObject> {\r\n  readonly options: T;\r\n  /**\r\n   * Will called with chart options after adapter creation.\r\n   */\r\n  init(this: DateAdapter<T>, chartOptions: ChartOptions): void;\r\n  /**\r\n   * Returns a map of time formats for the supported formatting units defined\r\n   * in Unit as well as 'datetime' representing a detailed date/time string.\r\n   */\r\n  formats(this: DateAdapter<T>): Record<string, string>;\r\n  /**\r\n   * Parses the given `value` and return the associated timestamp.\r\n   * @param value - the value to parse (usually comes from the data)\r\n   * @param [format] - the expected data format\r\n   */\r\n  parse(this: DateAdapter<T>, value: unknown, format?: TimeUnit): number | null;\r\n  /**\r\n   * Returns the formatted date in the specified `format` for a given `timestamp`.\r\n   * @param timestamp - the timestamp to format\r\n   * @param format - the date/time token\r\n   */\r\n  format(this: DateAdapter<T>, timestamp: number, format: TimeUnit): string;\r\n  /**\r\n   * Adds the specified `amount` of `unit` to the given `timestamp`.\r\n   * @param timestamp - the input timestamp\r\n   * @param amount - the amount to add\r\n   * @param unit - the unit as string\r\n   */\r\n  add(this: DateAdapter<T>, timestamp: number, amount: number, unit: TimeUnit): number;\r\n  /**\r\n   * Returns the number of `unit` between the given timestamps.\r\n   * @param a - the input timestamp (reference)\r\n   * @param b - the timestamp to subtract\r\n   * @param unit - the unit as string\r\n   */\r\n  diff(this: DateAdapter<T>, a: number, b: number, unit: TimeUnit): number;\r\n  /**\r\n   * Returns start of `unit` for the given `timestamp`.\r\n   * @param timestamp - the input timestamp\r\n   * @param unit - the unit as string\r\n   * @param [weekday] - the ISO day of the week with 1 being Monday\r\n   * and 7 being Sunday (only needed if param *unit* is `isoWeek`).\r\n   */\r\n  startOf(this: DateAdapter<T>, timestamp: number, unit: TimeUnit | 'isoWeek', weekday?: number): number;\r\n  /**\r\n   * Returns end of `unit` for the given `timestamp`.\r\n   * @param timestamp - the input timestamp\r\n   * @param unit - the unit as string\r\n   */\r\n  endOf(this: DateAdapter<T>, timestamp: number, unit: TimeUnit | 'isoWeek'): number;\r\n}\r\n\r\nfunction abstract<T = void>(): T {\r\n  throw new Error('This method is not implemented: Check that a complete date adapter is provided.');\r\n}\r\n\r\n/**\r\n * Date adapter (current used by the time scale)\r\n * @namespace Chart._adapters._date\r\n * @memberof Chart._adapters\r\n * @private\r\n */\r\nclass DateAdapterBase implements DateAdapter {\r\n\r\n  /**\r\n   * Override default date adapter methods.\r\n   * Accepts type parameter to define options type.\r\n   * @example\r\n   * Chart._adapters._date.override<{myAdapterOption: string}>({\r\n   *   init() {\r\n   *     console.log(this.options.myAdapterOption);\r\n   *   }\r\n   * })\r\n   */\r\n  static override<T extends AnyObject = AnyObject>(\r\n    members: Partial<Omit<DateAdapter<T>, 'options'>>\r\n  ) {\r\n    Object.assign(DateAdapterBase.prototype, members);\r\n  }\r\n\r\n  readonly options: AnyObject;\r\n\r\n  constructor(options: AnyObject) {\r\n    this.options = options || {};\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n  init() {}\r\n\r\n  formats(): Record<string, string> {\r\n    return abstract();\r\n  }\r\n\r\n  parse(): number | null {\r\n    return abstract();\r\n  }\r\n\r\n  format(): string {\r\n    return abstract();\r\n  }\r\n\r\n  add(): number {\r\n    return abstract();\r\n  }\r\n\r\n  diff(): number {\r\n    return abstract();\r\n  }\r\n\r\n  startOf(): number {\r\n    return abstract();\r\n  }\r\n\r\n  endOf(): number {\r\n    return abstract();\r\n  }\r\n}\r\n\r\nexport default {\r\n  _date: DateAdapterBase\r\n};\r\n","import {_lookupByKey, _rlookupByKey} from '../helpers/helpers.collection.js';\r\nimport {getRelativePosition} from '../helpers/helpers.dom.js';\r\nimport {_angleBetween, getAngleFromPoint} from '../helpers/helpers.math.js';\r\nimport {_isPointInArea} from '../helpers/index.js';\r\n\r\n/**\r\n * @typedef { import('./core.controller.js').default } Chart\r\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\r\n * @typedef {{axis?: string, intersect?: boolean, includeInvisible?: boolean}} InteractionOptions\r\n * @typedef {{datasetIndex: number, index: number, element: import('./core.element.js').default}} InteractionItem\r\n * @typedef { import('../types/index.js').Point } Point\r\n */\r\n\r\n/**\r\n * Helper function to do binary search when possible\r\n * @param {object} metaset - the dataset meta\r\n * @param {string} axis - the axis mode. x|y|xy|r\r\n * @param {number} value - the value to find\r\n * @param {boolean} [intersect] - should the element intersect\r\n * @returns {{lo:number, hi:number}} indices to search data array between\r\n */\r\nfunction binarySearch(metaset, axis, value, intersect) {\r\n  const {controller, data, _sorted} = metaset;\r\n  const iScale = controller._cachedMeta.iScale;\r\n  if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {\r\n    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;\r\n    if (!intersect) {\r\n      return lookupMethod(data, axis, value);\r\n    } else if (controller._sharedOptions) {\r\n      // _sharedOptions indicates that each element has equal options -> equal proportions\r\n      // So we can do a ranged binary search based on the range of first element and\r\n      // be confident to get the full range of indices that can intersect with the value.\r\n      const el = data[0];\r\n      const range = typeof el.getRange === 'function' && el.getRange(axis);\r\n      if (range) {\r\n        const start = lookupMethod(data, axis, value - range);\r\n        const end = lookupMethod(data, axis, value + range);\r\n        return {lo: start.lo, hi: end.hi};\r\n      }\r\n    }\r\n  }\r\n  // Default to all elements, when binary search can not be used.\r\n  return {lo: 0, hi: data.length - 1};\r\n}\r\n\r\n/**\r\n * Helper function to select candidate elements for interaction\r\n * @param {Chart} chart - the chart\r\n * @param {string} axis - the axis mode. x|y|xy|r\r\n * @param {Point} position - the point to be nearest to, in relative coordinates\r\n * @param {function} handler - the callback to execute for each visible item\r\n * @param {boolean} [intersect] - consider intersecting items\r\n */\r\nfunction evaluateInteractionItems(chart, axis, position, handler, intersect) {\r\n  const metasets = chart.getSortedVisibleDatasetMetas();\r\n  const value = position[axis];\r\n  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {\r\n    const {index, data} = metasets[i];\r\n    const {lo, hi} = binarySearch(metasets[i], axis, value, intersect);\r\n    for (let j = lo; j <= hi; ++j) {\r\n      const element = data[j];\r\n      if (!element.skip) {\r\n        handler(element, index, j);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Get a distance metric function for two points based on the\r\n * axis mode setting\r\n * @param {string} axis - the axis mode. x|y|xy|r\r\n */\r\nfunction getDistanceMetricForAxis(axis) {\r\n  const useX = axis.indexOf('x') !== -1;\r\n  const useY = axis.indexOf('y') !== -1;\r\n\r\n  return function(pt1, pt2) {\r\n    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\r\n    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\r\n    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\r\n  };\r\n}\r\n\r\n/**\r\n * Helper function to get the items that intersect the event position\r\n * @param {Chart} chart - the chart\r\n * @param {Point} position - the point to be nearest to, in relative coordinates\r\n * @param {string} axis - the axis mode. x|y|xy|r\r\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\r\n * @param {boolean} [includeInvisible] - include invisible points that are outside of the chart area\r\n * @return {InteractionItem[]} the nearest items\r\n */\r\nfunction getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {\r\n  const items = [];\r\n\r\n  if (!includeInvisible && !chart.isPointInArea(position)) {\r\n    return items;\r\n  }\r\n\r\n  const evaluationFunc = function(element, datasetIndex, index) {\r\n    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {\r\n      return;\r\n    }\r\n    if (element.inRange(position.x, position.y, useFinalPosition)) {\r\n      items.push({element, datasetIndex, index});\r\n    }\r\n  };\r\n\r\n  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);\r\n  return items;\r\n}\r\n\r\n/**\r\n * Helper function to get the items nearest to the event position for a radial chart\r\n * @param {Chart} chart - the chart to look at elements from\r\n * @param {Point} position - the point to be nearest to, in relative coordinates\r\n * @param {string} axis - the axes along which to measure distance\r\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\r\n * @return {InteractionItem[]} the nearest items\r\n */\r\nfunction getNearestRadialItems(chart, position, axis, useFinalPosition) {\r\n  let items = [];\r\n\r\n  function evaluationFunc(element, datasetIndex, index) {\r\n    const {startAngle, endAngle} = element.getProps(['startAngle', 'endAngle'], useFinalPosition);\r\n    const {angle} = getAngleFromPoint(element, {x: position.x, y: position.y});\r\n\r\n    if (_angleBetween(angle, startAngle, endAngle)) {\r\n      items.push({element, datasetIndex, index});\r\n    }\r\n  }\r\n\r\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\r\n  return items;\r\n}\r\n\r\n/**\r\n * Helper function to get the items nearest to the event position for a cartesian chart\r\n * @param {Chart} chart - the chart to look at elements from\r\n * @param {Point} position - the point to be nearest to, in relative coordinates\r\n * @param {string} axis - the axes along which to measure distance\r\n * @param {boolean} [intersect] - if true, only consider items that intersect the position\r\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\r\n * @param {boolean} [includeInvisible] - include invisible points that are outside of the chart area\r\n * @return {InteractionItem[]} the nearest items\r\n */\r\nfunction getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\r\n  let items = [];\r\n  const distanceMetric = getDistanceMetricForAxis(axis);\r\n  let minDistance = Number.POSITIVE_INFINITY;\r\n\r\n  function evaluationFunc(element, datasetIndex, index) {\r\n    const inRange = element.inRange(position.x, position.y, useFinalPosition);\r\n    if (intersect && !inRange) {\r\n      return;\r\n    }\r\n\r\n    const center = element.getCenterPoint(useFinalPosition);\r\n    const pointInArea = !!includeInvisible || chart.isPointInArea(center);\r\n    if (!pointInArea && !inRange) {\r\n      return;\r\n    }\r\n\r\n    const distance = distanceMetric(position, center);\r\n    if (distance < minDistance) {\r\n      items = [{element, datasetIndex, index}];\r\n      minDistance = distance;\r\n    } else if (distance === minDistance) {\r\n      // Can have multiple items at the same distance in which case we sort by size\r\n      items.push({element, datasetIndex, index});\r\n    }\r\n  }\r\n\r\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\r\n  return items;\r\n}\r\n\r\n/**\r\n * Helper function to get the items nearest to the event position considering all visible items in the chart\r\n * @param {Chart} chart - the chart to look at elements from\r\n * @param {Point} position - the point to be nearest to, in relative coordinates\r\n * @param {string} axis - the axes along which to measure distance\r\n * @param {boolean} [intersect] - if true, only consider items that intersect the position\r\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\r\n * @param {boolean} [includeInvisible] - include invisible points that are outside of the chart area\r\n * @return {InteractionItem[]} the nearest items\r\n */\r\nfunction getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\r\n  if (!includeInvisible && !chart.isPointInArea(position)) {\r\n    return [];\r\n  }\r\n\r\n  return axis === 'r' && !intersect\r\n    ? getNearestRadialItems(chart, position, axis, useFinalPosition)\r\n    : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);\r\n}\r\n\r\n/**\r\n * Helper function to get the items matching along the given X or Y axis\r\n * @param {Chart} chart - the chart to look at elements from\r\n * @param {Point} position - the point to be nearest to, in relative coordinates\r\n * @param {string} axis - the axis to match\r\n * @param {boolean} [intersect] - if true, only consider items that intersect the position\r\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\r\n * @return {InteractionItem[]} the nearest items\r\n */\r\nfunction getAxisItems(chart, position, axis, intersect, useFinalPosition) {\r\n  const items = [];\r\n  const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';\r\n  let intersectsItem = false;\r\n\r\n  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index) => {\r\n    if (element[rangeMethod](position[axis], useFinalPosition)) {\r\n      items.push({element, datasetIndex, index});\r\n      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);\r\n    }\r\n  });\r\n\r\n  // If we want to trigger on an intersect and we don't have any items\r\n  // that intersect the position, return nothing\r\n  if (intersect && !intersectsItem) {\r\n    return [];\r\n  }\r\n  return items;\r\n}\r\n\r\n/**\r\n * Contains interaction related functions\r\n * @namespace Chart.Interaction\r\n */\r\nexport default {\r\n  // Part of the public API to facilitate developers creating their own modes\r\n  evaluateInteractionItems,\r\n\r\n  // Helper function for different modes\r\n  modes: {\r\n    /**\r\n\t\t * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something\r\n\t\t * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item\r\n\t\t * @function Chart.Interaction.modes.index\r\n\t\t * @since v2.4.0\r\n\t\t * @param {Chart} chart - the chart we are returning items from\r\n\t\t * @param {Event} e - the event we are find things at\r\n\t\t * @param {InteractionOptions} options - options to use\r\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\r\n\t\t * @return {InteractionItem[]} - items that are found\r\n\t\t */\r\n    index(chart, e, options, useFinalPosition) {\r\n      const position = getRelativePosition(e, chart);\r\n      // Default axis for index mode is 'x' to match old behaviour\r\n      const axis = options.axis || 'x';\r\n      const includeInvisible = options.includeInvisible || false;\r\n      const items = options.intersect\r\n        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible)\r\n        : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\r\n      const elements = [];\r\n\r\n      if (!items.length) {\r\n        return [];\r\n      }\r\n\r\n      chart.getSortedVisibleDatasetMetas().forEach((meta) => {\r\n        const index = items[0].index;\r\n        const element = meta.data[index];\r\n\r\n        // don't count items that are skipped (null data)\r\n        if (element && !element.skip) {\r\n          elements.push({element, datasetIndex: meta.index, index});\r\n        }\r\n      });\r\n\r\n      return elements;\r\n    },\r\n\r\n    /**\r\n\t\t * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\r\n\t\t * If the options.intersect is false, we find the nearest item and return the items in that dataset\r\n\t\t * @function Chart.Interaction.modes.dataset\r\n\t\t * @param {Chart} chart - the chart we are returning items from\r\n\t\t * @param {Event} e - the event we are find things at\r\n\t\t * @param {InteractionOptions} options - options to use\r\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\r\n\t\t * @return {InteractionItem[]} - items that are found\r\n\t\t */\r\n    dataset(chart, e, options, useFinalPosition) {\r\n      const position = getRelativePosition(e, chart);\r\n      const axis = options.axis || 'xy';\r\n      const includeInvisible = options.includeInvisible || false;\r\n      let items = options.intersect\r\n        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) :\r\n        getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\r\n\r\n      if (items.length > 0) {\r\n        const datasetIndex = items[0].datasetIndex;\r\n        const data = chart.getDatasetMeta(datasetIndex).data;\r\n        items = [];\r\n        for (let i = 0; i < data.length; ++i) {\r\n          items.push({element: data[i], datasetIndex, index: i});\r\n        }\r\n      }\r\n\r\n      return items;\r\n    },\r\n\r\n    /**\r\n\t\t * Point mode returns all elements that hit test based on the event position\r\n\t\t * of the event\r\n\t\t * @function Chart.Interaction.modes.intersect\r\n\t\t * @param {Chart} chart - the chart we are returning items from\r\n\t\t * @param {Event} e - the event we are find things at\r\n\t\t * @param {InteractionOptions} options - options to use\r\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\r\n\t\t * @return {InteractionItem[]} - items that are found\r\n\t\t */\r\n    point(chart, e, options, useFinalPosition) {\r\n      const position = getRelativePosition(e, chart);\r\n      const axis = options.axis || 'xy';\r\n      const includeInvisible = options.includeInvisible || false;\r\n      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);\r\n    },\r\n\r\n    /**\r\n\t\t * nearest mode returns the element closest to the point\r\n\t\t * @function Chart.Interaction.modes.intersect\r\n\t\t * @param {Chart} chart - the chart we are returning items from\r\n\t\t * @param {Event} e - the event we are find things at\r\n\t\t * @param {InteractionOptions} options - options to use\r\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\r\n\t\t * @return {InteractionItem[]} - items that are found\r\n\t\t */\r\n    nearest(chart, e, options, useFinalPosition) {\r\n      const position = getRelativePosition(e, chart);\r\n      const axis = options.axis || 'xy';\r\n      const includeInvisible = options.includeInvisible || false;\r\n      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);\r\n    },\r\n\r\n    /**\r\n\t\t * x mode returns the elements that hit-test at the current x coordinate\r\n\t\t * @function Chart.Interaction.modes.x\r\n\t\t * @param {Chart} chart - the chart we are returning items from\r\n\t\t * @param {Event} e - the event we are find things at\r\n\t\t * @param {InteractionOptions} options - options to use\r\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\r\n\t\t * @return {InteractionItem[]} - items that are found\r\n\t\t */\r\n    x(chart, e, options, useFinalPosition) {\r\n      const position = getRelativePosition(e, chart);\r\n      return getAxisItems(chart, position, 'x', options.intersect, useFinalPosition);\r\n    },\r\n\r\n    /**\r\n\t\t * y mode returns the elements that hit-test at the current y coordinate\r\n\t\t * @function Chart.Interaction.modes.y\r\n\t\t * @param {Chart} chart - the chart we are returning items from\r\n\t\t * @param {Event} e - the event we are find things at\r\n\t\t * @param {InteractionOptions} options - options to use\r\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\r\n\t\t * @return {InteractionItem[]} - items that are found\r\n\t\t */\r\n    y(chart, e, options, useFinalPosition) {\r\n      const position = getRelativePosition(e, chart);\r\n      return getAxisItems(chart, position, 'y', options.intersect, useFinalPosition);\r\n    }\r\n  }\r\n};\r\n","import {defined, each, isObject} from '../helpers/helpers.core.js';\r\nimport {toPadding} from '../helpers/helpers.options.js';\r\n\r\n/**\r\n * @typedef { import('./core.controller.js').default } Chart\r\n */\r\n\r\nconst STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];\r\n\r\nfunction filterByPosition(array, position) {\r\n  return array.filter(v => v.pos === position);\r\n}\r\n\r\nfunction filterDynamicPositionByAxis(array, axis) {\r\n  return array.filter(v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\r\n}\r\n\r\nfunction sortByWeight(array, reverse) {\r\n  return array.sort((a, b) => {\r\n    const v0 = reverse ? b : a;\r\n    const v1 = reverse ? a : b;\r\n    return v0.weight === v1.weight ?\r\n      v0.index - v1.index :\r\n      v0.weight - v1.weight;\r\n  });\r\n}\r\n\r\nfunction wrapBoxes(boxes) {\r\n  const layoutBoxes = [];\r\n  let i, ilen, box, pos, stack, stackWeight;\r\n\r\n  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {\r\n    box = boxes[i];\r\n    ({position: pos, options: {stack, stackWeight = 1}} = box);\r\n    layoutBoxes.push({\r\n      index: i,\r\n      box,\r\n      pos,\r\n      horizontal: box.isHorizontal(),\r\n      weight: box.weight,\r\n      stack: stack && (pos + stack),\r\n      stackWeight\r\n    });\r\n  }\r\n  return layoutBoxes;\r\n}\r\n\r\nfunction buildStacks(layouts) {\r\n  const stacks = {};\r\n  for (const wrap of layouts) {\r\n    const {stack, pos, stackWeight} = wrap;\r\n    if (!stack || !STATIC_POSITIONS.includes(pos)) {\r\n      continue;\r\n    }\r\n    const _stack = stacks[stack] || (stacks[stack] = {count: 0, placed: 0, weight: 0, size: 0});\r\n    _stack.count++;\r\n    _stack.weight += stackWeight;\r\n  }\r\n  return stacks;\r\n}\r\n\r\n/**\r\n * store dimensions used instead of available chartArea in fitBoxes\r\n **/\r\nfunction setLayoutDims(layouts, params) {\r\n  const stacks = buildStacks(layouts);\r\n  const {vBoxMaxWidth, hBoxMaxHeight} = params;\r\n  let i, ilen, layout;\r\n  for (i = 0, ilen = layouts.length; i < ilen; ++i) {\r\n    layout = layouts[i];\r\n    const {fullSize} = layout.box;\r\n    const stack = stacks[layout.stack];\r\n    const factor = stack && layout.stackWeight / stack.weight;\r\n    if (layout.horizontal) {\r\n      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\r\n      layout.height = hBoxMaxHeight;\r\n    } else {\r\n      layout.width = vBoxMaxWidth;\r\n      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\r\n    }\r\n  }\r\n  return stacks;\r\n}\r\n\r\nfunction buildLayoutBoxes(boxes) {\r\n  const layoutBoxes = wrapBoxes(boxes);\r\n  const fullSize = sortByWeight(layoutBoxes.filter(wrap => wrap.box.fullSize), true);\r\n  const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\r\n  const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\r\n  const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\r\n  const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\r\n  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');\r\n  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');\r\n\r\n  return {\r\n    fullSize,\r\n    leftAndTop: left.concat(top),\r\n    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\r\n    chartArea: filterByPosition(layoutBoxes, 'chartArea'),\r\n    vertical: left.concat(right).concat(centerVertical),\r\n    horizontal: top.concat(bottom).concat(centerHorizontal)\r\n  };\r\n}\r\n\r\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\r\n  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\r\n}\r\n\r\nfunction updateMaxPadding(maxPadding, boxPadding) {\r\n  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\r\n  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\r\n  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\r\n  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\r\n}\r\n\r\nfunction updateDims(chartArea, params, layout, stacks) {\r\n  const {pos, box} = layout;\r\n  const maxPadding = chartArea.maxPadding;\r\n\r\n  // dynamically placed boxes size is not considered\r\n  if (!isObject(pos)) {\r\n    if (layout.size) {\r\n      // this layout was already counted for, lets first reduce old size\r\n      chartArea[pos] -= layout.size;\r\n    }\r\n    const stack = stacks[layout.stack] || {size: 0, count: 1};\r\n    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\r\n    layout.size = stack.size / stack.count;\r\n    chartArea[pos] += layout.size;\r\n  }\r\n\r\n  if (box.getPadding) {\r\n    updateMaxPadding(maxPadding, box.getPadding());\r\n  }\r\n\r\n  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));\r\n  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));\r\n  const widthChanged = newWidth !== chartArea.w;\r\n  const heightChanged = newHeight !== chartArea.h;\r\n  chartArea.w = newWidth;\r\n  chartArea.h = newHeight;\r\n\r\n  // return booleans on the changes per direction\r\n  return layout.horizontal\r\n    ? {same: widthChanged, other: heightChanged}\r\n    : {same: heightChanged, other: widthChanged};\r\n}\r\n\r\nfunction handleMaxPadding(chartArea) {\r\n  const maxPadding = chartArea.maxPadding;\r\n\r\n  function updatePos(pos) {\r\n    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\r\n    chartArea[pos] += change;\r\n    return change;\r\n  }\r\n  chartArea.y += updatePos('top');\r\n  chartArea.x += updatePos('left');\r\n  updatePos('right');\r\n  updatePos('bottom');\r\n}\r\n\r\nfunction getMargins(horizontal, chartArea) {\r\n  const maxPadding = chartArea.maxPadding;\r\n\r\n  function marginForPositions(positions) {\r\n    const margin = {left: 0, top: 0, right: 0, bottom: 0};\r\n    positions.forEach((pos) => {\r\n      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\r\n    });\r\n    return margin;\r\n  }\r\n\r\n  return horizontal\r\n    ? marginForPositions(['left', 'right'])\r\n    : marginForPositions(['top', 'bottom']);\r\n}\r\n\r\nfunction fitBoxes(boxes, chartArea, params, stacks) {\r\n  const refitBoxes = [];\r\n  let i, ilen, layout, box, refit, changed;\r\n\r\n  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {\r\n    layout = boxes[i];\r\n    box = layout.box;\r\n\r\n    box.update(\r\n      layout.width || chartArea.w,\r\n      layout.height || chartArea.h,\r\n      getMargins(layout.horizontal, chartArea)\r\n    );\r\n    const {same, other} = updateDims(chartArea, params, layout, stacks);\r\n\r\n    // Dimensions changed and there were non full width boxes before this\r\n    // -> we have to refit those\r\n    refit |= same && refitBoxes.length;\r\n\r\n    // Chart area changed in the opposite direction\r\n    changed = changed || other;\r\n\r\n    if (!box.fullSize) { // fullSize boxes don't need to be re-fitted in any case\r\n      refitBoxes.push(layout);\r\n    }\r\n  }\r\n\r\n  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\r\n}\r\n\r\nfunction setBoxDims(box, left, top, width, height) {\r\n  box.top = top;\r\n  box.left = left;\r\n  box.right = left + width;\r\n  box.bottom = top + height;\r\n  box.width = width;\r\n  box.height = height;\r\n}\r\n\r\nfunction placeBoxes(boxes, chartArea, params, stacks) {\r\n  const userPadding = params.padding;\r\n  let {x, y} = chartArea;\r\n\r\n  for (const layout of boxes) {\r\n    const box = layout.box;\r\n    const stack = stacks[layout.stack] || {count: 1, placed: 0, weight: 1};\r\n    const weight = (layout.stackWeight / stack.weight) || 1;\r\n    if (layout.horizontal) {\r\n      const width = chartArea.w * weight;\r\n      const height = stack.size || box.height;\r\n      if (defined(stack.start)) {\r\n        y = stack.start;\r\n      }\r\n      if (box.fullSize) {\r\n        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\r\n      } else {\r\n        setBoxDims(box, chartArea.left + stack.placed, y, width, height);\r\n      }\r\n      stack.start = y;\r\n      stack.placed += width;\r\n      y = box.bottom;\r\n    } else {\r\n      const height = chartArea.h * weight;\r\n      const width = stack.size || box.width;\r\n      if (defined(stack.start)) {\r\n        x = stack.start;\r\n      }\r\n      if (box.fullSize) {\r\n        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);\r\n      } else {\r\n        setBoxDims(box, x, chartArea.top + stack.placed, width, height);\r\n      }\r\n      stack.start = x;\r\n      stack.placed += height;\r\n      x = box.right;\r\n    }\r\n  }\r\n\r\n  chartArea.x = x;\r\n  chartArea.y = y;\r\n}\r\n\r\n/**\r\n * @interface LayoutItem\r\n * @typedef {object} LayoutItem\r\n * @prop {string} position - The position of the item in the chart layout. Possible values are\r\n * 'left', 'top', 'right', 'bottom', and 'chartArea'\r\n * @prop {number} weight - The weight used to sort the item. Higher weights are further away from the chart area\r\n * @prop {boolean} fullSize - if true, and the item is horizontal, then push vertical boxes down\r\n * @prop {function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)\r\n * @prop {function} update - Takes two parameters: width and height. Returns size of item\r\n * @prop {function} draw - Draws the element\r\n * @prop {function} [getPadding] -  Returns an object with padding on the edges\r\n * @prop {number} width - Width of item. Must be valid after update()\r\n * @prop {number} height - Height of item. Must be valid after update()\r\n * @prop {number} left - Left edge of the item. Set by layout system and cannot be used in update\r\n * @prop {number} top - Top edge of the item. Set by layout system and cannot be used in update\r\n * @prop {number} right - Right edge of the item. Set by layout system and cannot be used in update\r\n * @prop {number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update\r\n */\r\n\r\n// The layout service is very self explanatory.  It's responsible for the layout within a chart.\r\n// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need\r\n// It is this service's responsibility of carrying out that layout.\r\nexport default {\r\n\r\n  /**\r\n\t * Register a box to a chart.\r\n\t * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.\r\n\t * @param {Chart} chart - the chart to use\r\n\t * @param {LayoutItem} item - the item to add to be laid out\r\n\t */\r\n  addBox(chart, item) {\r\n    if (!chart.boxes) {\r\n      chart.boxes = [];\r\n    }\r\n\r\n    // initialize item with default values\r\n    item.fullSize = item.fullSize || false;\r\n    item.position = item.position || 'top';\r\n    item.weight = item.weight || 0;\r\n    // @ts-ignore\r\n    item._layers = item._layers || function() {\r\n      return [{\r\n        z: 0,\r\n        draw(chartArea) {\r\n          item.draw(chartArea);\r\n        }\r\n      }];\r\n    };\r\n\r\n    chart.boxes.push(item);\r\n  },\r\n\r\n  /**\r\n\t * Remove a layoutItem from a chart\r\n\t * @param {Chart} chart - the chart to remove the box from\r\n\t * @param {LayoutItem} layoutItem - the item to remove from the layout\r\n\t */\r\n  removeBox(chart, layoutItem) {\r\n    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\r\n    if (index !== -1) {\r\n      chart.boxes.splice(index, 1);\r\n    }\r\n  },\r\n\r\n  /**\r\n\t * Sets (or updates) options on the given `item`.\r\n\t * @param {Chart} chart - the chart in which the item lives (or will be added to)\r\n\t * @param {LayoutItem} item - the item to configure with the given options\r\n\t * @param {object} options - the new item options.\r\n\t */\r\n  configure(chart, item, options) {\r\n    item.fullSize = options.fullSize;\r\n    item.position = options.position;\r\n    item.weight = options.weight;\r\n  },\r\n\r\n  /**\r\n\t * Fits boxes of the given chart into the given size by having each box measure itself\r\n\t * then running a fitting algorithm\r\n\t * @param {Chart} chart - the chart\r\n\t * @param {number} width - the width to fit into\r\n\t * @param {number} height - the height to fit into\r\n   * @param {number} minPadding - minimum padding required for each side of chart area\r\n\t */\r\n  update(chart, width, height, minPadding) {\r\n    if (!chart) {\r\n      return;\r\n    }\r\n\r\n    const padding = toPadding(chart.options.layout.padding);\r\n    const availableWidth = Math.max(width - padding.width, 0);\r\n    const availableHeight = Math.max(height - padding.height, 0);\r\n    const boxes = buildLayoutBoxes(chart.boxes);\r\n    const verticalBoxes = boxes.vertical;\r\n    const horizontalBoxes = boxes.horizontal;\r\n\r\n    // Before any changes are made, notify boxes that an update is about to being\r\n    // This is used to clear any cached data (e.g. scale limits)\r\n    each(chart.boxes, box => {\r\n      if (typeof box.beforeLayout === 'function') {\r\n        box.beforeLayout();\r\n      }\r\n    });\r\n\r\n    // Essentially we now have any number of boxes on each of the 4 sides.\r\n    // Our canvas looks like the following.\r\n    // The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\r\n    // B1 is the bottom axis\r\n    // There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\r\n    // These locations are single-box locations only, when trying to register a chartArea location that is already taken,\r\n    // an error will be thrown.\r\n    //\r\n    // |----------------------------------------------------|\r\n    // |                  T1 (Full Width)                   |\r\n    // |----------------------------------------------------|\r\n    // |    |    |                 T2                  |    |\r\n    // |    |----|-------------------------------------|----|\r\n    // |    |    | C1 |                           | C2 |    |\r\n    // |    |    |----|                           |----|    |\r\n    // |    |    |                                     |    |\r\n    // | L1 | L2 |           ChartArea (C0)            | R1 |\r\n    // |    |    |                                     |    |\r\n    // |    |    |----|                           |----|    |\r\n    // |    |    | C3 |                           | C4 |    |\r\n    // |    |----|-------------------------------------|----|\r\n    // |    |    |                 B1                  |    |\r\n    // |----------------------------------------------------|\r\n    // |                  B2 (Full Width)                   |\r\n    // |----------------------------------------------------|\r\n    //\r\n\r\n    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) =>\r\n      wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\r\n\r\n    const params = Object.freeze({\r\n      outerWidth: width,\r\n      outerHeight: height,\r\n      padding,\r\n      availableWidth,\r\n      availableHeight,\r\n      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\r\n      hBoxMaxHeight: availableHeight / 2\r\n    });\r\n    const maxPadding = Object.assign({}, padding);\r\n    updateMaxPadding(maxPadding, toPadding(minPadding));\r\n    const chartArea = Object.assign({\r\n      maxPadding,\r\n      w: availableWidth,\r\n      h: availableHeight,\r\n      x: padding.left,\r\n      y: padding.top\r\n    }, padding);\r\n\r\n    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\r\n\r\n    // First fit the fullSize boxes, to reduce probability of re-fitting.\r\n    fitBoxes(boxes.fullSize, chartArea, params, stacks);\r\n\r\n    // Then fit vertical boxes\r\n    fitBoxes(verticalBoxes, chartArea, params, stacks);\r\n\r\n    // Then fit horizontal boxes\r\n    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\r\n      // if the area changed, re-fit vertical boxes\r\n      fitBoxes(verticalBoxes, chartArea, params, stacks);\r\n    }\r\n\r\n    handleMaxPadding(chartArea);\r\n\r\n    // Finally place the boxes to correct coordinates\r\n    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\r\n\r\n    // Move to opposite side of chart\r\n    chartArea.x += chartArea.w;\r\n    chartArea.y += chartArea.h;\r\n\r\n    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\r\n\r\n    chart.chartArea = {\r\n      left: chartArea.left,\r\n      top: chartArea.top,\r\n      right: chartArea.left + chartArea.w,\r\n      bottom: chartArea.top + chartArea.h,\r\n      height: chartArea.h,\r\n      width: chartArea.w,\r\n    };\r\n\r\n    // Finally update boxes in chartArea (radial scale for example)\r\n    each(boxes.chartArea, (layout) => {\r\n      const box = layout.box;\r\n      Object.assign(box, chart.chartArea);\r\n      box.update(chartArea.w, chartArea.h, {left: 0, top: 0, right: 0, bottom: 0});\r\n    });\r\n  }\r\n};\r\n","\r\n/**\r\n * @typedef { import('../core/core.controller.js').default } Chart\r\n */\r\n\r\n/**\r\n * Abstract class that allows abstracting platform dependencies away from the chart.\r\n */\r\nexport default class BasePlatform {\r\n  /**\r\n\t * Called at chart construction time, returns a context2d instance implementing\r\n\t * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.\r\n\t * @param {HTMLCanvasElement} canvas - The canvas from which to acquire context (platform specific)\r\n\t * @param {number} [aspectRatio] - The chart options\r\n\t */\r\n  acquireContext(canvas, aspectRatio) {} // eslint-disable-line no-unused-vars\r\n\r\n  /**\r\n\t * Called at chart destruction time, releases any resources associated to the context\r\n\t * previously returned by the acquireContext() method.\r\n\t * @param {CanvasRenderingContext2D} context - The context2d instance\r\n\t * @returns {boolean} true if the method succeeded, else false\r\n\t */\r\n  releaseContext(context) { // eslint-disable-line no-unused-vars\r\n    return false;\r\n  }\r\n\r\n  /**\r\n\t * Registers the specified listener on the given chart.\r\n\t * @param {Chart} chart - Chart from which to listen for event\r\n\t * @param {string} type - The ({@link ChartEvent}) type to listen for\r\n\t * @param {function} listener - Receives a notification (an object that implements\r\n\t * the {@link ChartEvent} interface) when an event of the specified type occurs.\r\n\t */\r\n  addEventListener(chart, type, listener) {} // eslint-disable-line no-unused-vars\r\n\r\n  /**\r\n\t * Removes the specified listener previously registered with addEventListener.\r\n\t * @param {Chart} chart - Chart from which to remove the listener\r\n\t * @param {string} type - The ({@link ChartEvent}) type to remove\r\n\t * @param {function} listener - The listener function to remove from the event target.\r\n\t */\r\n  removeEventListener(chart, type, listener) {} // eslint-disable-line no-unused-vars\r\n\r\n  /**\r\n\t * @returns {number} the current devicePixelRatio of the device this platform is connected to.\r\n\t */\r\n  getDevicePixelRatio() {\r\n    return 1;\r\n  }\r\n\r\n  /**\r\n\t * Returns the maximum size in pixels of given canvas element.\r\n\t * @param {HTMLCanvasElement} element\r\n\t * @param {number} [width] - content width of parent element\r\n\t * @param {number} [height] - content height of parent element\r\n\t * @param {number} [aspectRatio] - aspect ratio to maintain\r\n\t */\r\n  getMaximumSize(element, width, height, aspectRatio) {\r\n    width = Math.max(0, width || element.width);\r\n    height = height || element.height;\r\n    return {\r\n      width,\r\n      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\r\n    };\r\n  }\r\n\r\n  /**\r\n\t * @param {HTMLCanvasElement} canvas\r\n\t * @returns {boolean} true if the canvas is attached to the platform, false if not.\r\n\t */\r\n  isAttached(canvas) { // eslint-disable-line no-unused-vars\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Updates config with platform specific requirements\r\n   * @param {import('../core/core.config.js').default} config\r\n   */\r\n  updateConfig(config) { // eslint-disable-line no-unused-vars\r\n    // no-op\r\n  }\r\n}\r\n","/**\r\n * Platform fallback implementation (minimal).\r\n * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939\r\n */\r\n\r\nimport BasePlatform from './platform.base.js';\r\n\r\n/**\r\n * Platform class for charts without access to the DOM or to many element properties\r\n * This platform is used by default for any chart passed an OffscreenCanvas.\r\n * @extends BasePlatform\r\n */\r\nexport default class BasicPlatform extends BasePlatform {\r\n  acquireContext(item) {\r\n    // To prevent canvas fingerprinting, some add-ons undefine the getContext\r\n    // method, for example: https://github.com/kkapsner/CanvasBlocker\r\n    // https://github.com/chartjs/Chart.js/issues/2807\r\n    return item && item.getContext && item.getContext('2d') || null;\r\n  }\r\n  updateConfig(config) {\r\n    config.options.animation = false;\r\n  }\r\n}\r\n","/**\r\n * Chart.Platform implementation for targeting a web browser\r\n */\r\n\r\nimport BasePlatform from './platform.base.js';\r\nimport {_getParentNode, getRelativePosition, supportsEventListenerOptions, readUsedSize, getMaximumSize} from '../helpers/helpers.dom.js';\r\nimport {throttled} from '../helpers/helpers.extras.js';\r\nimport {isNullOrUndef} from '../helpers/helpers.core.js';\r\n\r\n/**\r\n * @typedef { import('../core/core.controller.js').default } Chart\r\n */\r\n\r\nconst EXPANDO_KEY = '$chartjs';\r\n\r\n/**\r\n * DOM event types -> Chart.js event types.\r\n * Note: only events with different types are mapped.\r\n * @see https://developer.mozilla.org/en-US/docs/Web/Events\r\n */\r\nconst EVENT_TYPES = {\r\n  touchstart: 'mousedown',\r\n  touchmove: 'mousemove',\r\n  touchend: 'mouseup',\r\n  pointerenter: 'mouseenter',\r\n  pointerdown: 'mousedown',\r\n  pointermove: 'mousemove',\r\n  pointerup: 'mouseup',\r\n  pointerleave: 'mouseout',\r\n  pointerout: 'mouseout'\r\n};\r\n\r\nconst isNullOrEmpty = value => value === null || value === '';\r\n/**\r\n * Initializes the canvas style and render size without modifying the canvas display size,\r\n * since responsiveness is handled by the controller.resize() method. The config is used\r\n * to determine the aspect ratio to apply in case no explicit height has been specified.\r\n * @param {HTMLCanvasElement} canvas\r\n * @param {number} [aspectRatio]\r\n */\r\nfunction initCanvas(canvas, aspectRatio) {\r\n  const style = canvas.style;\r\n\r\n  // NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it\r\n  // returns null or '' if no explicit value has been set to the canvas attribute.\r\n  const renderHeight = canvas.getAttribute('height');\r\n  const renderWidth = canvas.getAttribute('width');\r\n\r\n  // Chart.js modifies some canvas values that we want to restore on destroy\r\n  canvas[EXPANDO_KEY] = {\r\n    initial: {\r\n      height: renderHeight,\r\n      width: renderWidth,\r\n      style: {\r\n        display: style.display,\r\n        height: style.height,\r\n        width: style.width\r\n      }\r\n    }\r\n  };\r\n\r\n  // Force canvas to display as block to avoid extra space caused by inline\r\n  // elements, which would interfere with the responsive resize process.\r\n  // https://github.com/chartjs/Chart.js/issues/2538\r\n  style.display = style.display || 'block';\r\n  // Include possible borders in the size\r\n  style.boxSizing = style.boxSizing || 'border-box';\r\n\r\n  if (isNullOrEmpty(renderWidth)) {\r\n    const displayWidth = readUsedSize(canvas, 'width');\r\n    if (displayWidth !== undefined) {\r\n      canvas.width = displayWidth;\r\n    }\r\n  }\r\n\r\n  if (isNullOrEmpty(renderHeight)) {\r\n    if (canvas.style.height === '') {\r\n      // If no explicit render height and style height, let's apply the aspect ratio,\r\n      // which one can be specified by the user but also by charts as default option\r\n      // (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.\r\n      canvas.height = canvas.width / (aspectRatio || 2);\r\n    } else {\r\n      const displayHeight = readUsedSize(canvas, 'height');\r\n      if (displayHeight !== undefined) {\r\n        canvas.height = displayHeight;\r\n      }\r\n    }\r\n  }\r\n\r\n  return canvas;\r\n}\r\n\r\n// Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.\r\n// https://github.com/chartjs/Chart.js/issues/4287\r\nconst eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;\r\n\r\nfunction addListener(node, type, listener) {\r\n  node.addEventListener(type, listener, eventListenerOptions);\r\n}\r\n\r\nfunction removeListener(chart, type, listener) {\r\n  chart.canvas.removeEventListener(type, listener, eventListenerOptions);\r\n}\r\n\r\nfunction fromNativeEvent(event, chart) {\r\n  const type = EVENT_TYPES[event.type] || event.type;\r\n  const {x, y} = getRelativePosition(event, chart);\r\n  return {\r\n    type,\r\n    chart,\r\n    native: event,\r\n    x: x !== undefined ? x : null,\r\n    y: y !== undefined ? y : null,\r\n  };\r\n}\r\n\r\nfunction nodeListContains(nodeList, canvas) {\r\n  for (const node of nodeList) {\r\n    if (node === canvas || node.contains(canvas)) {\r\n      return true;\r\n    }\r\n  }\r\n}\r\n\r\nfunction createAttachObserver(chart, type, listener) {\r\n  const canvas = chart.canvas;\r\n  const observer = new MutationObserver(entries => {\r\n    let trigger = false;\r\n    for (const entry of entries) {\r\n      trigger = trigger || nodeListContains(entry.addedNodes, canvas);\r\n      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);\r\n    }\r\n    if (trigger) {\r\n      listener();\r\n    }\r\n  });\r\n  observer.observe(document, {childList: true, subtree: true});\r\n  return observer;\r\n}\r\n\r\nfunction createDetachObserver(chart, type, listener) {\r\n  const canvas = chart.canvas;\r\n  const observer = new MutationObserver(entries => {\r\n    let trigger = false;\r\n    for (const entry of entries) {\r\n      trigger = trigger || nodeListContains(entry.removedNodes, canvas);\r\n      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);\r\n    }\r\n    if (trigger) {\r\n      listener();\r\n    }\r\n  });\r\n  observer.observe(document, {childList: true, subtree: true});\r\n  return observer;\r\n}\r\n\r\nconst drpListeningCharts = new Map();\r\nlet oldDevicePixelRatio = 0;\r\n\r\nfunction onWindowResize() {\r\n  const dpr = window.devicePixelRatio;\r\n  if (dpr === oldDevicePixelRatio) {\r\n    return;\r\n  }\r\n  oldDevicePixelRatio = dpr;\r\n  drpListeningCharts.forEach((resize, chart) => {\r\n    if (chart.currentDevicePixelRatio !== dpr) {\r\n      resize();\r\n    }\r\n  });\r\n}\r\n\r\nfunction listenDevicePixelRatioChanges(chart, resize) {\r\n  if (!drpListeningCharts.size) {\r\n    window.addEventListener('resize', onWindowResize);\r\n  }\r\n  drpListeningCharts.set(chart, resize);\r\n}\r\n\r\nfunction unlistenDevicePixelRatioChanges(chart) {\r\n  drpListeningCharts.delete(chart);\r\n  if (!drpListeningCharts.size) {\r\n    window.removeEventListener('resize', onWindowResize);\r\n  }\r\n}\r\n\r\nfunction createResizeObserver(chart, type, listener) {\r\n  const canvas = chart.canvas;\r\n  const container = canvas && _getParentNode(canvas);\r\n  if (!container) {\r\n    return;\r\n  }\r\n  const resize = throttled((width, height) => {\r\n    const w = container.clientWidth;\r\n    listener(width, height);\r\n    if (w < container.clientWidth) {\r\n      // If the container size shrank during chart resize, let's assume\r\n      // scrollbar appeared. So we resize again with the scrollbar visible -\r\n      // effectively making chart smaller and the scrollbar hidden again.\r\n      // Because we are inside `throttled`, and currently `ticking`, scroll\r\n      // events are ignored during this whole 2 resize process.\r\n      // If we assumed wrong and something else happened, we are resizing\r\n      // twice in a frame (potential performance issue)\r\n      listener();\r\n    }\r\n  }, window);\r\n\r\n  // @ts-ignore until https://github.com/microsoft/TypeScript/issues/37861 implemented\r\n  const observer = new ResizeObserver(entries => {\r\n    const entry = entries[0];\r\n    const width = entry.contentRect.width;\r\n    const height = entry.contentRect.height;\r\n    // When its container's display is set to 'none' the callback will be called with a\r\n    // size of (0, 0), which will cause the chart to lose its original height, so skip\r\n    // resizing in such case.\r\n    if (width === 0 && height === 0) {\r\n      return;\r\n    }\r\n    resize(width, height);\r\n  });\r\n  observer.observe(container);\r\n  listenDevicePixelRatioChanges(chart, resize);\r\n\r\n  return observer;\r\n}\r\n\r\nfunction releaseObserver(chart, type, observer) {\r\n  if (observer) {\r\n    observer.disconnect();\r\n  }\r\n  if (type === 'resize') {\r\n    unlistenDevicePixelRatioChanges(chart);\r\n  }\r\n}\r\n\r\nfunction createProxyAndListen(chart, type, listener) {\r\n  const canvas = chart.canvas;\r\n  const proxy = throttled((event) => {\r\n    // This case can occur if the chart is destroyed while waiting\r\n    // for the throttled function to occur. We prevent crashes by checking\r\n    // for a destroyed chart\r\n    if (chart.ctx !== null) {\r\n      listener(fromNativeEvent(event, chart));\r\n    }\r\n  }, chart);\r\n\r\n  addListener(canvas, type, proxy);\r\n\r\n  return proxy;\r\n}\r\n\r\n/**\r\n * Platform class for charts that can access the DOM and global window/document properties\r\n * @extends BasePlatform\r\n */\r\nexport default class DomPlatform extends BasePlatform {\r\n\r\n  /**\r\n\t * @param {HTMLCanvasElement} canvas\r\n\t * @param {number} [aspectRatio]\r\n\t * @return {CanvasRenderingContext2D|null}\r\n\t */\r\n  acquireContext(canvas, aspectRatio) {\r\n    // To prevent canvas fingerprinting, some add-ons undefine the getContext\r\n    // method, for example: https://github.com/kkapsner/CanvasBlocker\r\n    // https://github.com/chartjs/Chart.js/issues/2807\r\n    const context = canvas && canvas.getContext && canvas.getContext('2d');\r\n\r\n    // `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the canvas is\r\n    // inside an iframe or when running in a protected environment. We could guess the\r\n    // types from their toString() value but let's keep things flexible and assume it's\r\n    // a sufficient condition if the canvas has a context2D which has canvas as `canvas`.\r\n    // https://github.com/chartjs/Chart.js/issues/3887\r\n    // https://github.com/chartjs/Chart.js/issues/4102\r\n    // https://github.com/chartjs/Chart.js/issues/4152\r\n    if (context && context.canvas === canvas) {\r\n      // Load platform resources on first chart creation, to make it possible to\r\n      // import the library before setting platform options.\r\n      initCanvas(canvas, aspectRatio);\r\n      return context;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n\t * @param {CanvasRenderingContext2D} context\r\n\t */\r\n  releaseContext(context) {\r\n    const canvas = context.canvas;\r\n    if (!canvas[EXPANDO_KEY]) {\r\n      return false;\r\n    }\r\n\r\n    const initial = canvas[EXPANDO_KEY].initial;\r\n    ['height', 'width'].forEach((prop) => {\r\n      const value = initial[prop];\r\n      if (isNullOrUndef(value)) {\r\n        canvas.removeAttribute(prop);\r\n      } else {\r\n        canvas.setAttribute(prop, value);\r\n      }\r\n    });\r\n\r\n    const style = initial.style || {};\r\n    Object.keys(style).forEach((key) => {\r\n      canvas.style[key] = style[key];\r\n    });\r\n\r\n    // The canvas render size might have been changed (and thus the state stack discarded),\r\n    // we can't use save() and restore() to restore the initial state. So make sure that at\r\n    // least the canvas context is reset to the default state by setting the canvas width.\r\n    // https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html\r\n    // eslint-disable-next-line no-self-assign\r\n    canvas.width = canvas.width;\r\n\r\n    delete canvas[EXPANDO_KEY];\r\n    return true;\r\n  }\r\n\r\n  /**\r\n\t *\r\n\t * @param {Chart} chart\r\n\t * @param {string} type\r\n\t * @param {function} listener\r\n\t */\r\n  addEventListener(chart, type, listener) {\r\n    // Can have only one listener per type, so make sure previous is removed\r\n    this.removeEventListener(chart, type);\r\n\r\n    const proxies = chart.$proxies || (chart.$proxies = {});\r\n    const handlers = {\r\n      attach: createAttachObserver,\r\n      detach: createDetachObserver,\r\n      resize: createResizeObserver\r\n    };\r\n    const handler = handlers[type] || createProxyAndListen;\r\n    proxies[type] = handler(chart, type, listener);\r\n  }\r\n\r\n\r\n  /**\r\n\t * @param {Chart} chart\r\n\t * @param {string} type\r\n\t */\r\n  removeEventListener(chart, type) {\r\n    const proxies = chart.$proxies || (chart.$proxies = {});\r\n    const proxy = proxies[type];\r\n\r\n    if (!proxy) {\r\n      return;\r\n    }\r\n\r\n    const handlers = {\r\n      attach: releaseObserver,\r\n      detach: releaseObserver,\r\n      resize: releaseObserver\r\n    };\r\n    const handler = handlers[type] || removeListener;\r\n    handler(chart, type, proxy);\r\n    proxies[type] = undefined;\r\n  }\r\n\r\n  getDevicePixelRatio() {\r\n    return window.devicePixelRatio;\r\n  }\r\n\r\n  /**\r\n\t * @param {HTMLCanvasElement} canvas\r\n\t * @param {number} [width] - content width of parent element\r\n\t * @param {number} [height] - content height of parent element\r\n\t * @param {number} [aspectRatio] - aspect ratio to maintain\r\n\t */\r\n  getMaximumSize(canvas, width, height, aspectRatio) {\r\n    return getMaximumSize(canvas, width, height, aspectRatio);\r\n  }\r\n\r\n  /**\r\n\t * @param {HTMLCanvasElement} canvas\r\n\t */\r\n  isAttached(canvas) {\r\n    const container = _getParentNode(canvas);\r\n    return !!(container && container.isConnected);\r\n  }\r\n}\r\n","import {_isDomSupported} from '../helpers/index.js';\r\nimport BasePlatform from './platform.base.js';\r\nimport BasicPlatform from './platform.basic.js';\r\nimport DomPlatform from './platform.dom.js';\r\n\r\nexport function _detectPlatform(canvas) {\r\n  if (!_isDomSupported() || (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas)) {\r\n    return BasicPlatform;\r\n  }\r\n  return DomPlatform;\r\n}\r\n\r\nexport {BasePlatform, BasicPlatform, DomPlatform};\r\n","import type {AnyObject} from '../types/basic.js';\r\nimport type {Point} from '../types/geometric.js';\r\nimport type {Animation} from '../types/animation.js';\r\nimport {isNumber} from '../helpers/helpers.math.js';\r\n\r\nexport default class Element<T = AnyObject, O = AnyObject> {\r\n\r\n  static defaults = {};\r\n  static defaultRoutes = undefined;\r\n\r\n  x: number;\r\n  y: number;\r\n  active = false;\r\n  options: O;\r\n  $animations: Record<keyof T, Animation>;\r\n\r\n  tooltipPosition(useFinalPosition: boolean): Point {\r\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\r\n    return {x, y} as Point;\r\n  }\r\n\r\n  hasValue() {\r\n    return isNumber(this.x) && isNumber(this.y);\r\n  }\r\n\r\n  /**\r\n   * Gets the current or final value of each prop. Can return extra properties (whole object).\r\n   * @param props - properties to get\r\n   * @param [final] - get the final value (animation target)\r\n   */\r\n  getProps<P extends (keyof T)[]>(props: P, final?: boolean): Pick<T, P[number]>;\r\n  getProps<P extends string>(props: P[], final?: boolean): Partial<Record<P, unknown>>;\r\n  getProps(props: string[], final?: boolean): Partial<Record<string, unknown>> {\r\n    const anims = this.$animations;\r\n    if (!final || !anims) {\r\n      // let's not create an object, if not needed\r\n      return this as Record<string, unknown>;\r\n    }\r\n    const ret: Record<string, unknown> = {};\r\n    props.forEach((prop) => {\r\n      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop as string];\r\n    });\r\n    return ret;\r\n  }\r\n}\r\n","import {isNullOrUndef, valueOrDefault} from '../helpers/helpers.core.js';\r\nimport {_factorize} from '../helpers/helpers.math.js';\r\n\r\n\r\n/**\r\n * @typedef { import('./core.controller.js').default } Chart\r\n * @typedef {{value:number | string, label?:string, major?:boolean, $context?:any}} Tick\r\n */\r\n\r\n/**\r\n * Returns a subset of ticks to be plotted to avoid overlapping labels.\r\n * @param {import('./core.scale.js').default} scale\r\n * @param {Tick[]} ticks\r\n * @return {Tick[]}\r\n * @private\r\n */\r\nexport function autoSkip(scale, ticks) {\r\n  const tickOpts = scale.options.ticks;\r\n  const determinedMaxTicks = determineMaxTicks(scale);\r\n  const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);\r\n  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\r\n  const numMajorIndices = majorIndices.length;\r\n  const first = majorIndices[0];\r\n  const last = majorIndices[numMajorIndices - 1];\r\n  const newTicks = [];\r\n\r\n  // If there are too many major ticks to display them all\r\n  if (numMajorIndices > ticksLimit) {\r\n    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\r\n    return newTicks;\r\n  }\r\n\r\n  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\r\n\r\n  if (numMajorIndices > 0) {\r\n    let i, ilen;\r\n    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\r\n    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\r\n    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {\r\n      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\r\n    }\r\n    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\r\n    return newTicks;\r\n  }\r\n  skip(ticks, newTicks, spacing);\r\n  return newTicks;\r\n}\r\n\r\nfunction determineMaxTicks(scale) {\r\n  const offset = scale.options.offset;\r\n  const tickLength = scale._tickSize();\r\n  const maxScale = scale._length / tickLength + (offset ? 0 : 1);\r\n  const maxChart = scale._maxLength / tickLength;\r\n  return Math.floor(Math.min(maxScale, maxChart));\r\n}\r\n\r\n/**\r\n * @param {number[]} majorIndices\r\n * @param {Tick[]} ticks\r\n * @param {number} ticksLimit\r\n */\r\nfunction calculateSpacing(majorIndices, ticks, ticksLimit) {\r\n  const evenMajorSpacing = getEvenSpacing(majorIndices);\r\n  const spacing = ticks.length / ticksLimit;\r\n\r\n  // If the major ticks are evenly spaced apart, place the minor ticks\r\n  // so that they divide the major ticks into even chunks\r\n  if (!evenMajorSpacing) {\r\n    return Math.max(spacing, 1);\r\n  }\r\n\r\n  const factors = _factorize(evenMajorSpacing);\r\n  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {\r\n    const factor = factors[i];\r\n    if (factor > spacing) {\r\n      return factor;\r\n    }\r\n  }\r\n  return Math.max(spacing, 1);\r\n}\r\n\r\n/**\r\n * @param {Tick[]} ticks\r\n */\r\nfunction getMajorIndices(ticks) {\r\n  const result = [];\r\n  let i, ilen;\r\n  for (i = 0, ilen = ticks.length; i < ilen; i++) {\r\n    if (ticks[i].major) {\r\n      result.push(i);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * @param {Tick[]} ticks\r\n * @param {Tick[]} newTicks\r\n * @param {number[]} majorIndices\r\n * @param {number} spacing\r\n */\r\nfunction skipMajors(ticks, newTicks, majorIndices, spacing) {\r\n  let count = 0;\r\n  let next = majorIndices[0];\r\n  let i;\r\n\r\n  spacing = Math.ceil(spacing);\r\n  for (i = 0; i < ticks.length; i++) {\r\n    if (i === next) {\r\n      newTicks.push(ticks[i]);\r\n      count++;\r\n      next = majorIndices[count * spacing];\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Tick[]} ticks\r\n * @param {Tick[]} newTicks\r\n * @param {number} spacing\r\n * @param {number} [majorStart]\r\n * @param {number} [majorEnd]\r\n */\r\nfunction skip(ticks, newTicks, spacing, majorStart, majorEnd) {\r\n  const start = valueOrDefault(majorStart, 0);\r\n  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);\r\n  let count = 0;\r\n  let length, i, next;\r\n\r\n  spacing = Math.ceil(spacing);\r\n  if (majorEnd) {\r\n    length = majorEnd - majorStart;\r\n    spacing = length / Math.floor(length / spacing);\r\n  }\r\n\r\n  next = start;\r\n\r\n  while (next < 0) {\r\n    count++;\r\n    next = Math.round(start + count * spacing);\r\n  }\r\n\r\n  for (i = Math.max(start, 0); i < end; i++) {\r\n    if (i === next) {\r\n      newTicks.push(ticks[i]);\r\n      count++;\r\n      next = Math.round(start + count * spacing);\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @param {number[]} arr\r\n */\r\nfunction getEvenSpacing(arr) {\r\n  const len = arr.length;\r\n  let i, diff;\r\n\r\n  if (len < 2) {\r\n    return false;\r\n  }\r\n\r\n  for (diff = arr[0], i = 1; i < len; ++i) {\r\n    if (arr[i] - arr[i - 1] !== diff) {\r\n      return false;\r\n    }\r\n  }\r\n  return diff;\r\n}\r\n","import Element from './core.element.js';\r\nimport {_alignPixel, _measureText, renderText, clipArea, unclipArea} from '../helpers/helpers.canvas.js';\r\nimport {callback as call, each, finiteOrDefault, isArray, isFinite, isNullOrUndef, isObject, valueOrDefault} from '../helpers/helpers.core.js';\r\nimport {toDegrees, toRadians, _int16Range, _limitValue, HALF_PI} from '../helpers/helpers.math.js';\r\nimport {_alignStartEnd, _toLeftRightCenter} from '../helpers/helpers.extras.js';\r\nimport {createContext, toFont, toPadding, _addGrace} from '../helpers/helpers.options.js';\r\nimport {autoSkip} from './core.scale.autoskip.js';\r\n\r\nconst reverseAlign = (align) => align === 'left' ? 'right' : align === 'right' ? 'left' : align;\r\nconst offsetFromEdge = (scale, edge, offset) => edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;\r\nconst getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);\r\n\r\n/**\r\n * @typedef { import('../types/index.js').Chart } Chart\r\n * @typedef {{value:number | string, label?:string, major?:boolean, $context?:any}} Tick\r\n */\r\n\r\n/**\r\n * Returns a new array containing numItems from arr\r\n * @param {any[]} arr\r\n * @param {number} numItems\r\n */\r\nfunction sample(arr, numItems) {\r\n  const result = [];\r\n  const increment = arr.length / numItems;\r\n  const len = arr.length;\r\n  let i = 0;\r\n\r\n  for (; i < len; i += increment) {\r\n    result.push(arr[Math.floor(i)]);\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * @param {Scale} scale\r\n * @param {number} index\r\n * @param {boolean} offsetGridLines\r\n */\r\nfunction getPixelForGridLine(scale, index, offsetGridLines) {\r\n  const length = scale.ticks.length;\r\n  const validIndex = Math.min(index, length - 1);\r\n  const start = scale._startPixel;\r\n  const end = scale._endPixel;\r\n  const epsilon = 1e-6; // 1e-6 is margin in pixels for accumulated error.\r\n  let lineValue = scale.getPixelForTick(validIndex);\r\n  let offset;\r\n\r\n  if (offsetGridLines) {\r\n    if (length === 1) {\r\n      offset = Math.max(lineValue - start, end - lineValue);\r\n    } else if (index === 0) {\r\n      offset = (scale.getPixelForTick(1) - lineValue) / 2;\r\n    } else {\r\n      offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\r\n    }\r\n    lineValue += validIndex < index ? offset : -offset;\r\n\r\n    // Return undefined if the pixel is out of the range\r\n    if (lineValue < start - epsilon || lineValue > end + epsilon) {\r\n      return;\r\n    }\r\n  }\r\n  return lineValue;\r\n}\r\n\r\n/**\r\n * @param {object} caches\r\n * @param {number} length\r\n */\r\nfunction garbageCollect(caches, length) {\r\n  each(caches, (cache) => {\r\n    const gc = cache.gc;\r\n    const gcLen = gc.length / 2;\r\n    let i;\r\n    if (gcLen > length) {\r\n      for (i = 0; i < gcLen; ++i) {\r\n        delete cache.data[gc[i]];\r\n      }\r\n      gc.splice(0, gcLen);\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * @param {object} options\r\n */\r\nfunction getTickMarkLength(options) {\r\n  return options.drawTicks ? options.tickLength : 0;\r\n}\r\n\r\n/**\r\n * @param {object} options\r\n */\r\nfunction getTitleHeight(options, fallback) {\r\n  if (!options.display) {\r\n    return 0;\r\n  }\r\n\r\n  const font = toFont(options.font, fallback);\r\n  const padding = toPadding(options.padding);\r\n  const lines = isArray(options.text) ? options.text.length : 1;\r\n\r\n  return (lines * font.lineHeight) + padding.height;\r\n}\r\n\r\nfunction createScaleContext(parent, scale) {\r\n  return createContext(parent, {\r\n    scale,\r\n    type: 'scale'\r\n  });\r\n}\r\n\r\nfunction createTickContext(parent, index, tick) {\r\n  return createContext(parent, {\r\n    tick,\r\n    index,\r\n    type: 'tick'\r\n  });\r\n}\r\n\r\nfunction titleAlign(align, position, reverse) {\r\n  /** @type {CanvasTextAlign} */\r\n  let ret = _toLeftRightCenter(align);\r\n  if ((reverse && position !== 'right') || (!reverse && position === 'right')) {\r\n    ret = reverseAlign(ret);\r\n  }\r\n  return ret;\r\n}\r\n\r\nfunction titleArgs(scale, offset, position, align) {\r\n  const {top, left, bottom, right, chart} = scale;\r\n  const {chartArea, scales} = chart;\r\n  let rotation = 0;\r\n  let maxWidth, titleX, titleY;\r\n  const height = bottom - top;\r\n  const width = right - left;\r\n\r\n  if (scale.isHorizontal()) {\r\n    titleX = _alignStartEnd(align, left, right);\r\n\r\n    if (isObject(position)) {\r\n      const positionAxisID = Object.keys(position)[0];\r\n      const value = position[positionAxisID];\r\n      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\r\n    } else if (position === 'center') {\r\n      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\r\n    } else {\r\n      titleY = offsetFromEdge(scale, position, offset);\r\n    }\r\n    maxWidth = right - left;\r\n  } else {\r\n    if (isObject(position)) {\r\n      const positionAxisID = Object.keys(position)[0];\r\n      const value = position[positionAxisID];\r\n      titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;\r\n    } else if (position === 'center') {\r\n      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\r\n    } else {\r\n      titleX = offsetFromEdge(scale, position, offset);\r\n    }\r\n    titleY = _alignStartEnd(align, bottom, top);\r\n    rotation = position === 'left' ? -HALF_PI : HALF_PI;\r\n  }\r\n  return {titleX, titleY, maxWidth, rotation};\r\n}\r\n\r\nexport default class Scale extends Element {\r\n\r\n  // eslint-disable-next-line max-statements\r\n  constructor(cfg) {\r\n    super();\r\n\r\n    /** @type {string} */\r\n    this.id = cfg.id;\r\n    /** @type {string} */\r\n    this.type = cfg.type;\r\n    /** @type {any} */\r\n    this.options = undefined;\r\n    /** @type {CanvasRenderingContext2D} */\r\n    this.ctx = cfg.ctx;\r\n    /** @type {Chart} */\r\n    this.chart = cfg.chart;\r\n\r\n    // implements box\r\n    /** @type {number} */\r\n    this.top = undefined;\r\n    /** @type {number} */\r\n    this.bottom = undefined;\r\n    /** @type {number} */\r\n    this.left = undefined;\r\n    /** @type {number} */\r\n    this.right = undefined;\r\n    /** @type {number} */\r\n    this.width = undefined;\r\n    /** @type {number} */\r\n    this.height = undefined;\r\n    this._margins = {\r\n      left: 0,\r\n      right: 0,\r\n      top: 0,\r\n      bottom: 0\r\n    };\r\n    /** @type {number} */\r\n    this.maxWidth = undefined;\r\n    /** @type {number} */\r\n    this.maxHeight = undefined;\r\n    /** @type {number} */\r\n    this.paddingTop = undefined;\r\n    /** @type {number} */\r\n    this.paddingBottom = undefined;\r\n    /** @type {number} */\r\n    this.paddingLeft = undefined;\r\n    /** @type {number} */\r\n    this.paddingRight = undefined;\r\n\r\n    // scale-specific properties\r\n    /** @type {string=} */\r\n    this.axis = undefined;\r\n    /** @type {number=} */\r\n    this.labelRotation = undefined;\r\n    this.min = undefined;\r\n    this.max = undefined;\r\n    this._range = undefined;\r\n    /** @type {Tick[]} */\r\n    this.ticks = [];\r\n    /** @type {object[]|null} */\r\n    this._gridLineItems = null;\r\n    /** @type {object[]|null} */\r\n    this._labelItems = null;\r\n    /** @type {object|null} */\r\n    this._labelSizes = null;\r\n    this._length = 0;\r\n    this._maxLength = 0;\r\n    this._longestTextCache = {};\r\n    /** @type {number} */\r\n    this._startPixel = undefined;\r\n    /** @type {number} */\r\n    this._endPixel = undefined;\r\n    this._reversePixels = false;\r\n    this._userMax = undefined;\r\n    this._userMin = undefined;\r\n    this._suggestedMax = undefined;\r\n    this._suggestedMin = undefined;\r\n    this._ticksLength = 0;\r\n    this._borderValue = 0;\r\n    this._cache = {};\r\n    this._dataLimitsCached = false;\r\n    this.$context = undefined;\r\n  }\r\n\r\n  /**\r\n\t * @param {any} options\r\n\t * @since 3.0\r\n\t */\r\n  init(options) {\r\n    this.options = options.setContext(this.getContext());\r\n\r\n    this.axis = options.axis;\r\n\r\n    // parse min/max value, so we can properly determine min/max for other scales\r\n    this._userMin = this.parse(options.min);\r\n    this._userMax = this.parse(options.max);\r\n    this._suggestedMin = this.parse(options.suggestedMin);\r\n    this._suggestedMax = this.parse(options.suggestedMax);\r\n  }\r\n\r\n  /**\r\n\t * Parse a supported input value to internal representation.\r\n\t * @param {*} raw\r\n\t * @param {number} [index]\r\n\t * @since 3.0\r\n\t */\r\n  parse(raw, index) { // eslint-disable-line no-unused-vars\r\n    return raw;\r\n  }\r\n\r\n  /**\r\n\t * @return {{min: number, max: number, minDefined: boolean, maxDefined: boolean}}\r\n\t * @protected\r\n\t * @since 3.0\r\n\t */\r\n  getUserBounds() {\r\n    let {_userMin, _userMax, _suggestedMin, _suggestedMax} = this;\r\n    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);\r\n    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);\r\n    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);\r\n    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);\r\n    return {\r\n      min: finiteOrDefault(_userMin, _suggestedMin),\r\n      max: finiteOrDefault(_userMax, _suggestedMax),\r\n      minDefined: isFinite(_userMin),\r\n      maxDefined: isFinite(_userMax)\r\n    };\r\n  }\r\n\r\n  /**\r\n\t * @param {boolean} canStack\r\n\t * @return {{min: number, max: number}}\r\n\t * @protected\r\n\t * @since 3.0\r\n\t */\r\n  getMinMax(canStack) {\r\n    // eslint-disable-next-line prefer-const\r\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\r\n    let range;\r\n\r\n    if (minDefined && maxDefined) {\r\n      return {min, max};\r\n    }\r\n\r\n    const metas = this.getMatchingVisibleMetas();\r\n    for (let i = 0, ilen = metas.length; i < ilen; ++i) {\r\n      range = metas[i].controller.getMinMax(this, canStack);\r\n      if (!minDefined) {\r\n        min = Math.min(min, range.min);\r\n      }\r\n      if (!maxDefined) {\r\n        max = Math.max(max, range.max);\r\n      }\r\n    }\r\n\r\n    // Make sure min <= max when only min or max is defined by user and the data is outside that range\r\n    min = maxDefined && min > max ? max : min;\r\n    max = minDefined && min > max ? min : max;\r\n\r\n    return {\r\n      min: finiteOrDefault(min, finiteOrDefault(max, min)),\r\n      max: finiteOrDefault(max, finiteOrDefault(min, max))\r\n    };\r\n  }\r\n\r\n  /**\r\n\t * Get the padding needed for the scale\r\n\t * @return {{top: number, left: number, bottom: number, right: number}} the necessary padding\r\n\t * @private\r\n\t */\r\n  getPadding() {\r\n    return {\r\n      left: this.paddingLeft || 0,\r\n      top: this.paddingTop || 0,\r\n      right: this.paddingRight || 0,\r\n      bottom: this.paddingBottom || 0\r\n    };\r\n  }\r\n\r\n  /**\r\n\t * Returns the scale tick objects\r\n\t * @return {Tick[]}\r\n\t * @since 2.7\r\n\t */\r\n  getTicks() {\r\n    return this.ticks;\r\n  }\r\n\r\n  /**\r\n\t * @return {string[]}\r\n\t */\r\n  getLabels() {\r\n    const data = this.chart.data;\r\n    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\r\n  }\r\n\r\n  /**\r\n   * @return {import('../types.js').LabelItem[]}\r\n   */\r\n  getLabelItems(chartArea = this.chart.chartArea) {\r\n    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));\r\n    return items;\r\n  }\r\n\r\n  // When a new layout is created, reset the data limits cache\r\n  beforeLayout() {\r\n    this._cache = {};\r\n    this._dataLimitsCached = false;\r\n  }\r\n\r\n  // These methods are ordered by lifecycle. Utilities then follow.\r\n  // Any function defined here is inherited by all scale types.\r\n  // Any function can be extended by the scale type\r\n\r\n  beforeUpdate() {\r\n    call(this.options.beforeUpdate, [this]);\r\n  }\r\n\r\n  /**\r\n\t * @param {number} maxWidth - the max width in pixels\r\n\t * @param {number} maxHeight - the max height in pixels\r\n\t * @param {{top: number, left: number, bottom: number, right: number}} margins - the space between the edge of the other scales and edge of the chart\r\n\t *   This space comes from two sources:\r\n\t *     - padding - space that's required to show the labels at the edges of the scale\r\n\t *     - thickness of scales or legends in another orientation\r\n\t */\r\n  update(maxWidth, maxHeight, margins) {\r\n    const {beginAtZero, grace, ticks: tickOpts} = this.options;\r\n    const sampleSize = tickOpts.sampleSize;\r\n\r\n    // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\r\n    this.beforeUpdate();\r\n\r\n    // Absorb the master measurements\r\n    this.maxWidth = maxWidth;\r\n    this.maxHeight = maxHeight;\r\n    this._margins = margins = Object.assign({\r\n      left: 0,\r\n      right: 0,\r\n      top: 0,\r\n      bottom: 0\r\n    }, margins);\r\n\r\n    this.ticks = null;\r\n    this._labelSizes = null;\r\n    this._gridLineItems = null;\r\n    this._labelItems = null;\r\n\r\n    // Dimensions\r\n    this.beforeSetDimensions();\r\n    this.setDimensions();\r\n    this.afterSetDimensions();\r\n\r\n    this._maxLength = this.isHorizontal()\r\n      ? this.width + margins.left + margins.right\r\n      : this.height + margins.top + margins.bottom;\r\n\r\n    // Data min/max\r\n    if (!this._dataLimitsCached) {\r\n      this.beforeDataLimits();\r\n      this.determineDataLimits();\r\n      this.afterDataLimits();\r\n      this._range = _addGrace(this, grace, beginAtZero);\r\n      this._dataLimitsCached = true;\r\n    }\r\n\r\n    this.beforeBuildTicks();\r\n\r\n    this.ticks = this.buildTicks() || [];\r\n\r\n    // Allow modification of ticks in callback.\r\n    this.afterBuildTicks();\r\n\r\n    // Compute tick rotation and fit using a sampled subset of labels\r\n    // We generally don't need to compute the size of every single label for determining scale size\r\n    const samplingEnabled = sampleSize < this.ticks.length;\r\n    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);\r\n\r\n    // configure is called twice, once here, once from core.controller.updateLayout.\r\n    // Here we haven't been positioned yet, but dimensions are correct.\r\n    // Variables set in configure are needed for calculateLabelRotation, and\r\n    // it's ok that coordinates are not correct there, only dimensions matter.\r\n    this.configure();\r\n\r\n    // Tick Rotation\r\n    this.beforeCalculateLabelRotation();\r\n    this.calculateLabelRotation(); // Preconditions: number of ticks and sizes of largest labels must be calculated beforehand\r\n    this.afterCalculateLabelRotation();\r\n\r\n    // Auto-skip\r\n    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {\r\n      this.ticks = autoSkip(this, this.ticks);\r\n      this._labelSizes = null;\r\n      this.afterAutoSkip();\r\n    }\r\n\r\n    if (samplingEnabled) {\r\n      // Generate labels using all non-skipped ticks\r\n      this._convertTicksToLabels(this.ticks);\r\n    }\r\n\r\n    this.beforeFit();\r\n    this.fit(); // Preconditions: label rotation and label sizes must be calculated beforehand\r\n    this.afterFit();\r\n\r\n    // IMPORTANT: after this point, we consider that `this.ticks` will NEVER change!\r\n\r\n    this.afterUpdate();\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  configure() {\r\n    let reversePixels = this.options.reverse;\r\n    let startPixel, endPixel;\r\n\r\n    if (this.isHorizontal()) {\r\n      startPixel = this.left;\r\n      endPixel = this.right;\r\n    } else {\r\n      startPixel = this.top;\r\n      endPixel = this.bottom;\r\n      // by default vertical scales are from bottom to top, so pixels are reversed\r\n      reversePixels = !reversePixels;\r\n    }\r\n    this._startPixel = startPixel;\r\n    this._endPixel = endPixel;\r\n    this._reversePixels = reversePixels;\r\n    this._length = endPixel - startPixel;\r\n    this._alignToPixels = this.options.alignToPixels;\r\n  }\r\n\r\n  afterUpdate() {\r\n    call(this.options.afterUpdate, [this]);\r\n  }\r\n\r\n  //\r\n\r\n  beforeSetDimensions() {\r\n    call(this.options.beforeSetDimensions, [this]);\r\n  }\r\n  setDimensions() {\r\n    // Set the unconstrained dimension before label rotation\r\n    if (this.isHorizontal()) {\r\n      // Reset position before calculating rotation\r\n      this.width = this.maxWidth;\r\n      this.left = 0;\r\n      this.right = this.width;\r\n    } else {\r\n      this.height = this.maxHeight;\r\n\r\n      // Reset position before calculating rotation\r\n      this.top = 0;\r\n      this.bottom = this.height;\r\n    }\r\n\r\n    // Reset padding\r\n    this.paddingLeft = 0;\r\n    this.paddingTop = 0;\r\n    this.paddingRight = 0;\r\n    this.paddingBottom = 0;\r\n  }\r\n  afterSetDimensions() {\r\n    call(this.options.afterSetDimensions, [this]);\r\n  }\r\n\r\n  _callHooks(name) {\r\n    this.chart.notifyPlugins(name, this.getContext());\r\n    call(this.options[name], [this]);\r\n  }\r\n\r\n  // Data limits\r\n  beforeDataLimits() {\r\n    this._callHooks('beforeDataLimits');\r\n  }\r\n  determineDataLimits() {}\r\n  afterDataLimits() {\r\n    this._callHooks('afterDataLimits');\r\n  }\r\n\r\n  //\r\n  beforeBuildTicks() {\r\n    this._callHooks('beforeBuildTicks');\r\n  }\r\n  /**\r\n\t * @return {object[]} the ticks\r\n\t */\r\n  buildTicks() {\r\n    return [];\r\n  }\r\n  afterBuildTicks() {\r\n    this._callHooks('afterBuildTicks');\r\n  }\r\n\r\n  beforeTickToLabelConversion() {\r\n    call(this.options.beforeTickToLabelConversion, [this]);\r\n  }\r\n  /**\r\n\t * Convert ticks to label strings\r\n\t * @param {Tick[]} ticks\r\n\t */\r\n  generateTickLabels(ticks) {\r\n    const tickOpts = this.options.ticks;\r\n    let i, ilen, tick;\r\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\r\n      tick = ticks[i];\r\n      tick.label = call(tickOpts.callback, [tick.value, i, ticks], this);\r\n    }\r\n  }\r\n  afterTickToLabelConversion() {\r\n    call(this.options.afterTickToLabelConversion, [this]);\r\n  }\r\n\r\n  //\r\n\r\n  beforeCalculateLabelRotation() {\r\n    call(this.options.beforeCalculateLabelRotation, [this]);\r\n  }\r\n  calculateLabelRotation() {\r\n    const options = this.options;\r\n    const tickOpts = options.ticks;\r\n    const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);\r\n    const minRotation = tickOpts.minRotation || 0;\r\n    const maxRotation = tickOpts.maxRotation;\r\n    let labelRotation = minRotation;\r\n    let tickWidth, maxHeight, maxLabelDiagonal;\r\n\r\n    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {\r\n      this.labelRotation = minRotation;\r\n      return;\r\n    }\r\n\r\n    const labelSizes = this._getLabelSizes();\r\n    const maxLabelWidth = labelSizes.widest.width;\r\n    const maxLabelHeight = labelSizes.highest.height;\r\n\r\n    // Estimate the width of each grid based on the canvas width, the maximum\r\n    // label width and the number of tick intervals\r\n    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);\r\n    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);\r\n\r\n    // Allow 3 pixels x2 padding either side for label readability\r\n    if (maxLabelWidth + 6 > tickWidth) {\r\n      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\r\n      maxHeight = this.maxHeight - getTickMarkLength(options.grid)\r\n\t\t\t\t- tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);\r\n      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\r\n      labelRotation = toDegrees(Math.min(\r\n        Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)),\r\n        Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))\r\n      ));\r\n      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\r\n    }\r\n\r\n    this.labelRotation = labelRotation;\r\n  }\r\n  afterCalculateLabelRotation() {\r\n    call(this.options.afterCalculateLabelRotation, [this]);\r\n  }\r\n  afterAutoSkip() {}\r\n\r\n  //\r\n\r\n  beforeFit() {\r\n    call(this.options.beforeFit, [this]);\r\n  }\r\n  fit() {\r\n    // Reset\r\n    const minSize = {\r\n      width: 0,\r\n      height: 0\r\n    };\r\n\r\n    const {chart, options: {ticks: tickOpts, title: titleOpts, grid: gridOpts}} = this;\r\n    const display = this._isVisible();\r\n    const isHorizontal = this.isHorizontal();\r\n\r\n    if (display) {\r\n      const titleHeight = getTitleHeight(titleOpts, chart.options.font);\r\n      if (isHorizontal) {\r\n        minSize.width = this.maxWidth;\r\n        minSize.height = getTickMarkLength(gridOpts) + titleHeight;\r\n      } else {\r\n        minSize.height = this.maxHeight; // fill all the height\r\n        minSize.width = getTickMarkLength(gridOpts) + titleHeight;\r\n      }\r\n\r\n      // Don't bother fitting the ticks if we are not showing the labels\r\n      if (tickOpts.display && this.ticks.length) {\r\n        const {first, last, widest, highest} = this._getLabelSizes();\r\n        const tickPadding = tickOpts.padding * 2;\r\n        const angleRadians = toRadians(this.labelRotation);\r\n        const cos = Math.cos(angleRadians);\r\n        const sin = Math.sin(angleRadians);\r\n\r\n        if (isHorizontal) {\r\n        // A horizontal axis is more constrained by the height.\r\n          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\r\n          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);\r\n        } else {\r\n        // A vertical axis is more constrained by the width. Labels are the\r\n        // dominant factor here, so get that length first and account for padding\r\n          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\r\n\r\n          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);\r\n        }\r\n        this._calculatePadding(first, last, sin, cos);\r\n      }\r\n    }\r\n\r\n    this._handleMargins();\r\n\r\n    if (isHorizontal) {\r\n      this.width = this._length = chart.width - this._margins.left - this._margins.right;\r\n      this.height = minSize.height;\r\n    } else {\r\n      this.width = minSize.width;\r\n      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;\r\n    }\r\n  }\r\n\r\n  _calculatePadding(first, last, sin, cos) {\r\n    const {ticks: {align, padding}, position} = this.options;\r\n    const isRotated = this.labelRotation !== 0;\r\n    const labelsBelowTicks = position !== 'top' && this.axis === 'x';\r\n\r\n    if (this.isHorizontal()) {\r\n      const offsetLeft = this.getPixelForTick(0) - this.left;\r\n      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);\r\n      let paddingLeft = 0;\r\n      let paddingRight = 0;\r\n\r\n      // Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned\r\n      // which means that the right padding is dominated by the font height\r\n      if (isRotated) {\r\n        if (labelsBelowTicks) {\r\n          paddingLeft = cos * first.width;\r\n          paddingRight = sin * last.height;\r\n        } else {\r\n          paddingLeft = sin * first.height;\r\n          paddingRight = cos * last.width;\r\n        }\r\n      } else if (align === 'start') {\r\n        paddingRight = last.width;\r\n      } else if (align === 'end') {\r\n        paddingLeft = first.width;\r\n      } else if (align !== 'inner') {\r\n        paddingLeft = first.width / 2;\r\n        paddingRight = last.width / 2;\r\n      }\r\n\r\n      // Adjust padding taking into account changes in offsets\r\n      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);\r\n      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);\r\n    } else {\r\n      let paddingTop = last.height / 2;\r\n      let paddingBottom = first.height / 2;\r\n\r\n      if (align === 'start') {\r\n        paddingTop = 0;\r\n        paddingBottom = first.height;\r\n      } else if (align === 'end') {\r\n        paddingTop = last.height;\r\n        paddingBottom = 0;\r\n      }\r\n\r\n      this.paddingTop = paddingTop + padding;\r\n      this.paddingBottom = paddingBottom + padding;\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * Handle margins and padding interactions\r\n\t * @private\r\n\t */\r\n  _handleMargins() {\r\n    if (this._margins) {\r\n      this._margins.left = Math.max(this.paddingLeft, this._margins.left);\r\n      this._margins.top = Math.max(this.paddingTop, this._margins.top);\r\n      this._margins.right = Math.max(this.paddingRight, this._margins.right);\r\n      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\r\n    }\r\n  }\r\n\r\n  afterFit() {\r\n    call(this.options.afterFit, [this]);\r\n  }\r\n\r\n  // Shared Methods\r\n  /**\r\n\t * @return {boolean}\r\n\t */\r\n  isHorizontal() {\r\n    const {axis, position} = this.options;\r\n    return position === 'top' || position === 'bottom' || axis === 'x';\r\n  }\r\n  /**\r\n\t * @return {boolean}\r\n\t */\r\n  isFullSize() {\r\n    return this.options.fullSize;\r\n  }\r\n\r\n  /**\r\n\t * @param {Tick[]} ticks\r\n\t * @private\r\n\t */\r\n  _convertTicksToLabels(ticks) {\r\n    this.beforeTickToLabelConversion();\r\n\r\n    this.generateTickLabels(ticks);\r\n\r\n    // Ticks should be skipped when callback returns null or undef, so lets remove those.\r\n    let i, ilen;\r\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\r\n      if (isNullOrUndef(ticks[i].label)) {\r\n        ticks.splice(i, 1);\r\n        ilen--;\r\n        i--;\r\n      }\r\n    }\r\n\r\n    this.afterTickToLabelConversion();\r\n  }\r\n\r\n  /**\r\n\t * @return {{ first: object, last: object, widest: object, highest: object, widths: Array, heights: array }}\r\n\t * @private\r\n\t */\r\n  _getLabelSizes() {\r\n    let labelSizes = this._labelSizes;\r\n\r\n    if (!labelSizes) {\r\n      const sampleSize = this.options.ticks.sampleSize;\r\n      let ticks = this.ticks;\r\n      if (sampleSize < ticks.length) {\r\n        ticks = sample(ticks, sampleSize);\r\n      }\r\n\r\n      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);\r\n    }\r\n\r\n    return labelSizes;\r\n  }\r\n\r\n  /**\r\n\t * Returns {width, height, offset} objects for the first, last, widest, highest tick\r\n\t * labels where offset indicates the anchor point offset from the top in pixels.\r\n\t * @return {{ first: object, last: object, widest: object, highest: object, widths: Array, heights: array }}\r\n\t * @private\r\n\t */\r\n  _computeLabelSizes(ticks, length, maxTicksLimit) {\r\n    const {ctx, _longestTextCache: caches} = this;\r\n    const widths = [];\r\n    const heights = [];\r\n    const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));\r\n    let widestLabelSize = 0;\r\n    let highestLabelSize = 0;\r\n    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\r\n\r\n    for (i = 0; i < length; i += increment) {\r\n      label = ticks[i].label;\r\n      tickFont = this._resolveTickFontOptions(i);\r\n      ctx.font = fontString = tickFont.string;\r\n      cache = caches[fontString] = caches[fontString] || {data: {}, gc: []};\r\n      lineHeight = tickFont.lineHeight;\r\n      width = height = 0;\r\n      // Undefined labels and arrays should not be measured\r\n      if (!isNullOrUndef(label) && !isArray(label)) {\r\n        width = _measureText(ctx, cache.data, cache.gc, width, label);\r\n        height = lineHeight;\r\n      } else if (isArray(label)) {\r\n        // if it is an array let's measure each element\r\n        for (j = 0, jlen = label.length; j < jlen; ++j) {\r\n          nestedLabel = /** @type {string} */ (label[j]);\r\n          // Undefined labels and arrays should not be measured\r\n          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {\r\n            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);\r\n            height += lineHeight;\r\n          }\r\n        }\r\n      }\r\n      widths.push(width);\r\n      heights.push(height);\r\n      widestLabelSize = Math.max(width, widestLabelSize);\r\n      highestLabelSize = Math.max(height, highestLabelSize);\r\n    }\r\n    garbageCollect(caches, length);\r\n\r\n    const widest = widths.indexOf(widestLabelSize);\r\n    const highest = heights.indexOf(highestLabelSize);\r\n\r\n    const valueAt = (idx) => ({width: widths[idx] || 0, height: heights[idx] || 0});\r\n\r\n    return {\r\n      first: valueAt(0),\r\n      last: valueAt(length - 1),\r\n      widest: valueAt(widest),\r\n      highest: valueAt(highest),\r\n      widths,\r\n      heights,\r\n    };\r\n  }\r\n\r\n  /**\r\n\t * Used to get the label to display in the tooltip for the given value\r\n\t * @param {*} value\r\n\t * @return {string}\r\n\t */\r\n  getLabelForValue(value) {\r\n    return value;\r\n  }\r\n\r\n  /**\r\n\t * Returns the location of the given data point. Value can either be an index or a numerical value\r\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\r\n\t * @param {*} value\r\n\t * @param {number} [index]\r\n\t * @return {number}\r\n\t */\r\n  getPixelForValue(value, index) { // eslint-disable-line no-unused-vars\r\n    return NaN;\r\n  }\r\n\r\n  /**\r\n\t * Used to get the data value from a given pixel. This is the inverse of getPixelForValue\r\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\r\n\t * @param {number} pixel\r\n\t * @return {*}\r\n\t */\r\n  getValueForPixel(pixel) {} // eslint-disable-line no-unused-vars\r\n\r\n  /**\r\n\t * Returns the location of the tick at the given index\r\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\r\n\t * @param {number} index\r\n\t * @return {number}\r\n\t */\r\n  getPixelForTick(index) {\r\n    const ticks = this.ticks;\r\n    if (index < 0 || index > ticks.length - 1) {\r\n      return null;\r\n    }\r\n    return this.getPixelForValue(ticks[index].value);\r\n  }\r\n\r\n  /**\r\n\t * Utility for getting the pixel location of a percentage of scale\r\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\r\n\t * @param {number} decimal\r\n\t * @return {number}\r\n\t */\r\n  getPixelForDecimal(decimal) {\r\n    if (this._reversePixels) {\r\n      decimal = 1 - decimal;\r\n    }\r\n\r\n    const pixel = this._startPixel + decimal * this._length;\r\n    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);\r\n  }\r\n\r\n  /**\r\n\t * @param {number} pixel\r\n\t * @return {number}\r\n\t */\r\n  getDecimalForPixel(pixel) {\r\n    const decimal = (pixel - this._startPixel) / this._length;\r\n    return this._reversePixels ? 1 - decimal : decimal;\r\n  }\r\n\r\n  /**\r\n\t * Returns the pixel for the minimum chart value\r\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\r\n\t * @return {number}\r\n\t */\r\n  getBasePixel() {\r\n    return this.getPixelForValue(this.getBaseValue());\r\n  }\r\n\r\n  /**\r\n\t * @return {number}\r\n\t */\r\n  getBaseValue() {\r\n    const {min, max} = this;\r\n\r\n    return min < 0 && max < 0 ? max :\r\n      min > 0 && max > 0 ? min :\r\n      0;\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  getContext(index) {\r\n    const ticks = this.ticks || [];\r\n\r\n    if (index >= 0 && index < ticks.length) {\r\n      const tick = ticks[index];\r\n      return tick.$context ||\r\n\t\t\t\t(tick.$context = createTickContext(this.getContext(), index, tick));\r\n    }\r\n    return this.$context ||\r\n\t\t\t(this.$context = createScaleContext(this.chart.getContext(), this));\r\n  }\r\n\r\n  /**\r\n\t * @return {number}\r\n\t * @private\r\n\t */\r\n  _tickSize() {\r\n    const optionTicks = this.options.ticks;\r\n\r\n    // Calculate space needed by label in axis direction.\r\n    const rot = toRadians(this.labelRotation);\r\n    const cos = Math.abs(Math.cos(rot));\r\n    const sin = Math.abs(Math.sin(rot));\r\n\r\n    const labelSizes = this._getLabelSizes();\r\n    const padding = optionTicks.autoSkipPadding || 0;\r\n    const w = labelSizes ? labelSizes.widest.width + padding : 0;\r\n    const h = labelSizes ? labelSizes.highest.height + padding : 0;\r\n\r\n    // Calculate space needed for 1 tick in axis direction.\r\n    return this.isHorizontal()\r\n      ? h * cos > w * sin ? w / cos : h / sin\r\n      : h * sin < w * cos ? h / cos : w / sin;\r\n  }\r\n\r\n  /**\r\n\t * @return {boolean}\r\n\t * @private\r\n\t */\r\n  _isVisible() {\r\n    const display = this.options.display;\r\n\r\n    if (display !== 'auto') {\r\n      return !!display;\r\n    }\r\n\r\n    return this.getMatchingVisibleMetas().length > 0;\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _computeGridLineItems(chartArea) {\r\n    const axis = this.axis;\r\n    const chart = this.chart;\r\n    const options = this.options;\r\n    const {grid, position, border} = options;\r\n    const offset = grid.offset;\r\n    const isHorizontal = this.isHorizontal();\r\n    const ticks = this.ticks;\r\n    const ticksLength = ticks.length + (offset ? 1 : 0);\r\n    const tl = getTickMarkLength(grid);\r\n    const items = [];\r\n\r\n    const borderOpts = border.setContext(this.getContext());\r\n    const axisWidth = borderOpts.display ? borderOpts.width : 0;\r\n    const axisHalfWidth = axisWidth / 2;\r\n    const alignBorderValue = function(pixel) {\r\n      return _alignPixel(chart, pixel, axisWidth);\r\n    };\r\n    let borderValue, i, lineValue, alignedLineValue;\r\n    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\r\n\r\n    if (position === 'top') {\r\n      borderValue = alignBorderValue(this.bottom);\r\n      ty1 = this.bottom - tl;\r\n      ty2 = borderValue - axisHalfWidth;\r\n      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\r\n      y2 = chartArea.bottom;\r\n    } else if (position === 'bottom') {\r\n      borderValue = alignBorderValue(this.top);\r\n      y1 = chartArea.top;\r\n      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\r\n      ty1 = borderValue + axisHalfWidth;\r\n      ty2 = this.top + tl;\r\n    } else if (position === 'left') {\r\n      borderValue = alignBorderValue(this.right);\r\n      tx1 = this.right - tl;\r\n      tx2 = borderValue - axisHalfWidth;\r\n      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\r\n      x2 = chartArea.right;\r\n    } else if (position === 'right') {\r\n      borderValue = alignBorderValue(this.left);\r\n      x1 = chartArea.left;\r\n      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\r\n      tx1 = borderValue + axisHalfWidth;\r\n      tx2 = this.left + tl;\r\n    } else if (axis === 'x') {\r\n      if (position === 'center') {\r\n        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\r\n      } else if (isObject(position)) {\r\n        const positionAxisID = Object.keys(position)[0];\r\n        const value = position[positionAxisID];\r\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\r\n      }\r\n\r\n      y1 = chartArea.top;\r\n      y2 = chartArea.bottom;\r\n      ty1 = borderValue + axisHalfWidth;\r\n      ty2 = ty1 + tl;\r\n    } else if (axis === 'y') {\r\n      if (position === 'center') {\r\n        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\r\n      } else if (isObject(position)) {\r\n        const positionAxisID = Object.keys(position)[0];\r\n        const value = position[positionAxisID];\r\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\r\n      }\r\n\r\n      tx1 = borderValue - axisHalfWidth;\r\n      tx2 = tx1 - tl;\r\n      x1 = chartArea.left;\r\n      x2 = chartArea.right;\r\n    }\r\n\r\n    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);\r\n    const step = Math.max(1, Math.ceil(ticksLength / limit));\r\n    for (i = 0; i < ticksLength; i += step) {\r\n      const context = this.getContext(i);\r\n      const optsAtIndex = grid.setContext(context);\r\n      const optsAtIndexBorder = border.setContext(context);\r\n\r\n      const lineWidth = optsAtIndex.lineWidth;\r\n      const lineColor = optsAtIndex.color;\r\n      const borderDash = optsAtIndexBorder.dash || [];\r\n      const borderDashOffset = optsAtIndexBorder.dashOffset;\r\n\r\n      const tickWidth = optsAtIndex.tickWidth;\r\n      const tickColor = optsAtIndex.tickColor;\r\n      const tickBorderDash = optsAtIndex.tickBorderDash || [];\r\n      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\r\n\r\n      lineValue = getPixelForGridLine(this, i, offset);\r\n\r\n      // Skip if the pixel is out of the range\r\n      if (lineValue === undefined) {\r\n        continue;\r\n      }\r\n\r\n      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);\r\n\r\n      if (isHorizontal) {\r\n        tx1 = tx2 = x1 = x2 = alignedLineValue;\r\n      } else {\r\n        ty1 = ty2 = y1 = y2 = alignedLineValue;\r\n      }\r\n\r\n      items.push({\r\n        tx1,\r\n        ty1,\r\n        tx2,\r\n        ty2,\r\n        x1,\r\n        y1,\r\n        x2,\r\n        y2,\r\n        width: lineWidth,\r\n        color: lineColor,\r\n        borderDash,\r\n        borderDashOffset,\r\n        tickWidth,\r\n        tickColor,\r\n        tickBorderDash,\r\n        tickBorderDashOffset,\r\n      });\r\n    }\r\n\r\n    this._ticksLength = ticksLength;\r\n    this._borderValue = borderValue;\r\n\r\n    return items;\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _computeLabelItems(chartArea) {\r\n    const axis = this.axis;\r\n    const options = this.options;\r\n    const {position, ticks: optionTicks} = options;\r\n    const isHorizontal = this.isHorizontal();\r\n    const ticks = this.ticks;\r\n    const {align, crossAlign, padding, mirror} = optionTicks;\r\n    const tl = getTickMarkLength(options.grid);\r\n    const tickAndPadding = tl + padding;\r\n    const hTickAndPadding = mirror ? -padding : tickAndPadding;\r\n    const rotation = -toRadians(this.labelRotation);\r\n    const items = [];\r\n    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\r\n    let textBaseline = 'middle';\r\n\r\n    if (position === 'top') {\r\n      y = this.bottom - hTickAndPadding;\r\n      textAlign = this._getXAxisLabelAlignment();\r\n    } else if (position === 'bottom') {\r\n      y = this.top + hTickAndPadding;\r\n      textAlign = this._getXAxisLabelAlignment();\r\n    } else if (position === 'left') {\r\n      const ret = this._getYAxisLabelAlignment(tl);\r\n      textAlign = ret.textAlign;\r\n      x = ret.x;\r\n    } else if (position === 'right') {\r\n      const ret = this._getYAxisLabelAlignment(tl);\r\n      textAlign = ret.textAlign;\r\n      x = ret.x;\r\n    } else if (axis === 'x') {\r\n      if (position === 'center') {\r\n        y = ((chartArea.top + chartArea.bottom) / 2) + tickAndPadding;\r\n      } else if (isObject(position)) {\r\n        const positionAxisID = Object.keys(position)[0];\r\n        const value = position[positionAxisID];\r\n        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\r\n      }\r\n      textAlign = this._getXAxisLabelAlignment();\r\n    } else if (axis === 'y') {\r\n      if (position === 'center') {\r\n        x = ((chartArea.left + chartArea.right) / 2) - tickAndPadding;\r\n      } else if (isObject(position)) {\r\n        const positionAxisID = Object.keys(position)[0];\r\n        const value = position[positionAxisID];\r\n        x = this.chart.scales[positionAxisID].getPixelForValue(value);\r\n      }\r\n      textAlign = this._getYAxisLabelAlignment(tl).textAlign;\r\n    }\r\n\r\n    if (axis === 'y') {\r\n      if (align === 'start') {\r\n        textBaseline = 'top';\r\n      } else if (align === 'end') {\r\n        textBaseline = 'bottom';\r\n      }\r\n    }\r\n\r\n    const labelSizes = this._getLabelSizes();\r\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\r\n      tick = ticks[i];\r\n      label = tick.label;\r\n\r\n      const optsAtIndex = optionTicks.setContext(this.getContext(i));\r\n      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;\r\n      font = this._resolveTickFontOptions(i);\r\n      lineHeight = font.lineHeight;\r\n      lineCount = isArray(label) ? label.length : 1;\r\n      const halfCount = lineCount / 2;\r\n      const color = optsAtIndex.color;\r\n      const strokeColor = optsAtIndex.textStrokeColor;\r\n      const strokeWidth = optsAtIndex.textStrokeWidth;\r\n      let tickTextAlign = textAlign;\r\n\r\n      if (isHorizontal) {\r\n        x = pixel;\r\n\r\n        if (textAlign === 'inner') {\r\n          if (i === ilen - 1) {\r\n            tickTextAlign = !this.options.reverse ? 'right' : 'left';\r\n          } else if (i === 0) {\r\n            tickTextAlign = !this.options.reverse ? 'left' : 'right';\r\n          } else {\r\n            tickTextAlign = 'center';\r\n          }\r\n        }\r\n\r\n        if (position === 'top') {\r\n          if (crossAlign === 'near' || rotation !== 0) {\r\n            textOffset = -lineCount * lineHeight + lineHeight / 2;\r\n          } else if (crossAlign === 'center') {\r\n            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\r\n          } else {\r\n            textOffset = -labelSizes.highest.height + lineHeight / 2;\r\n          }\r\n        } else {\r\n          // eslint-disable-next-line no-lonely-if\r\n          if (crossAlign === 'near' || rotation !== 0) {\r\n            textOffset = lineHeight / 2;\r\n          } else if (crossAlign === 'center') {\r\n            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\r\n          } else {\r\n            textOffset = labelSizes.highest.height - lineCount * lineHeight;\r\n          }\r\n        }\r\n        if (mirror) {\r\n          textOffset *= -1;\r\n        }\r\n        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {\r\n          x += (lineHeight / 2) * Math.sin(rotation);\r\n        }\r\n      } else {\r\n        y = pixel;\r\n        textOffset = (1 - lineCount) * lineHeight / 2;\r\n      }\r\n\r\n      let backdrop;\r\n\r\n      if (optsAtIndex.showLabelBackdrop) {\r\n        const labelPadding = toPadding(optsAtIndex.backdropPadding);\r\n        const height = labelSizes.heights[i];\r\n        const width = labelSizes.widths[i];\r\n\r\n        let top = textOffset - labelPadding.top;\r\n        let left = 0 - labelPadding.left;\r\n\r\n        switch (textBaseline) {\r\n        case 'middle':\r\n          top -= height / 2;\r\n          break;\r\n        case 'bottom':\r\n          top -= height;\r\n          break;\r\n        default:\r\n          break;\r\n        }\r\n\r\n        switch (textAlign) {\r\n        case 'center':\r\n          left -= width / 2;\r\n          break;\r\n        case 'right':\r\n          left -= width;\r\n          break;\r\n        default:\r\n          break;\r\n        }\r\n\r\n        backdrop = {\r\n          left,\r\n          top,\r\n          width: width + labelPadding.width,\r\n          height: height + labelPadding.height,\r\n\r\n          color: optsAtIndex.backdropColor,\r\n        };\r\n      }\r\n\r\n      items.push({\r\n        label,\r\n        font,\r\n        textOffset,\r\n        options: {\r\n          rotation,\r\n          color,\r\n          strokeColor,\r\n          strokeWidth,\r\n          textAlign: tickTextAlign,\r\n          textBaseline,\r\n          translation: [x, y],\r\n          backdrop,\r\n        }\r\n      });\r\n    }\r\n\r\n    return items;\r\n  }\r\n\r\n  _getXAxisLabelAlignment() {\r\n    const {position, ticks} = this.options;\r\n    const rotation = -toRadians(this.labelRotation);\r\n\r\n    if (rotation) {\r\n      return position === 'top' ? 'left' : 'right';\r\n    }\r\n\r\n    let align = 'center';\r\n\r\n    if (ticks.align === 'start') {\r\n      align = 'left';\r\n    } else if (ticks.align === 'end') {\r\n      align = 'right';\r\n    } else if (ticks.align === 'inner') {\r\n      align = 'inner';\r\n    }\r\n\r\n    return align;\r\n  }\r\n\r\n  _getYAxisLabelAlignment(tl) {\r\n    const {position, ticks: {crossAlign, mirror, padding}} = this.options;\r\n    const labelSizes = this._getLabelSizes();\r\n    const tickAndPadding = tl + padding;\r\n    const widest = labelSizes.widest.width;\r\n\r\n    let textAlign;\r\n    let x;\r\n\r\n    if (position === 'left') {\r\n      if (mirror) {\r\n        x = this.right + padding;\r\n\r\n        if (crossAlign === 'near') {\r\n          textAlign = 'left';\r\n        } else if (crossAlign === 'center') {\r\n          textAlign = 'center';\r\n          x += (widest / 2);\r\n        } else {\r\n          textAlign = 'right';\r\n          x += widest;\r\n        }\r\n      } else {\r\n        x = this.right - tickAndPadding;\r\n\r\n        if (crossAlign === 'near') {\r\n          textAlign = 'right';\r\n        } else if (crossAlign === 'center') {\r\n          textAlign = 'center';\r\n          x -= (widest / 2);\r\n        } else {\r\n          textAlign = 'left';\r\n          x = this.left;\r\n        }\r\n      }\r\n    } else if (position === 'right') {\r\n      if (mirror) {\r\n        x = this.left + padding;\r\n\r\n        if (crossAlign === 'near') {\r\n          textAlign = 'right';\r\n        } else if (crossAlign === 'center') {\r\n          textAlign = 'center';\r\n          x -= (widest / 2);\r\n        } else {\r\n          textAlign = 'left';\r\n          x -= widest;\r\n        }\r\n      } else {\r\n        x = this.left + tickAndPadding;\r\n\r\n        if (crossAlign === 'near') {\r\n          textAlign = 'left';\r\n        } else if (crossAlign === 'center') {\r\n          textAlign = 'center';\r\n          x += widest / 2;\r\n        } else {\r\n          textAlign = 'right';\r\n          x = this.right;\r\n        }\r\n      }\r\n    } else {\r\n      textAlign = 'right';\r\n    }\r\n\r\n    return {textAlign, x};\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _computeLabelArea() {\r\n    if (this.options.ticks.mirror) {\r\n      return;\r\n    }\r\n\r\n    const chart = this.chart;\r\n    const position = this.options.position;\r\n\r\n    if (position === 'left' || position === 'right') {\r\n      return {top: 0, left: this.left, bottom: chart.height, right: this.right};\r\n    } if (position === 'top' || position === 'bottom') {\r\n      return {top: this.top, left: 0, bottom: this.bottom, right: chart.width};\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   */\r\n  drawBackground() {\r\n    const {ctx, options: {backgroundColor}, left, top, width, height} = this;\r\n    if (backgroundColor) {\r\n      ctx.save();\r\n      ctx.fillStyle = backgroundColor;\r\n      ctx.fillRect(left, top, width, height);\r\n      ctx.restore();\r\n    }\r\n  }\r\n\r\n  getLineWidthForValue(value) {\r\n    const grid = this.options.grid;\r\n    if (!this._isVisible() || !grid.display) {\r\n      return 0;\r\n    }\r\n    const ticks = this.ticks;\r\n    const index = ticks.findIndex(t => t.value === value);\r\n    if (index >= 0) {\r\n      const opts = grid.setContext(this.getContext(index));\r\n      return opts.lineWidth;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  drawGrid(chartArea) {\r\n    const grid = this.options.grid;\r\n    const ctx = this.ctx;\r\n    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));\r\n    let i, ilen;\r\n\r\n    const drawLine = (p1, p2, style) => {\r\n      if (!style.width || !style.color) {\r\n        return;\r\n      }\r\n      ctx.save();\r\n      ctx.lineWidth = style.width;\r\n      ctx.strokeStyle = style.color;\r\n      ctx.setLineDash(style.borderDash || []);\r\n      ctx.lineDashOffset = style.borderDashOffset;\r\n\r\n      ctx.beginPath();\r\n      ctx.moveTo(p1.x, p1.y);\r\n      ctx.lineTo(p2.x, p2.y);\r\n      ctx.stroke();\r\n      ctx.restore();\r\n    };\r\n\r\n    if (grid.display) {\r\n      for (i = 0, ilen = items.length; i < ilen; ++i) {\r\n        const item = items[i];\r\n\r\n        if (grid.drawOnChartArea) {\r\n          drawLine(\r\n            {x: item.x1, y: item.y1},\r\n            {x: item.x2, y: item.y2},\r\n            item\r\n          );\r\n        }\r\n\r\n        if (grid.drawTicks) {\r\n          drawLine(\r\n            {x: item.tx1, y: item.ty1},\r\n            {x: item.tx2, y: item.ty2},\r\n            {\r\n              color: item.tickColor,\r\n              width: item.tickWidth,\r\n              borderDash: item.tickBorderDash,\r\n              borderDashOffset: item.tickBorderDashOffset\r\n            }\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  drawBorder() {\r\n    const {chart, ctx, options: {border, grid}} = this;\r\n    const borderOpts = border.setContext(this.getContext());\r\n    const axisWidth = border.display ? borderOpts.width : 0;\r\n    if (!axisWidth) {\r\n      return;\r\n    }\r\n    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;\r\n    const borderValue = this._borderValue;\r\n    let x1, x2, y1, y2;\r\n\r\n    if (this.isHorizontal()) {\r\n      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;\r\n      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;\r\n      y1 = y2 = borderValue;\r\n    } else {\r\n      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;\r\n      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;\r\n      x1 = x2 = borderValue;\r\n    }\r\n    ctx.save();\r\n    ctx.lineWidth = borderOpts.width;\r\n    ctx.strokeStyle = borderOpts.color;\r\n\r\n    ctx.beginPath();\r\n    ctx.moveTo(x1, y1);\r\n    ctx.lineTo(x2, y2);\r\n    ctx.stroke();\r\n\r\n    ctx.restore();\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  drawLabels(chartArea) {\r\n    const optionTicks = this.options.ticks;\r\n\r\n    if (!optionTicks.display) {\r\n      return;\r\n    }\r\n\r\n    const ctx = this.ctx;\r\n\r\n    const area = this._computeLabelArea();\r\n    if (area) {\r\n      clipArea(ctx, area);\r\n    }\r\n\r\n    const items = this.getLabelItems(chartArea);\r\n    for (const item of items) {\r\n      const renderTextOptions = item.options;\r\n      const tickFont = item.font;\r\n      const label = item.label;\r\n      const y = item.textOffset;\r\n      renderText(ctx, label, 0, y, tickFont, renderTextOptions);\r\n    }\r\n\r\n    if (area) {\r\n      unclipArea(ctx);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  drawTitle() {\r\n    const {ctx, options: {position, title, reverse}} = this;\r\n\r\n    if (!title.display) {\r\n      return;\r\n    }\r\n\r\n    const font = toFont(title.font);\r\n    const padding = toPadding(title.padding);\r\n    const align = title.align;\r\n    let offset = font.lineHeight / 2;\r\n\r\n    if (position === 'bottom' || position === 'center' || isObject(position)) {\r\n      offset += padding.bottom;\r\n      if (isArray(title.text)) {\r\n        offset += font.lineHeight * (title.text.length - 1);\r\n      }\r\n    } else {\r\n      offset += padding.top;\r\n    }\r\n\r\n    const {titleX, titleY, maxWidth, rotation} = titleArgs(this, offset, position, align);\r\n\r\n    renderText(ctx, title.text, 0, 0, font, {\r\n      color: title.color,\r\n      maxWidth,\r\n      rotation,\r\n      textAlign: titleAlign(align, position, reverse),\r\n      textBaseline: 'middle',\r\n      translation: [titleX, titleY],\r\n    });\r\n  }\r\n\r\n  draw(chartArea) {\r\n    if (!this._isVisible()) {\r\n      return;\r\n    }\r\n\r\n    this.drawBackground();\r\n    this.drawGrid(chartArea);\r\n    this.drawBorder();\r\n    this.drawTitle();\r\n    this.drawLabels(chartArea);\r\n  }\r\n\r\n  /**\r\n\t * @return {object[]}\r\n\t * @private\r\n\t */\r\n  _layers() {\r\n    const opts = this.options;\r\n    const tz = opts.ticks && opts.ticks.z || 0;\r\n    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);\r\n    const bz = valueOrDefault(opts.border && opts.border.z, 0);\r\n\r\n    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {\r\n      // backward compatibility: draw has been overridden by custom scale\r\n      return [{\r\n        z: tz,\r\n        draw: (chartArea) => {\r\n          this.draw(chartArea);\r\n        }\r\n      }];\r\n    }\r\n\r\n    return [{\r\n      z: gz,\r\n      draw: (chartArea) => {\r\n        this.drawBackground();\r\n        this.drawGrid(chartArea);\r\n        this.drawTitle();\r\n      }\r\n    }, {\r\n      z: bz,\r\n      draw: () => {\r\n        this.drawBorder();\r\n      }\r\n    }, {\r\n      z: tz,\r\n      draw: (chartArea) => {\r\n        this.drawLabels(chartArea);\r\n      }\r\n    }];\r\n  }\r\n\r\n  /**\r\n\t * Returns visible dataset metas that are attached to this scale\r\n\t * @param {string} [type] - if specified, also filter by dataset type\r\n\t * @return {object[]}\r\n\t */\r\n  getMatchingVisibleMetas(type) {\r\n    const metas = this.chart.getSortedVisibleDatasetMetas();\r\n    const axisID = this.axis + 'AxisID';\r\n    const result = [];\r\n    let i, ilen;\r\n\r\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\r\n      const meta = metas[i];\r\n      if (meta[axisID] === this.id && (!type || meta.type === type)) {\r\n        result.push(meta);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n\t * @param {number} index\r\n\t * @return {object}\r\n\t * @protected\r\n \t */\r\n  _resolveTickFontOptions(index) {\r\n    const opts = this.options.ticks.setContext(this.getContext(index));\r\n    return toFont(opts.font);\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   */\r\n  _maxDigits() {\r\n    const fontSize = this._resolveTickFontOptions(0).lineHeight;\r\n    return (this.isHorizontal() ? this.width : this.height) / fontSize;\r\n  }\r\n}\r\n","import {merge} from '../helpers/index.js';\r\nimport defaults, {overrides} from './core.defaults.js';\r\n\r\n/**\r\n * @typedef {{id: string, defaults: any, overrides?: any, defaultRoutes: any}} IChartComponent\r\n */\r\n\r\nexport default class TypedRegistry {\r\n  constructor(type, scope, override) {\r\n    this.type = type;\r\n    this.scope = scope;\r\n    this.override = override;\r\n    this.items = Object.create(null);\r\n  }\r\n\r\n  isForType(type) {\r\n    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\r\n  }\r\n\r\n  /**\r\n\t * @param {IChartComponent} item\r\n\t * @returns {string} The scope where items defaults were registered to.\r\n\t */\r\n  register(item) {\r\n    const proto = Object.getPrototypeOf(item);\r\n    let parentScope;\r\n\r\n    if (isIChartComponent(proto)) {\r\n      // Make sure the parent is registered and note the scope where its defaults are.\r\n      parentScope = this.register(proto);\r\n    }\r\n\r\n    const items = this.items;\r\n    const id = item.id;\r\n    const scope = this.scope + '.' + id;\r\n\r\n    if (!id) {\r\n      throw new Error('class does not have id: ' + item);\r\n    }\r\n\r\n    if (id in items) {\r\n      // already registered\r\n      return scope;\r\n    }\r\n\r\n    items[id] = item;\r\n    registerDefaults(item, scope, parentScope);\r\n    if (this.override) {\r\n      defaults.override(item.id, item.overrides);\r\n    }\r\n\r\n    return scope;\r\n  }\r\n\r\n  /**\r\n\t * @param {string} id\r\n\t * @returns {object?}\r\n\t */\r\n  get(id) {\r\n    return this.items[id];\r\n  }\r\n\r\n  /**\r\n\t * @param {IChartComponent} item\r\n\t */\r\n  unregister(item) {\r\n    const items = this.items;\r\n    const id = item.id;\r\n    const scope = this.scope;\r\n\r\n    if (id in items) {\r\n      delete items[id];\r\n    }\r\n\r\n    if (scope && id in defaults[scope]) {\r\n      delete defaults[scope][id];\r\n      if (this.override) {\r\n        delete overrides[id];\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction registerDefaults(item, scope, parentScope) {\r\n  // Inherit the parent's defaults and keep existing defaults\r\n  const itemDefaults = merge(Object.create(null), [\r\n    parentScope ? defaults.get(parentScope) : {},\r\n    defaults.get(scope),\r\n    item.defaults\r\n  ]);\r\n\r\n  defaults.set(scope, itemDefaults);\r\n\r\n  if (item.defaultRoutes) {\r\n    routeDefaults(scope, item.defaultRoutes);\r\n  }\r\n\r\n  if (item.descriptors) {\r\n    defaults.describe(scope, item.descriptors);\r\n  }\r\n}\r\n\r\nfunction routeDefaults(scope, routes) {\r\n  Object.keys(routes).forEach(property => {\r\n    const propertyParts = property.split('.');\r\n    const sourceName = propertyParts.pop();\r\n    const sourceScope = [scope].concat(propertyParts).join('.');\r\n    const parts = routes[property].split('.');\r\n    const targetName = parts.pop();\r\n    const targetScope = parts.join('.');\r\n    defaults.route(sourceScope, sourceName, targetScope, targetName);\r\n  });\r\n}\r\n\r\nfunction isIChartComponent(proto) {\r\n  return 'id' in proto && 'defaults' in proto;\r\n}\r\n","import DatasetController from './core.datasetController.js';\r\nimport Element from './core.element.js';\r\nimport Scale from './core.scale.js';\r\nimport TypedRegistry from './core.typedRegistry.js';\r\nimport {each, callback as call, _capitalize} from '../helpers/helpers.core.js';\r\n\r\n/**\r\n * Please use the module's default export which provides a singleton instance\r\n * Note: class is exported for typedoc\r\n */\r\nexport class Registry {\r\n  constructor() {\r\n    this.controllers = new TypedRegistry(DatasetController, 'datasets', true);\r\n    this.elements = new TypedRegistry(Element, 'elements');\r\n    this.plugins = new TypedRegistry(Object, 'plugins');\r\n    this.scales = new TypedRegistry(Scale, 'scales');\r\n    // Order is important, Scale has Element in prototype chain,\r\n    // so Scales must be before Elements. Plugins are a fallback, so not listed here.\r\n    this._typedRegistries = [this.controllers, this.scales, this.elements];\r\n  }\r\n\r\n  /**\r\n\t * @param  {...any} args\r\n\t */\r\n  add(...args) {\r\n    this._each('register', args);\r\n  }\r\n\r\n  remove(...args) {\r\n    this._each('unregister', args);\r\n  }\r\n\r\n  /**\r\n\t * @param  {...typeof DatasetController} args\r\n\t */\r\n  addControllers(...args) {\r\n    this._each('register', args, this.controllers);\r\n  }\r\n\r\n  /**\r\n\t * @param  {...typeof Element} args\r\n\t */\r\n  addElements(...args) {\r\n    this._each('register', args, this.elements);\r\n  }\r\n\r\n  /**\r\n\t * @param  {...any} args\r\n\t */\r\n  addPlugins(...args) {\r\n    this._each('register', args, this.plugins);\r\n  }\r\n\r\n  /**\r\n\t * @param  {...typeof Scale} args\r\n\t */\r\n  addScales(...args) {\r\n    this._each('register', args, this.scales);\r\n  }\r\n\r\n  /**\r\n\t * @param {string} id\r\n\t * @returns {typeof DatasetController}\r\n\t */\r\n  getController(id) {\r\n    return this._get(id, this.controllers, 'controller');\r\n  }\r\n\r\n  /**\r\n\t * @param {string} id\r\n\t * @returns {typeof Element}\r\n\t */\r\n  getElement(id) {\r\n    return this._get(id, this.elements, 'element');\r\n  }\r\n\r\n  /**\r\n\t * @param {string} id\r\n\t * @returns {object}\r\n\t */\r\n  getPlugin(id) {\r\n    return this._get(id, this.plugins, 'plugin');\r\n  }\r\n\r\n  /**\r\n\t * @param {string} id\r\n\t * @returns {typeof Scale}\r\n\t */\r\n  getScale(id) {\r\n    return this._get(id, this.scales, 'scale');\r\n  }\r\n\r\n  /**\r\n\t * @param  {...typeof DatasetController} args\r\n\t */\r\n  removeControllers(...args) {\r\n    this._each('unregister', args, this.controllers);\r\n  }\r\n\r\n  /**\r\n\t * @param  {...typeof Element} args\r\n\t */\r\n  removeElements(...args) {\r\n    this._each('unregister', args, this.elements);\r\n  }\r\n\r\n  /**\r\n\t * @param  {...any} args\r\n\t */\r\n  removePlugins(...args) {\r\n    this._each('unregister', args, this.plugins);\r\n  }\r\n\r\n  /**\r\n\t * @param  {...typeof Scale} args\r\n\t */\r\n  removeScales(...args) {\r\n    this._each('unregister', args, this.scales);\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _each(method, args, typedRegistry) {\r\n    [...args].forEach(arg => {\r\n      const reg = typedRegistry || this._getRegistryForType(arg);\r\n      if (typedRegistry || reg.isForType(arg) || (reg === this.plugins && arg.id)) {\r\n        this._exec(method, reg, arg);\r\n      } else {\r\n        // Handle loopable args\r\n        // Use case:\r\n        //  import * as plugins from './plugins.js';\r\n        //  Chart.register(plugins);\r\n        each(arg, item => {\r\n          // If there are mixed types in the loopable, make sure those are\r\n          // registered in correct registry\r\n          // Use case: (treemap exporting controller, elements etc)\r\n          //  import * as treemap from 'chartjs-chart-treemap.js';\r\n          //  Chart.register(treemap);\r\n\r\n          const itemReg = typedRegistry || this._getRegistryForType(item);\r\n          this._exec(method, itemReg, item);\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _exec(method, registry, component) {\r\n    const camelMethod = _capitalize(method);\r\n    call(component['before' + camelMethod], [], component); // beforeRegister / beforeUnregister\r\n    registry[method](component);\r\n    call(component['after' + camelMethod], [], component); // afterRegister / afterUnregister\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _getRegistryForType(type) {\r\n    for (let i = 0; i < this._typedRegistries.length; i++) {\r\n      const reg = this._typedRegistries[i];\r\n      if (reg.isForType(type)) {\r\n        return reg;\r\n      }\r\n    }\r\n    // plugins is the fallback registry\r\n    return this.plugins;\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _get(id, typedRegistry, type) {\r\n    const item = typedRegistry.get(id);\r\n    if (item === undefined) {\r\n      throw new Error('\"' + id + '\" is not a registered ' + type + '.');\r\n    }\r\n    return item;\r\n  }\r\n\r\n}\r\n\r\n// singleton instance\r\nexport default /* #__PURE__ */ new Registry();\r\n","import registry from './core.registry.js';\r\nimport {callback as callCallback, isNullOrUndef, valueOrDefault} from '../helpers/helpers.core.js';\r\n\r\n/**\r\n * @typedef { import('./core.controller.js').default } Chart\r\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\r\n * @typedef { import('../plugins/plugin.tooltip.js').default } Tooltip\r\n */\r\n\r\n/**\r\n * @callback filterCallback\r\n * @param {{plugin: object, options: object}} value\r\n * @param {number} [index]\r\n * @param {array} [array]\r\n * @param {object} [thisArg]\r\n * @return {boolean}\r\n */\r\n\r\n\r\nexport default class PluginService {\r\n  constructor() {\r\n    this._init = [];\r\n  }\r\n\r\n  /**\r\n\t * Calls enabled plugins for `chart` on the specified hook and with the given args.\r\n\t * This method immediately returns as soon as a plugin explicitly returns false. The\r\n\t * returned value can be used, for instance, to interrupt the current action.\r\n\t * @param {Chart} chart - The chart instance for which plugins should be called.\r\n\t * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\r\n\t * @param {object} [args] - Extra arguments to apply to the hook call.\r\n   * @param {filterCallback} [filter] - Filtering function for limiting which plugins are notified\r\n\t * @returns {boolean} false if any of the plugins return false, else returns true.\r\n\t */\r\n  notify(chart, hook, args, filter) {\r\n    if (hook === 'beforeInit') {\r\n      this._init = this._createDescriptors(chart, true);\r\n      this._notify(this._init, chart, 'install');\r\n    }\r\n\r\n    const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);\r\n    const result = this._notify(descriptors, chart, hook, args);\r\n\r\n    if (hook === 'afterDestroy') {\r\n      this._notify(descriptors, chart, 'stop');\r\n      this._notify(this._init, chart, 'uninstall');\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _notify(descriptors, chart, hook, args) {\r\n    args = args || {};\r\n    for (const descriptor of descriptors) {\r\n      const plugin = descriptor.plugin;\r\n      const method = plugin[hook];\r\n      const params = [chart, args, descriptor.options];\r\n      if (callCallback(method, params, plugin) === false && args.cancelable) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  invalidate() {\r\n    // When plugins are registered, there is the possibility of a double\r\n    // invalidate situation. In this case, we only want to invalidate once.\r\n    // If we invalidate multiple times, the `_oldCache` is lost and all of the\r\n    // plugins are restarted without being correctly stopped.\r\n    // See https://github.com/chartjs/Chart.js/issues/8147\r\n    if (!isNullOrUndef(this._cache)) {\r\n      this._oldCache = this._cache;\r\n      this._cache = undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @param {Chart} chart\r\n\t * @private\r\n\t */\r\n  _descriptors(chart) {\r\n    if (this._cache) {\r\n      return this._cache;\r\n    }\r\n\r\n    const descriptors = this._cache = this._createDescriptors(chart);\r\n\r\n    this._notifyStateChanges(chart);\r\n\r\n    return descriptors;\r\n  }\r\n\r\n  _createDescriptors(chart, all) {\r\n    const config = chart && chart.config;\r\n    const options = valueOrDefault(config.options && config.options.plugins, {});\r\n    const plugins = allPlugins(config);\r\n    // options === false => all plugins are disabled\r\n    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\r\n  }\r\n\r\n  /**\r\n\t * @param {Chart} chart\r\n\t * @private\r\n\t */\r\n  _notifyStateChanges(chart) {\r\n    const previousDescriptors = this._oldCache || [];\r\n    const descriptors = this._cache;\r\n    const diff = (a, b) => a.filter(x => !b.some(y => x.plugin.id === y.plugin.id));\r\n    this._notify(diff(previousDescriptors, descriptors), chart, 'stop');\r\n    this._notify(diff(descriptors, previousDescriptors), chart, 'start');\r\n  }\r\n}\r\n\r\n/**\r\n * @param {import('./core.config.js').default} config\r\n */\r\nfunction allPlugins(config) {\r\n  const localIds = {};\r\n  const plugins = [];\r\n  const keys = Object.keys(registry.plugins.items);\r\n  for (let i = 0; i < keys.length; i++) {\r\n    plugins.push(registry.getPlugin(keys[i]));\r\n  }\r\n\r\n  const local = config.plugins || [];\r\n  for (let i = 0; i < local.length; i++) {\r\n    const plugin = local[i];\r\n\r\n    if (plugins.indexOf(plugin) === -1) {\r\n      plugins.push(plugin);\r\n      localIds[plugin.id] = true;\r\n    }\r\n  }\r\n\r\n  return {plugins, localIds};\r\n}\r\n\r\nfunction getOpts(options, all) {\r\n  if (!all && options === false) {\r\n    return null;\r\n  }\r\n  if (options === true) {\r\n    return {};\r\n  }\r\n  return options;\r\n}\r\n\r\nfunction createDescriptors(chart, {plugins, localIds}, options, all) {\r\n  const result = [];\r\n  const context = chart.getContext();\r\n\r\n  for (const plugin of plugins) {\r\n    const id = plugin.id;\r\n    const opts = getOpts(options[id], all);\r\n    if (opts === null) {\r\n      continue;\r\n    }\r\n    result.push({\r\n      plugin,\r\n      options: pluginOpts(chart.config, {plugin, local: localIds[id]}, opts, context)\r\n    });\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction pluginOpts(config, {plugin, local}, opts, context) {\r\n  const keys = config.pluginScopeKeys(plugin);\r\n  const scopes = config.getOptionScopes(opts, keys);\r\n  if (local && plugin.defaults) {\r\n    // make sure plugin defaults are in scopes for local (not registered) plugins\r\n    scopes.push(plugin.defaults);\r\n  }\r\n  return config.createResolver(scopes, context, [''], {\r\n    // These are just defaults that plugins can override\r\n    scriptable: false,\r\n    indexable: false,\r\n    allKeys: true\r\n  });\r\n}\r\n","import defaults, {overrides, descriptors} from './core.defaults.js';\r\nimport {mergeIf, resolveObjectKey, isArray, isFunction, valueOrDefault, isObject} from '../helpers/helpers.core.js';\r\nimport {_attachContext, _createResolver, _descriptors} from '../helpers/helpers.config.js';\r\n\r\nexport function getIndexAxis(type, options) {\r\n  const datasetDefaults = defaults.datasets[type] || {};\r\n  const datasetOptions = (options.datasets || {})[type] || {};\r\n  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';\r\n}\r\n\r\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\r\n  let axis = id;\r\n  if (id === '_index_') {\r\n    axis = indexAxis;\r\n  } else if (id === '_value_') {\r\n    axis = indexAxis === 'x' ? 'y' : 'x';\r\n  }\r\n  return axis;\r\n}\r\n\r\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\r\n  return axis === indexAxis ? '_index_' : '_value_';\r\n}\r\n\r\nfunction idMatchesAxis(id) {\r\n  if (id === 'x' || id === 'y' || id === 'r') {\r\n    return id;\r\n  }\r\n}\r\n\r\nfunction axisFromPosition(position) {\r\n  if (position === 'top' || position === 'bottom') {\r\n    return 'x';\r\n  }\r\n  if (position === 'left' || position === 'right') {\r\n    return 'y';\r\n  }\r\n}\r\n\r\nexport function determineAxis(id, ...scaleOptions) {\r\n  if (idMatchesAxis(id)) {\r\n    return id;\r\n  }\r\n  for (const opts of scaleOptions) {\r\n    const axis = opts.axis\r\n      || axisFromPosition(opts.position)\r\n      || id.length > 1 && idMatchesAxis(id[0].toLowerCase());\r\n    if (axis) {\r\n      return axis;\r\n    }\r\n  }\r\n  throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);\r\n}\r\n\r\nfunction getAxisFromDataset(id, axis, dataset) {\r\n  if (dataset[axis + 'AxisID'] === id) {\r\n    return {axis};\r\n  }\r\n}\r\n\r\nfunction retrieveAxisFromDatasets(id, config) {\r\n  if (config.data && config.data.datasets) {\r\n    const boundDs = config.data.datasets.filter((d) => d.xAxisID === id || d.yAxisID === id);\r\n    if (boundDs.length) {\r\n      return getAxisFromDataset(id, 'x', boundDs[0]) || getAxisFromDataset(id, 'y', boundDs[0]);\r\n    }\r\n  }\r\n  return {};\r\n}\r\n\r\nfunction mergeScaleConfig(config, options) {\r\n  const chartDefaults = overrides[config.type] || {scales: {}};\r\n  const configScales = options.scales || {};\r\n  const chartIndexAxis = getIndexAxis(config.type, options);\r\n  const scales = Object.create(null);\r\n\r\n  // First figure out first scale id's per axis.\r\n  Object.keys(configScales).forEach(id => {\r\n    const scaleConf = configScales[id];\r\n    if (!isObject(scaleConf)) {\r\n      return console.error(`Invalid scale configuration for scale: ${id}`);\r\n    }\r\n    if (scaleConf._proxy) {\r\n      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);\r\n    }\r\n    const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);\r\n    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\r\n    const defaultScaleOptions = chartDefaults.scales || {};\r\n    scales[id] = mergeIf(Object.create(null), [{axis}, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);\r\n  });\r\n\r\n  // Then merge dataset defaults to scale configs\r\n  config.data.datasets.forEach(dataset => {\r\n    const type = dataset.type || config.type;\r\n    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\r\n    const datasetDefaults = overrides[type] || {};\r\n    const defaultScaleOptions = datasetDefaults.scales || {};\r\n    Object.keys(defaultScaleOptions).forEach(defaultID => {\r\n      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\r\n      const id = dataset[axis + 'AxisID'] || axis;\r\n      scales[id] = scales[id] || Object.create(null);\r\n      mergeIf(scales[id], [{axis}, configScales[id], defaultScaleOptions[defaultID]]);\r\n    });\r\n  });\r\n\r\n  // apply scale defaults, if not overridden by dataset defaults\r\n  Object.keys(scales).forEach(key => {\r\n    const scale = scales[key];\r\n    mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);\r\n  });\r\n\r\n  return scales;\r\n}\r\n\r\nfunction initOptions(config) {\r\n  const options = config.options || (config.options = {});\r\n\r\n  options.plugins = valueOrDefault(options.plugins, {});\r\n  options.scales = mergeScaleConfig(config, options);\r\n}\r\n\r\nfunction initData(data) {\r\n  data = data || {};\r\n  data.datasets = data.datasets || [];\r\n  data.labels = data.labels || [];\r\n  return data;\r\n}\r\n\r\nfunction initConfig(config) {\r\n  config = config || {};\r\n  config.data = initData(config.data);\r\n\r\n  initOptions(config);\r\n\r\n  return config;\r\n}\r\n\r\nconst keyCache = new Map();\r\nconst keysCached = new Set();\r\n\r\nfunction cachedKeys(cacheKey, generate) {\r\n  let keys = keyCache.get(cacheKey);\r\n  if (!keys) {\r\n    keys = generate();\r\n    keyCache.set(cacheKey, keys);\r\n    keysCached.add(keys);\r\n  }\r\n  return keys;\r\n}\r\n\r\nconst addIfFound = (set, obj, key) => {\r\n  const opts = resolveObjectKey(obj, key);\r\n  if (opts !== undefined) {\r\n    set.add(opts);\r\n  }\r\n};\r\n\r\nexport default class Config {\r\n  constructor(config) {\r\n    this._config = initConfig(config);\r\n    this._scopeCache = new Map();\r\n    this._resolverCache = new Map();\r\n  }\r\n\r\n  get platform() {\r\n    return this._config.platform;\r\n  }\r\n\r\n  get type() {\r\n    return this._config.type;\r\n  }\r\n\r\n  set type(type) {\r\n    this._config.type = type;\r\n  }\r\n\r\n  get data() {\r\n    return this._config.data;\r\n  }\r\n\r\n  set data(data) {\r\n    this._config.data = initData(data);\r\n  }\r\n\r\n  get options() {\r\n    return this._config.options;\r\n  }\r\n\r\n  set options(options) {\r\n    this._config.options = options;\r\n  }\r\n\r\n  get plugins() {\r\n    return this._config.plugins;\r\n  }\r\n\r\n  update() {\r\n    const config = this._config;\r\n    this.clearCache();\r\n    initOptions(config);\r\n  }\r\n\r\n  clearCache() {\r\n    this._scopeCache.clear();\r\n    this._resolverCache.clear();\r\n  }\r\n\r\n  /**\r\n   * Returns the option scope keys for resolving dataset options.\r\n   * These keys do not include the dataset itself, because it is not under options.\r\n   * @param {string} datasetType\r\n   * @return {string[][]}\r\n   */\r\n  datasetScopeKeys(datasetType) {\r\n    return cachedKeys(datasetType,\r\n      () => [[\r\n        `datasets.${datasetType}`,\r\n        ''\r\n      ]]);\r\n  }\r\n\r\n  /**\r\n   * Returns the option scope keys for resolving dataset animation options.\r\n   * These keys do not include the dataset itself, because it is not under options.\r\n   * @param {string} datasetType\r\n   * @param {string} transition\r\n   * @return {string[][]}\r\n   */\r\n  datasetAnimationScopeKeys(datasetType, transition) {\r\n    return cachedKeys(`${datasetType}.transition.${transition}`,\r\n      () => [\r\n        [\r\n          `datasets.${datasetType}.transitions.${transition}`,\r\n          `transitions.${transition}`,\r\n        ],\r\n        // The following are used for looking up the `animations` and `animation` keys\r\n        [\r\n          `datasets.${datasetType}`,\r\n          ''\r\n        ]\r\n      ]);\r\n  }\r\n\r\n  /**\r\n   * Returns the options scope keys for resolving element options that belong\r\n   * to an dataset. These keys do not include the dataset itself, because it\r\n   * is not under options.\r\n   * @param {string} datasetType\r\n   * @param {string} elementType\r\n   * @return {string[][]}\r\n   */\r\n  datasetElementScopeKeys(datasetType, elementType) {\r\n    return cachedKeys(`${datasetType}-${elementType}`,\r\n      () => [[\r\n        `datasets.${datasetType}.elements.${elementType}`,\r\n        `datasets.${datasetType}`,\r\n        `elements.${elementType}`,\r\n        ''\r\n      ]]);\r\n  }\r\n\r\n  /**\r\n   * Returns the options scope keys for resolving plugin options.\r\n   * @param {{id: string, additionalOptionScopes?: string[]}} plugin\r\n   * @return {string[][]}\r\n   */\r\n  pluginScopeKeys(plugin) {\r\n    const id = plugin.id;\r\n    const type = this.type;\r\n    return cachedKeys(`${type}-plugin-${id}`,\r\n      () => [[\r\n        `plugins.${id}`,\r\n        ...plugin.additionalOptionScopes || [],\r\n      ]]);\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _cachedScopes(mainScope, resetCache) {\r\n    const _scopeCache = this._scopeCache;\r\n    let cache = _scopeCache.get(mainScope);\r\n    if (!cache || resetCache) {\r\n      cache = new Map();\r\n      _scopeCache.set(mainScope, cache);\r\n    }\r\n    return cache;\r\n  }\r\n\r\n  /**\r\n   * Resolves the objects from options and defaults for option value resolution.\r\n   * @param {object} mainScope - The main scope object for options\r\n   * @param {string[][]} keyLists - The arrays of keys in resolution order\r\n   * @param {boolean} [resetCache] - reset the cache for this mainScope\r\n   */\r\n  getOptionScopes(mainScope, keyLists, resetCache) {\r\n    const {options, type} = this;\r\n    const cache = this._cachedScopes(mainScope, resetCache);\r\n    const cached = cache.get(keyLists);\r\n    if (cached) {\r\n      return cached;\r\n    }\r\n\r\n    const scopes = new Set();\r\n\r\n    keyLists.forEach(keys => {\r\n      if (mainScope) {\r\n        scopes.add(mainScope);\r\n        keys.forEach(key => addIfFound(scopes, mainScope, key));\r\n      }\r\n      keys.forEach(key => addIfFound(scopes, options, key));\r\n      keys.forEach(key => addIfFound(scopes, overrides[type] || {}, key));\r\n      keys.forEach(key => addIfFound(scopes, defaults, key));\r\n      keys.forEach(key => addIfFound(scopes, descriptors, key));\r\n    });\r\n\r\n    const array = Array.from(scopes);\r\n    if (array.length === 0) {\r\n      array.push(Object.create(null));\r\n    }\r\n    if (keysCached.has(keyLists)) {\r\n      cache.set(keyLists, array);\r\n    }\r\n    return array;\r\n  }\r\n\r\n  /**\r\n   * Returns the option scopes for resolving chart options\r\n   * @return {object[]}\r\n   */\r\n  chartOptionScopes() {\r\n    const {options, type} = this;\r\n\r\n    return [\r\n      options,\r\n      overrides[type] || {},\r\n      defaults.datasets[type] || {}, // https://github.com/chartjs/Chart.js/issues/8531\r\n      {type},\r\n      defaults,\r\n      descriptors\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * @param {object[]} scopes\r\n   * @param {string[]} names\r\n   * @param {function|object} context\r\n   * @param {string[]} [prefixes]\r\n   * @return {object}\r\n   */\r\n  resolveNamedOptions(scopes, names, context, prefixes = ['']) {\r\n    const result = {$shared: true};\r\n    const {resolver, subPrefixes} = getResolver(this._resolverCache, scopes, prefixes);\r\n    let options = resolver;\r\n    if (needContext(resolver, names)) {\r\n      result.$shared = false;\r\n      context = isFunction(context) ? context() : context;\r\n      // subResolver is passed to scriptable options. It should not resolve to hover options.\r\n      const subResolver = this.createResolver(scopes, context, subPrefixes);\r\n      options = _attachContext(resolver, context, subResolver);\r\n    }\r\n\r\n    for (const prop of names) {\r\n      result[prop] = options[prop];\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * @param {object[]} scopes\r\n   * @param {object} [context]\r\n   * @param {string[]} [prefixes]\r\n   * @param {{scriptable: boolean, indexable: boolean, allKeys?: boolean}} [descriptorDefaults]\r\n   */\r\n  createResolver(scopes, context, prefixes = [''], descriptorDefaults) {\r\n    const {resolver} = getResolver(this._resolverCache, scopes, prefixes);\r\n    return isObject(context)\r\n      ? _attachContext(resolver, context, undefined, descriptorDefaults)\r\n      : resolver;\r\n  }\r\n}\r\n\r\nfunction getResolver(resolverCache, scopes, prefixes) {\r\n  let cache = resolverCache.get(scopes);\r\n  if (!cache) {\r\n    cache = new Map();\r\n    resolverCache.set(scopes, cache);\r\n  }\r\n  const cacheKey = prefixes.join();\r\n  let cached = cache.get(cacheKey);\r\n  if (!cached) {\r\n    const resolver = _createResolver(scopes, prefixes);\r\n    cached = {\r\n      resolver,\r\n      subPrefixes: prefixes.filter(p => !p.toLowerCase().includes('hover'))\r\n    };\r\n    cache.set(cacheKey, cached);\r\n  }\r\n  return cached;\r\n}\r\n\r\nconst hasFunction = value => isObject(value)\r\n  && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction(value[key]), false);\r\n\r\nfunction needContext(proxy, names) {\r\n  const {isScriptable, isIndexable} = _descriptors(proxy);\r\n\r\n  for (const prop of names) {\r\n    const scriptable = isScriptable(prop);\r\n    const indexable = isIndexable(prop);\r\n    const value = (indexable || scriptable) && proxy[prop];\r\n    if ((scriptable && (isFunction(value) || hasFunction(value)))\r\n      || (indexable && isArray(value))) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n","import animator from './core.animator.js';\r\nimport defaults, {overrides} from './core.defaults.js';\r\nimport Interaction from './core.interaction.js';\r\nimport layouts from './core.layouts.js';\r\nimport {_detectPlatform} from '../platform/index.js';\r\nimport PluginService from './core.plugins.js';\r\nimport registry from './core.registry.js';\r\nimport Config, {determineAxis, getIndexAxis} from './core.config.js';\r\nimport {retinaScale, _isDomSupported} from '../helpers/helpers.dom.js';\r\nimport {each, callback as callCallback, uid, valueOrDefault, _elementsEqual, isNullOrUndef, setsEqual, defined, isFunction, _isClickEvent} from '../helpers/helpers.core.js';\r\nimport {clearCanvas, clipArea, createContext, unclipArea, _isPointInArea} from '../helpers/index.js';\r\n// @ts-ignore\r\nimport {version} from '../../package.json';\r\nimport {debounce} from '../helpers/helpers.extras.js';\r\n\r\n/**\r\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\r\n * @typedef { import('../types/index.js').Point } Point\r\n */\r\n\r\nconst KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];\r\nfunction positionIsHorizontal(position, axis) {\r\n  return position === 'top' || position === 'bottom' || (KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x');\r\n}\r\n\r\nfunction compare2Level(l1, l2) {\r\n  return function(a, b) {\r\n    return a[l1] === b[l1]\r\n      ? a[l2] - b[l2]\r\n      : a[l1] - b[l1];\r\n  };\r\n}\r\n\r\nfunction onAnimationsComplete(context) {\r\n  const chart = context.chart;\r\n  const animationOptions = chart.options.animation;\r\n\r\n  chart.notifyPlugins('afterRender');\r\n  callCallback(animationOptions && animationOptions.onComplete, [context], chart);\r\n}\r\n\r\nfunction onAnimationProgress(context) {\r\n  const chart = context.chart;\r\n  const animationOptions = chart.options.animation;\r\n  callCallback(animationOptions && animationOptions.onProgress, [context], chart);\r\n}\r\n\r\n/**\r\n * Chart.js can take a string id of a canvas element, a 2d context, or a canvas element itself.\r\n * Attempt to unwrap the item passed into the chart constructor so that it is a canvas element (if possible).\r\n */\r\nfunction getCanvas(item) {\r\n  if (_isDomSupported() && typeof item === 'string') {\r\n    item = document.getElementById(item);\r\n  } else if (item && item.length) {\r\n    // Support for array based queries (such as jQuery)\r\n    item = item[0];\r\n  }\r\n\r\n  if (item && item.canvas) {\r\n    // Support for any object associated to a canvas (including a context2d)\r\n    item = item.canvas;\r\n  }\r\n  return item;\r\n}\r\n\r\nconst instances = {};\r\nconst getChart = (key) => {\r\n  const canvas = getCanvas(key);\r\n  return Object.values(instances).filter((c) => c.canvas === canvas).pop();\r\n};\r\n\r\nfunction moveNumericKeys(obj, start, move) {\r\n  const keys = Object.keys(obj);\r\n  for (const key of keys) {\r\n    const intKey = +key;\r\n    if (intKey >= start) {\r\n      const value = obj[key];\r\n      delete obj[key];\r\n      if (move > 0 || intKey > start) {\r\n        obj[intKey + move] = value;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @param {ChartEvent} e\r\n * @param {ChartEvent|null} lastEvent\r\n * @param {boolean} inChartArea\r\n * @param {boolean} isClick\r\n * @returns {ChartEvent|null}\r\n */\r\nfunction determineLastEvent(e, lastEvent, inChartArea, isClick) {\r\n  if (!inChartArea || e.type === 'mouseout') {\r\n    return null;\r\n  }\r\n  if (isClick) {\r\n    return lastEvent;\r\n  }\r\n  return e;\r\n}\r\n\r\nfunction getDatasetArea(meta) {\r\n  const {xScale, yScale} = meta;\r\n  if (xScale && yScale) {\r\n    return {\r\n      left: xScale.left,\r\n      right: xScale.right,\r\n      top: yScale.top,\r\n      bottom: yScale.bottom\r\n    };\r\n  }\r\n}\r\n\r\nclass Chart {\r\n\r\n  static defaults = defaults;\r\n  static instances = instances;\r\n  static overrides = overrides;\r\n  static registry = registry;\r\n  static version = version;\r\n  static getChart = getChart;\r\n\r\n  static register(...items) {\r\n    registry.add(...items);\r\n    invalidatePlugins();\r\n  }\r\n\r\n  static unregister(...items) {\r\n    registry.remove(...items);\r\n    invalidatePlugins();\r\n  }\r\n\r\n  // eslint-disable-next-line max-statements\r\n  constructor(item, userConfig) {\r\n    const config = this.config = new Config(userConfig);\r\n    const initialCanvas = getCanvas(item);\r\n    const existingChart = getChart(initialCanvas);\r\n    if (existingChart) {\r\n      throw new Error(\r\n        'Canvas is already in use. Chart with ID \\'' + existingChart.id + '\\'' +\r\n\t\t\t\t' must be destroyed before the canvas with ID \\'' + existingChart.canvas.id + '\\' can be reused.'\r\n      );\r\n    }\r\n\r\n    const options = config.createResolver(config.chartOptionScopes(), this.getContext());\r\n\r\n    this.platform = new (config.platform || _detectPlatform(initialCanvas))();\r\n    this.platform.updateConfig(config);\r\n\r\n    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);\r\n    const canvas = context && context.canvas;\r\n    const height = canvas && canvas.height;\r\n    const width = canvas && canvas.width;\r\n\r\n    this.id = uid();\r\n    this.ctx = context;\r\n    this.canvas = canvas;\r\n    this.width = width;\r\n    this.height = height;\r\n    this._options = options;\r\n    // Store the previously used aspect ratio to determine if a resize\r\n    // is needed during updates. Do this after _options is set since\r\n    // aspectRatio uses a getter\r\n    this._aspectRatio = this.aspectRatio;\r\n    this._layers = [];\r\n    this._metasets = [];\r\n    this._stacks = undefined;\r\n    this.boxes = [];\r\n    this.currentDevicePixelRatio = undefined;\r\n    this.chartArea = undefined;\r\n    this._active = [];\r\n    this._lastEvent = undefined;\r\n    this._listeners = {};\r\n    /** @type {?{attach?: function, detach?: function, resize?: function}} */\r\n    this._responsiveListeners = undefined;\r\n    this._sortedMetasets = [];\r\n    this.scales = {};\r\n    this._plugins = new PluginService();\r\n    this.$proxies = {};\r\n    this._hiddenIndices = {};\r\n    this.attached = false;\r\n    this._animationsDisabled = undefined;\r\n    this.$context = undefined;\r\n    this._doResize = debounce(mode => this.update(mode), options.resizeDelay || 0);\r\n    this._dataChanges = [];\r\n\r\n    // Add the chart instance to the global namespace\r\n    instances[this.id] = this;\r\n\r\n    if (!context || !canvas) {\r\n      // The given item is not a compatible context2d element, let's return before finalizing\r\n      // the chart initialization but after setting basic chart / controller properties that\r\n      // can help to figure out that the chart is not valid (e.g chart.canvas !== null);\r\n      // https://github.com/chartjs/Chart.js/issues/2807\r\n      console.error(\"Failed to create chart: can't acquire context from the given item\");\r\n      return;\r\n    }\r\n\r\n    animator.listen(this, 'complete', onAnimationsComplete);\r\n    animator.listen(this, 'progress', onAnimationProgress);\r\n\r\n    this._initialize();\r\n    if (this.attached) {\r\n      this.update();\r\n    }\r\n  }\r\n\r\n  get aspectRatio() {\r\n    const {options: {aspectRatio, maintainAspectRatio}, width, height, _aspectRatio} = this;\r\n    if (!isNullOrUndef(aspectRatio)) {\r\n      // If aspectRatio is defined in options, use that.\r\n      return aspectRatio;\r\n    }\r\n\r\n    if (maintainAspectRatio && _aspectRatio) {\r\n      // If maintainAspectRatio is truthly and we had previously determined _aspectRatio, use that\r\n      return _aspectRatio;\r\n    }\r\n\r\n    // Calculate\r\n    return height ? width / height : null;\r\n  }\r\n\r\n  get data() {\r\n    return this.config.data;\r\n  }\r\n\r\n  set data(data) {\r\n    this.config.data = data;\r\n  }\r\n\r\n  get options() {\r\n    return this._options;\r\n  }\r\n\r\n  set options(options) {\r\n    this.config.options = options;\r\n  }\r\n\r\n  get registry() {\r\n    return registry;\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _initialize() {\r\n    // Before init plugin notification\r\n    this.notifyPlugins('beforeInit');\r\n\r\n    if (this.options.responsive) {\r\n      this.resize();\r\n    } else {\r\n      retinaScale(this, this.options.devicePixelRatio);\r\n    }\r\n\r\n    this.bindEvents();\r\n\r\n    // After init plugin notification\r\n    this.notifyPlugins('afterInit');\r\n\r\n    return this;\r\n  }\r\n\r\n  clear() {\r\n    clearCanvas(this.canvas, this.ctx);\r\n    return this;\r\n  }\r\n\r\n  stop() {\r\n    animator.stop(this);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n\t * Resize the chart to its container or to explicit dimensions.\r\n\t * @param {number} [width]\r\n\t * @param {number} [height]\r\n\t */\r\n  resize(width, height) {\r\n    if (!animator.running(this)) {\r\n      this._resize(width, height);\r\n    } else {\r\n      this._resizeBeforeDraw = {width, height};\r\n    }\r\n  }\r\n\r\n  _resize(width, height) {\r\n    const options = this.options;\r\n    const canvas = this.canvas;\r\n    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;\r\n    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);\r\n    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();\r\n    const mode = this.width ? 'resize' : 'attach';\r\n\r\n    this.width = newSize.width;\r\n    this.height = newSize.height;\r\n    this._aspectRatio = this.aspectRatio;\r\n    if (!retinaScale(this, newRatio, true)) {\r\n      return;\r\n    }\r\n\r\n    this.notifyPlugins('resize', {size: newSize});\r\n\r\n    callCallback(options.onResize, [this, newSize], this);\r\n\r\n    if (this.attached) {\r\n      if (this._doResize(mode)) {\r\n        // The resize update is delayed, only draw without updating.\r\n        this.render();\r\n      }\r\n    }\r\n  }\r\n\r\n  ensureScalesHaveIDs() {\r\n    const options = this.options;\r\n    const scalesOptions = options.scales || {};\r\n\r\n    each(scalesOptions, (axisOptions, axisID) => {\r\n      axisOptions.id = axisID;\r\n    });\r\n  }\r\n\r\n  /**\r\n\t * Builds a map of scale ID to scale object for future lookup.\r\n\t */\r\n  buildOrUpdateScales() {\r\n    const options = this.options;\r\n    const scaleOpts = options.scales;\r\n    const scales = this.scales;\r\n    const updated = Object.keys(scales).reduce((obj, id) => {\r\n      obj[id] = false;\r\n      return obj;\r\n    }, {});\r\n    let items = [];\r\n\r\n    if (scaleOpts) {\r\n      items = items.concat(\r\n        Object.keys(scaleOpts).map((id) => {\r\n          const scaleOptions = scaleOpts[id];\r\n          const axis = determineAxis(id, scaleOptions);\r\n          const isRadial = axis === 'r';\r\n          const isHorizontal = axis === 'x';\r\n          return {\r\n            options: scaleOptions,\r\n            dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',\r\n            dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'\r\n          };\r\n        })\r\n      );\r\n    }\r\n\r\n    each(items, (item) => {\r\n      const scaleOptions = item.options;\r\n      const id = scaleOptions.id;\r\n      const axis = determineAxis(id, scaleOptions);\r\n      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);\r\n\r\n      if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\r\n        scaleOptions.position = item.dposition;\r\n      }\r\n\r\n      updated[id] = true;\r\n      let scale = null;\r\n      if (id in scales && scales[id].type === scaleType) {\r\n        scale = scales[id];\r\n      } else {\r\n        const scaleClass = registry.getScale(scaleType);\r\n        scale = new scaleClass({\r\n          id,\r\n          type: scaleType,\r\n          ctx: this.ctx,\r\n          chart: this\r\n        });\r\n        scales[scale.id] = scale;\r\n      }\r\n\r\n      scale.init(scaleOptions, options);\r\n    });\r\n    // clear up discarded scales\r\n    each(updated, (hasUpdated, id) => {\r\n      if (!hasUpdated) {\r\n        delete scales[id];\r\n      }\r\n    });\r\n\r\n    each(scales, (scale) => {\r\n      layouts.configure(this, scale, scale.options);\r\n      layouts.addBox(this, scale);\r\n    });\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _updateMetasets() {\r\n    const metasets = this._metasets;\r\n    const numData = this.data.datasets.length;\r\n    const numMeta = metasets.length;\r\n\r\n    metasets.sort((a, b) => a.index - b.index);\r\n    if (numMeta > numData) {\r\n      for (let i = numData; i < numMeta; ++i) {\r\n        this._destroyDatasetMeta(i);\r\n      }\r\n      metasets.splice(numData, numMeta - numData);\r\n    }\r\n    this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _removeUnreferencedMetasets() {\r\n    const {_metasets: metasets, data: {datasets}} = this;\r\n    if (metasets.length > datasets.length) {\r\n      delete this._stacks;\r\n    }\r\n    metasets.forEach((meta, index) => {\r\n      if (datasets.filter(x => x === meta._dataset).length === 0) {\r\n        this._destroyDatasetMeta(index);\r\n      }\r\n    });\r\n  }\r\n\r\n  buildOrUpdateControllers() {\r\n    const newControllers = [];\r\n    const datasets = this.data.datasets;\r\n    let i, ilen;\r\n\r\n    this._removeUnreferencedMetasets();\r\n\r\n    for (i = 0, ilen = datasets.length; i < ilen; i++) {\r\n      const dataset = datasets[i];\r\n      let meta = this.getDatasetMeta(i);\r\n      const type = dataset.type || this.config.type;\r\n\r\n      if (meta.type && meta.type !== type) {\r\n        this._destroyDatasetMeta(i);\r\n        meta = this.getDatasetMeta(i);\r\n      }\r\n      meta.type = type;\r\n      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);\r\n      meta.order = dataset.order || 0;\r\n      meta.index = i;\r\n      meta.label = '' + dataset.label;\r\n      meta.visible = this.isDatasetVisible(i);\r\n\r\n      if (meta.controller) {\r\n        meta.controller.updateIndex(i);\r\n        meta.controller.linkScales();\r\n      } else {\r\n        const ControllerClass = registry.getController(type);\r\n        const {datasetElementType, dataElementType} = defaults.datasets[type];\r\n        Object.assign(ControllerClass, {\r\n          dataElementType: registry.getElement(dataElementType),\r\n          datasetElementType: datasetElementType && registry.getElement(datasetElementType)\r\n        });\r\n        meta.controller = new ControllerClass(this, i);\r\n        newControllers.push(meta.controller);\r\n      }\r\n    }\r\n\r\n    this._updateMetasets();\r\n    return newControllers;\r\n  }\r\n\r\n  /**\r\n\t * Reset the elements of all datasets\r\n\t * @private\r\n\t */\r\n  _resetElements() {\r\n    each(this.data.datasets, (dataset, datasetIndex) => {\r\n      this.getDatasetMeta(datasetIndex).controller.reset();\r\n    }, this);\r\n  }\r\n\r\n  /**\r\n\t* Resets the chart back to its state before the initial animation\r\n\t*/\r\n  reset() {\r\n    this._resetElements();\r\n    this.notifyPlugins('reset');\r\n  }\r\n\r\n  update(mode) {\r\n    const config = this.config;\r\n\r\n    config.update();\r\n    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());\r\n    const animsDisabled = this._animationsDisabled = !options.animation;\r\n\r\n    this._updateScales();\r\n    this._checkEventBindings();\r\n    this._updateHiddenIndices();\r\n\r\n    // plugins options references might have change, let's invalidate the cache\r\n    // https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167\r\n    this._plugins.invalidate();\r\n\r\n    if (this.notifyPlugins('beforeUpdate', {mode, cancelable: true}) === false) {\r\n      return;\r\n    }\r\n\r\n    // Make sure dataset controllers are updated and new controllers are reset\r\n    const newControllers = this.buildOrUpdateControllers();\r\n\r\n    this.notifyPlugins('beforeElementsUpdate');\r\n\r\n    // Make sure all dataset controllers have correct meta data counts\r\n    let minPadding = 0;\r\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {\r\n      const {controller} = this.getDatasetMeta(i);\r\n      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\r\n      // New controllers will be reset after the layout pass, so we only want to modify\r\n      // elements added to new datasets\r\n      controller.buildOrUpdateElements(reset);\r\n      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\r\n    }\r\n    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;\r\n    this._updateLayout(minPadding);\r\n\r\n    // Only reset the controllers if we have animations\r\n    if (!animsDisabled) {\r\n      // Can only reset the new controllers after the scales have been updated\r\n      // Reset is done to get the starting point for the initial animation\r\n      each(newControllers, (controller) => {\r\n        controller.reset();\r\n      });\r\n    }\r\n\r\n    this._updateDatasets(mode);\r\n\r\n    // Do this before render so that any plugins that need final scale updates can use it\r\n    this.notifyPlugins('afterUpdate', {mode});\r\n\r\n    this._layers.sort(compare2Level('z', '_idx'));\r\n\r\n    // Replay last event from before update, or set hover styles on active elements\r\n    const {_active, _lastEvent} = this;\r\n    if (_lastEvent) {\r\n      this._eventHandler(_lastEvent, true);\r\n    } else if (_active.length) {\r\n      this._updateHoverStyles(_active, _active, true);\r\n    }\r\n\r\n    this.render();\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _updateScales() {\r\n    each(this.scales, (scale) => {\r\n      layouts.removeBox(this, scale);\r\n    });\r\n\r\n    this.ensureScalesHaveIDs();\r\n    this.buildOrUpdateScales();\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _checkEventBindings() {\r\n    const options = this.options;\r\n    const existingEvents = new Set(Object.keys(this._listeners));\r\n    const newEvents = new Set(options.events);\r\n\r\n    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {\r\n      // The configured events have changed. Rebind.\r\n      this.unbindEvents();\r\n      this.bindEvents();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _updateHiddenIndices() {\r\n    const {_hiddenIndices} = this;\r\n    const changes = this._getUniformDataChanges() || [];\r\n    for (const {method, start, count} of changes) {\r\n      const move = method === '_removeElements' ? -count : count;\r\n      moveNumericKeys(_hiddenIndices, start, move);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _getUniformDataChanges() {\r\n    const _dataChanges = this._dataChanges;\r\n    if (!_dataChanges || !_dataChanges.length) {\r\n      return;\r\n    }\r\n\r\n    this._dataChanges = [];\r\n    const datasetCount = this.data.datasets.length;\r\n    const makeSet = (idx) => new Set(\r\n      _dataChanges\r\n        .filter(c => c[0] === idx)\r\n        .map((c, i) => i + ',' + c.splice(1).join(','))\r\n    );\r\n\r\n    const changeSet = makeSet(0);\r\n    for (let i = 1; i < datasetCount; i++) {\r\n      if (!setsEqual(changeSet, makeSet(i))) {\r\n        return;\r\n      }\r\n    }\r\n    return Array.from(changeSet)\r\n      .map(c => c.split(','))\r\n      .map(a => ({method: a[1], start: +a[2], count: +a[3]}));\r\n  }\r\n\r\n  /**\r\n\t * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`\r\n\t * hook, in which case, plugins will not be called on `afterLayout`.\r\n\t * @private\r\n\t */\r\n  _updateLayout(minPadding) {\r\n    if (this.notifyPlugins('beforeLayout', {cancelable: true}) === false) {\r\n      return;\r\n    }\r\n\r\n    layouts.update(this, this.width, this.height, minPadding);\r\n\r\n    const area = this.chartArea;\r\n    const noArea = area.width <= 0 || area.height <= 0;\r\n\r\n    this._layers = [];\r\n    each(this.boxes, (box) => {\r\n      if (noArea && box.position === 'chartArea') {\r\n        // Skip drawing and configuring chartArea boxes when chartArea is zero or negative\r\n        return;\r\n      }\r\n\r\n      // configure is called twice, once in core.scale.update and once here.\r\n      // Here the boxes are fully updated and at their final positions.\r\n      if (box.configure) {\r\n        box.configure();\r\n      }\r\n      this._layers.push(...box._layers());\r\n    }, this);\r\n\r\n    this._layers.forEach((item, index) => {\r\n      item._idx = index;\r\n    });\r\n\r\n    this.notifyPlugins('afterLayout');\r\n  }\r\n\r\n  /**\r\n\t * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`\r\n\t * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.\r\n\t * @private\r\n\t */\r\n  _updateDatasets(mode) {\r\n    if (this.notifyPlugins('beforeDatasetsUpdate', {mode, cancelable: true}) === false) {\r\n      return;\r\n    }\r\n\r\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\r\n      this.getDatasetMeta(i).controller.configure();\r\n    }\r\n\r\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\r\n      this._updateDataset(i, isFunction(mode) ? mode({datasetIndex: i}) : mode);\r\n    }\r\n\r\n    this.notifyPlugins('afterDatasetsUpdate', {mode});\r\n  }\r\n\r\n  /**\r\n\t * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`\r\n\t * hook, in which case, plugins will not be called on `afterDatasetUpdate`.\r\n\t * @private\r\n\t */\r\n  _updateDataset(index, mode) {\r\n    const meta = this.getDatasetMeta(index);\r\n    const args = {meta, index, mode, cancelable: true};\r\n\r\n    if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {\r\n      return;\r\n    }\r\n\r\n    meta.controller._update(mode);\r\n\r\n    args.cancelable = false;\r\n    this.notifyPlugins('afterDatasetUpdate', args);\r\n  }\r\n\r\n  render() {\r\n    if (this.notifyPlugins('beforeRender', {cancelable: true}) === false) {\r\n      return;\r\n    }\r\n\r\n    if (animator.has(this)) {\r\n      if (this.attached && !animator.running(this)) {\r\n        animator.start(this);\r\n      }\r\n    } else {\r\n      this.draw();\r\n      onAnimationsComplete({chart: this});\r\n    }\r\n  }\r\n\r\n  draw() {\r\n    let i;\r\n    if (this._resizeBeforeDraw) {\r\n      const {width, height} = this._resizeBeforeDraw;\r\n      this._resize(width, height);\r\n      this._resizeBeforeDraw = null;\r\n    }\r\n    this.clear();\r\n\r\n    if (this.width <= 0 || this.height <= 0) {\r\n      return;\r\n    }\r\n\r\n    if (this.notifyPlugins('beforeDraw', {cancelable: true}) === false) {\r\n      return;\r\n    }\r\n\r\n    // Because of plugin hooks (before/afterDatasetsDraw), datasets can't\r\n    // currently be part of layers. Instead, we draw\r\n    // layers <= 0 before(default, backward compat), and the rest after\r\n    const layers = this._layers;\r\n    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {\r\n      layers[i].draw(this.chartArea);\r\n    }\r\n\r\n    this._drawDatasets();\r\n\r\n    // Rest of layers\r\n    for (; i < layers.length; ++i) {\r\n      layers[i].draw(this.chartArea);\r\n    }\r\n\r\n    this.notifyPlugins('afterDraw');\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _getSortedDatasetMetas(filterVisible) {\r\n    const metasets = this._sortedMetasets;\r\n    const result = [];\r\n    let i, ilen;\r\n\r\n    for (i = 0, ilen = metasets.length; i < ilen; ++i) {\r\n      const meta = metasets[i];\r\n      if (!filterVisible || meta.visible) {\r\n        result.push(meta);\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n\t * Gets the visible dataset metas in drawing order\r\n\t * @return {object[]}\r\n\t */\r\n  getSortedVisibleDatasetMetas() {\r\n    return this._getSortedDatasetMetas(true);\r\n  }\r\n\r\n  /**\r\n\t * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`\r\n\t * hook, in which case, plugins will not be called on `afterDatasetsDraw`.\r\n\t * @private\r\n\t */\r\n  _drawDatasets() {\r\n    if (this.notifyPlugins('beforeDatasetsDraw', {cancelable: true}) === false) {\r\n      return;\r\n    }\r\n\r\n    const metasets = this.getSortedVisibleDatasetMetas();\r\n    for (let i = metasets.length - 1; i >= 0; --i) {\r\n      this._drawDataset(metasets[i]);\r\n    }\r\n\r\n    this.notifyPlugins('afterDatasetsDraw');\r\n  }\r\n\r\n  /**\r\n\t * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`\r\n\t * hook, in which case, plugins will not be called on `afterDatasetDraw`.\r\n\t * @private\r\n\t */\r\n  _drawDataset(meta) {\r\n    const ctx = this.ctx;\r\n    const clip = meta._clip;\r\n    const useClip = !clip.disabled;\r\n    const area = getDatasetArea(meta) || this.chartArea;\r\n    const args = {\r\n      meta,\r\n      index: meta.index,\r\n      cancelable: true\r\n    };\r\n\r\n    if (this.notifyPlugins('beforeDatasetDraw', args) === false) {\r\n      return;\r\n    }\r\n\r\n    if (useClip) {\r\n      clipArea(ctx, {\r\n        left: clip.left === false ? 0 : area.left - clip.left,\r\n        right: clip.right === false ? this.width : area.right + clip.right,\r\n        top: clip.top === false ? 0 : area.top - clip.top,\r\n        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom\r\n      });\r\n    }\r\n\r\n    meta.controller.draw();\r\n\r\n    if (useClip) {\r\n      unclipArea(ctx);\r\n    }\r\n\r\n    args.cancelable = false;\r\n    this.notifyPlugins('afterDatasetDraw', args);\r\n  }\r\n\r\n  /**\r\n   * Checks whether the given point is in the chart area.\r\n   * @param {Point} point - in relative coordinates (see, e.g., getRelativePosition)\r\n   * @returns {boolean}\r\n   */\r\n  isPointInArea(point) {\r\n    return _isPointInArea(point, this.chartArea, this._minPadding);\r\n  }\r\n\r\n  getElementsAtEventForMode(e, mode, options, useFinalPosition) {\r\n    const method = Interaction.modes[mode];\r\n    if (typeof method === 'function') {\r\n      return method(this, e, options, useFinalPosition);\r\n    }\r\n\r\n    return [];\r\n  }\r\n\r\n  getDatasetMeta(datasetIndex) {\r\n    const dataset = this.data.datasets[datasetIndex];\r\n    const metasets = this._metasets;\r\n    let meta = metasets.filter(x => x && x._dataset === dataset).pop();\r\n\r\n    if (!meta) {\r\n      meta = {\r\n        type: null,\r\n        data: [],\r\n        dataset: null,\r\n        controller: null,\r\n        hidden: null,\t\t\t// See isDatasetVisible() comment\r\n        xAxisID: null,\r\n        yAxisID: null,\r\n        order: dataset && dataset.order || 0,\r\n        index: datasetIndex,\r\n        _dataset: dataset,\r\n        _parsed: [],\r\n        _sorted: false\r\n      };\r\n      metasets.push(meta);\r\n    }\r\n\r\n    return meta;\r\n  }\r\n\r\n  getContext() {\r\n    return this.$context || (this.$context = createContext(null, {chart: this, type: 'chart'}));\r\n  }\r\n\r\n  getVisibleDatasetCount() {\r\n    return this.getSortedVisibleDatasetMetas().length;\r\n  }\r\n\r\n  isDatasetVisible(datasetIndex) {\r\n    const dataset = this.data.datasets[datasetIndex];\r\n    if (!dataset) {\r\n      return false;\r\n    }\r\n\r\n    const meta = this.getDatasetMeta(datasetIndex);\r\n\r\n    // meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,\r\n    // the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.\r\n    return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;\r\n  }\r\n\r\n  setDatasetVisibility(datasetIndex, visible) {\r\n    const meta = this.getDatasetMeta(datasetIndex);\r\n    meta.hidden = !visible;\r\n  }\r\n\r\n  toggleDataVisibility(index) {\r\n    this._hiddenIndices[index] = !this._hiddenIndices[index];\r\n  }\r\n\r\n  getDataVisibility(index) {\r\n    return !this._hiddenIndices[index];\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _updateVisibility(datasetIndex, dataIndex, visible) {\r\n    const mode = visible ? 'show' : 'hide';\r\n    const meta = this.getDatasetMeta(datasetIndex);\r\n    const anims = meta.controller._resolveAnimations(undefined, mode);\r\n\r\n    if (defined(dataIndex)) {\r\n      meta.data[dataIndex].hidden = !visible;\r\n      this.update();\r\n    } else {\r\n      this.setDatasetVisibility(datasetIndex, visible);\r\n      // Animate visible state, so hide animation can be seen. This could be handled better if update / updateDataset returned a Promise.\r\n      anims.update(meta, {visible});\r\n      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : undefined);\r\n    }\r\n  }\r\n\r\n  hide(datasetIndex, dataIndex) {\r\n    this._updateVisibility(datasetIndex, dataIndex, false);\r\n  }\r\n\r\n  show(datasetIndex, dataIndex) {\r\n    this._updateVisibility(datasetIndex, dataIndex, true);\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _destroyDatasetMeta(datasetIndex) {\r\n    const meta = this._metasets[datasetIndex];\r\n    if (meta && meta.controller) {\r\n      meta.controller._destroy();\r\n    }\r\n    delete this._metasets[datasetIndex];\r\n  }\r\n\r\n  _stop() {\r\n    let i, ilen;\r\n    this.stop();\r\n    animator.remove(this);\r\n\r\n    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\r\n      this._destroyDatasetMeta(i);\r\n    }\r\n  }\r\n\r\n  destroy() {\r\n    this.notifyPlugins('beforeDestroy');\r\n    const {canvas, ctx} = this;\r\n\r\n    this._stop();\r\n    this.config.clearCache();\r\n\r\n    if (canvas) {\r\n      this.unbindEvents();\r\n      clearCanvas(canvas, ctx);\r\n      this.platform.releaseContext(ctx);\r\n      this.canvas = null;\r\n      this.ctx = null;\r\n    }\r\n\r\n    delete instances[this.id];\r\n\r\n    this.notifyPlugins('afterDestroy');\r\n  }\r\n\r\n  toBase64Image(...args) {\r\n    return this.canvas.toDataURL(...args);\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  bindEvents() {\r\n    this.bindUserEvents();\r\n    if (this.options.responsive) {\r\n      this.bindResponsiveEvents();\r\n    } else {\r\n      this.attached = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  bindUserEvents() {\r\n    const listeners = this._listeners;\r\n    const platform = this.platform;\r\n\r\n    const _add = (type, listener) => {\r\n      platform.addEventListener(this, type, listener);\r\n      listeners[type] = listener;\r\n    };\r\n\r\n    const listener = (e, x, y) => {\r\n      e.offsetX = x;\r\n      e.offsetY = y;\r\n      this._eventHandler(e);\r\n    };\r\n\r\n    each(this.options.events, (type) => _add(type, listener));\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  bindResponsiveEvents() {\r\n    if (!this._responsiveListeners) {\r\n      this._responsiveListeners = {};\r\n    }\r\n    const listeners = this._responsiveListeners;\r\n    const platform = this.platform;\r\n\r\n    const _add = (type, listener) => {\r\n      platform.addEventListener(this, type, listener);\r\n      listeners[type] = listener;\r\n    };\r\n    const _remove = (type, listener) => {\r\n      if (listeners[type]) {\r\n        platform.removeEventListener(this, type, listener);\r\n        delete listeners[type];\r\n      }\r\n    };\r\n\r\n    const listener = (width, height) => {\r\n      if (this.canvas) {\r\n        this.resize(width, height);\r\n      }\r\n    };\r\n\r\n    let detached; // eslint-disable-line prefer-const\r\n    const attached = () => {\r\n      _remove('attach', attached);\r\n\r\n      this.attached = true;\r\n      this.resize();\r\n\r\n      _add('resize', listener);\r\n      _add('detach', detached);\r\n    };\r\n\r\n    detached = () => {\r\n      this.attached = false;\r\n\r\n      _remove('resize', listener);\r\n\r\n      // Stop animating and remove metasets, so when re-attached, the animations start from beginning.\r\n      this._stop();\r\n      this._resize(0, 0);\r\n\r\n      _add('attach', attached);\r\n    };\r\n\r\n    if (platform.isAttached(this.canvas)) {\r\n      attached();\r\n    } else {\r\n      detached();\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  unbindEvents() {\r\n    each(this._listeners, (listener, type) => {\r\n      this.platform.removeEventListener(this, type, listener);\r\n    });\r\n    this._listeners = {};\r\n\r\n    each(this._responsiveListeners, (listener, type) => {\r\n      this.platform.removeEventListener(this, type, listener);\r\n    });\r\n    this._responsiveListeners = undefined;\r\n  }\r\n\r\n  updateHoverStyle(items, mode, enabled) {\r\n    const prefix = enabled ? 'set' : 'remove';\r\n    let meta, item, i, ilen;\r\n\r\n    if (mode === 'dataset') {\r\n      meta = this.getDatasetMeta(items[0].datasetIndex);\r\n      meta.controller['_' + prefix + 'DatasetHoverStyle']();\r\n    }\r\n\r\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\r\n      item = items[i];\r\n      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\r\n      if (controller) {\r\n        controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * Get active (hovered) elements\r\n\t * @returns array\r\n\t */\r\n  getActiveElements() {\r\n    return this._active || [];\r\n  }\r\n\r\n  /**\r\n\t * Set active (hovered) elements\r\n\t * @param {array} activeElements New active data points\r\n\t */\r\n  setActiveElements(activeElements) {\r\n    const lastActive = this._active || [];\r\n    const active = activeElements.map(({datasetIndex, index}) => {\r\n      const meta = this.getDatasetMeta(datasetIndex);\r\n      if (!meta) {\r\n        throw new Error('No dataset found at index ' + datasetIndex);\r\n      }\r\n\r\n      return {\r\n        datasetIndex,\r\n        element: meta.data[index],\r\n        index,\r\n      };\r\n    });\r\n    const changed = !_elementsEqual(active, lastActive);\r\n\r\n    if (changed) {\r\n      this._active = active;\r\n      // Make sure we don't use the previous mouse event to override the active elements in update.\r\n      this._lastEvent = null;\r\n      this._updateHoverStyles(active, lastActive);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * Calls enabled plugins on the specified hook and with the given args.\r\n\t * This method immediately returns as soon as a plugin explicitly returns false. The\r\n\t * returned value can be used, for instance, to interrupt the current action.\r\n\t * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\r\n\t * @param {Object} [args] - Extra arguments to apply to the hook call.\r\n   * @param {import('./core.plugins.js').filterCallback} [filter] - Filtering function for limiting which plugins are notified\r\n\t * @returns {boolean} false if any of the plugins return false, else returns true.\r\n\t */\r\n  notifyPlugins(hook, args, filter) {\r\n    return this._plugins.notify(this, hook, args, filter);\r\n  }\r\n\r\n  /**\r\n   * Check if a plugin with the specific ID is registered and enabled\r\n   * @param {string} pluginId - The ID of the plugin of which to check if it is enabled\r\n   * @returns {boolean}\r\n   */\r\n  isPluginEnabled(pluginId) {\r\n    return this._plugins._cache.filter(p => p.plugin.id === pluginId).length === 1;\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _updateHoverStyles(active, lastActive, replay) {\r\n    const hoverOptions = this.options.hover;\r\n    const diff = (a, b) => a.filter(x => !b.some(y => x.datasetIndex === y.datasetIndex && x.index === y.index));\r\n    const deactivated = diff(lastActive, active);\r\n    const activated = replay ? active : diff(active, lastActive);\r\n\r\n    if (deactivated.length) {\r\n      this.updateHoverStyle(deactivated, hoverOptions.mode, false);\r\n    }\r\n\r\n    if (activated.length && hoverOptions.mode) {\r\n      this.updateHoverStyle(activated, hoverOptions.mode, true);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _eventHandler(e, replay) {\r\n    const args = {\r\n      event: e,\r\n      replay,\r\n      cancelable: true,\r\n      inChartArea: this.isPointInArea(e)\r\n    };\r\n    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);\r\n\r\n    if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {\r\n      return;\r\n    }\r\n\r\n    const changed = this._handleEvent(e, replay, args.inChartArea);\r\n\r\n    args.cancelable = false;\r\n    this.notifyPlugins('afterEvent', args, eventFilter);\r\n\r\n    if (changed || args.changed) {\r\n      this.render();\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n\t * Handle an event\r\n\t * @param {ChartEvent} e the event to handle\r\n\t * @param {boolean} [replay] - true if the event was replayed by `update`\r\n   * @param {boolean} [inChartArea] - true if the event is inside chartArea\r\n\t * @return {boolean} true if the chart needs to re-render\r\n\t * @private\r\n\t */\r\n  _handleEvent(e, replay, inChartArea) {\r\n    const {_active: lastActive = [], options} = this;\r\n\r\n    // If the event is replayed from `update`, we should evaluate with the final positions.\r\n    //\r\n    // The `replay`:\r\n    // It's the last event (excluding click) that has occurred before `update`.\r\n    // So mouse has not moved. It's also over the chart, because there is a `replay`.\r\n    //\r\n    // The why:\r\n    // If animations are active, the elements haven't moved yet compared to state before update.\r\n    // But if they will, we are activating the elements that would be active, if this check\r\n    // was done after the animations have completed. => \"final positions\".\r\n    // If there is no animations, the \"final\" and \"current\" positions are equal.\r\n    // This is done so we do not have to evaluate the active elements each animation frame\r\n    // - it would be expensive.\r\n    const useFinalPosition = replay;\r\n    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);\r\n    const isClick = _isClickEvent(e);\r\n    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);\r\n\r\n    if (inChartArea) {\r\n      // Set _lastEvent to null while we are processing the event handlers.\r\n      // This prevents recursion if the handler calls chart.update()\r\n      this._lastEvent = null;\r\n\r\n      // Invoke onHover hook\r\n      callCallback(options.onHover, [e, active, this], this);\r\n\r\n      if (isClick) {\r\n        callCallback(options.onClick, [e, active, this], this);\r\n      }\r\n    }\r\n\r\n    const changed = !_elementsEqual(active, lastActive);\r\n    if (changed || replay) {\r\n      this._active = active;\r\n      this._updateHoverStyles(active, lastActive, replay);\r\n    }\r\n\r\n    this._lastEvent = lastEvent;\r\n\r\n    return changed;\r\n  }\r\n\r\n  /**\r\n   * @param {ChartEvent} e - The event\r\n   * @param {import('../types/index.js').ActiveElement[]} lastActive - Previously active elements\r\n   * @param {boolean} inChartArea - Is the envent inside chartArea\r\n   * @param {boolean} useFinalPosition - Should the evaluation be done with current or final (after animation) element positions\r\n   * @returns {import('../types/index.js').ActiveElement[]} - The active elements\r\n   * @pravate\r\n   */\r\n  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {\r\n    if (e.type === 'mouseout') {\r\n      return [];\r\n    }\r\n\r\n    if (!inChartArea) {\r\n      // Let user control the active elements outside chartArea. Eg. using Legend.\r\n      return lastActive;\r\n    }\r\n\r\n    const hoverOptions = this.options.hover;\r\n    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\r\n  }\r\n}\r\n\r\n// @ts-ignore\r\nfunction invalidatePlugins() {\r\n  return each(Chart.instances, (chart) => chart._plugins.invalidate());\r\n}\r\n\r\nexport default Chart;\r\n","import Element from '../core/core.element.js';\r\nimport {_angleBetween, getAngleFromPoint, TAU, HALF_PI, valueOrDefault} from '../helpers/index.js';\r\nimport {PI, _isBetween, _limitValue} from '../helpers/helpers.math.js';\r\nimport {_readValueToProps} from '../helpers/helpers.options.js';\r\nimport type {ArcOptions, Point} from '../types/index.js';\r\n\r\n\r\nfunction clipArc(ctx: CanvasRenderingContext2D, element: ArcElement, endAngle: number) {\r\n  const {startAngle, pixelMargin, x, y, outerRadius, innerRadius} = element;\r\n  let angleMargin = pixelMargin / outerRadius;\r\n\r\n  // Draw an inner border by clipping the arc and drawing a double-width border\r\n  // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders\r\n  ctx.beginPath();\r\n  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\r\n  if (innerRadius > pixelMargin) {\r\n    angleMargin = pixelMargin / innerRadius;\r\n    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\r\n  } else {\r\n    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);\r\n  }\r\n  ctx.closePath();\r\n  ctx.clip();\r\n}\r\n\r\nfunction toRadiusCorners(value) {\r\n  return _readValueToProps(value, ['outerStart', 'outerEnd', 'innerStart', 'innerEnd']);\r\n}\r\n\r\n/**\r\n * Parse border radius from the provided options\r\n */\r\nfunction parseBorderRadius(arc: ArcElement, innerRadius: number, outerRadius: number, angleDelta: number) {\r\n  const o = toRadiusCorners(arc.options.borderRadius);\r\n  const halfThickness = (outerRadius - innerRadius) / 2;\r\n  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\r\n\r\n  // Outer limits are complicated. We want to compute the available angular distance at\r\n  // a radius of outerRadius - borderRadius because for small angular distances, this term limits.\r\n  // We compute at r = outerRadius - borderRadius because this circle defines the center of the border corners.\r\n  //\r\n  // If the borderRadius is large, that value can become negative.\r\n  // This causes the outer borders to lose their radius entirely, which is rather unexpected. To solve that, if borderRadius > outerRadius\r\n  // we know that the thickness term will dominate and compute the limits at that point\r\n  const computeOuterLimit = (val) => {\r\n    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\r\n    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));\r\n  };\r\n\r\n  return {\r\n    outerStart: computeOuterLimit(o.outerStart),\r\n    outerEnd: computeOuterLimit(o.outerEnd),\r\n    innerStart: _limitValue(o.innerStart, 0, innerLimit),\r\n    innerEnd: _limitValue(o.innerEnd, 0, innerLimit),\r\n  };\r\n}\r\n\r\n/**\r\n * Convert (r, ) to (x, y)\r\n */\r\nfunction rThetaToXY(r: number, theta: number, x: number, y: number) {\r\n  return {\r\n    x: x + r * Math.cos(theta),\r\n    y: y + r * Math.sin(theta),\r\n  };\r\n}\r\n\r\n\r\n/**\r\n * Path the arc, respecting border radius by separating into left and right halves.\r\n *\r\n *   Start      End\r\n *\r\n *    1--->a--->2    Outer\r\n *   /           \\\r\n *   8           3\r\n *   |           |\r\n *   |           |\r\n *   7           4\r\n *   \\           /\r\n *    6<---b<---5    Inner\r\n */\r\nfunction pathArc(\r\n  ctx: CanvasRenderingContext2D,\r\n  element: ArcElement,\r\n  offset: number,\r\n  spacing: number,\r\n  end: number,\r\n  circular: boolean,\r\n) {\r\n  const {x, y, startAngle: start, pixelMargin, innerRadius: innerR} = element;\r\n\r\n  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\r\n  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\r\n\r\n  let spacingOffset = 0;\r\n  const alpha = end - start;\r\n\r\n  if (spacing) {\r\n    // When spacing is present, it is the same for all items\r\n    // So we adjust the start and end angle of the arc such that\r\n    // the distance is the same as it would be without the spacing\r\n    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\r\n    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\r\n    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\r\n    const adjustedAngle = avNogSpacingRadius !== 0 ? (alpha * avNogSpacingRadius) / (avNogSpacingRadius + spacing) : alpha;\r\n    spacingOffset = (alpha - adjustedAngle) / 2;\r\n  }\r\n\r\n  const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;\r\n  const angleOffset = (alpha - beta) / 2;\r\n  const startAngle = start + angleOffset + spacingOffset;\r\n  const endAngle = end - angleOffset - spacingOffset;\r\n  const {outerStart, outerEnd, innerStart, innerEnd} = parseBorderRadius(element, innerRadius, outerRadius, endAngle - startAngle);\r\n\r\n  const outerStartAdjustedRadius = outerRadius - outerStart;\r\n  const outerEndAdjustedRadius = outerRadius - outerEnd;\r\n  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\r\n  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\r\n\r\n  const innerStartAdjustedRadius = innerRadius + innerStart;\r\n  const innerEndAdjustedRadius = innerRadius + innerEnd;\r\n  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\r\n  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\r\n\r\n  ctx.beginPath();\r\n\r\n  if (circular) {\r\n    // The first arc segments from point 1 to point a to point 2\r\n    const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;\r\n    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);\r\n    ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);\r\n\r\n    // The corner segment from point 2 to point 3\r\n    if (outerEnd > 0) {\r\n      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\r\n      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);\r\n    }\r\n\r\n    // The line from point 3 to point 4\r\n    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\r\n    ctx.lineTo(p4.x, p4.y);\r\n\r\n    // The corner segment from point 4 to point 5\r\n    if (innerEnd > 0) {\r\n      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\r\n      ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);\r\n    }\r\n\r\n    // The inner arc from point 5 to point b to point 6\r\n    const innerMidAdjustedAngle = ((endAngle - (innerEnd / innerRadius)) + (startAngle + (innerStart / innerRadius))) / 2;\r\n    ctx.arc(x, y, innerRadius, endAngle - (innerEnd / innerRadius), innerMidAdjustedAngle, true);\r\n    ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + (innerStart / innerRadius), true);\r\n\r\n    // The corner segment from point 6 to point 7\r\n    if (innerStart > 0) {\r\n      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\r\n      ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);\r\n    }\r\n\r\n    // The line from point 7 to point 8\r\n    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\r\n    ctx.lineTo(p8.x, p8.y);\r\n\r\n    // The corner segment from point 8 to point 1\r\n    if (outerStart > 0) {\r\n      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\r\n      ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);\r\n    }\r\n  } else {\r\n    ctx.moveTo(x, y);\r\n\r\n    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;\r\n    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;\r\n    ctx.lineTo(outerStartX, outerStartY);\r\n\r\n    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;\r\n    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;\r\n    ctx.lineTo(outerEndX, outerEndY);\r\n  }\r\n\r\n  ctx.closePath();\r\n}\r\n\r\nfunction drawArc(\r\n  ctx: CanvasRenderingContext2D,\r\n  element: ArcElement,\r\n  offset: number,\r\n  spacing: number,\r\n  circular: boolean,\r\n) {\r\n  const {fullCircles, startAngle, circumference} = element;\r\n  let endAngle = element.endAngle;\r\n  if (fullCircles) {\r\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\r\n    for (let i = 0; i < fullCircles; ++i) {\r\n      ctx.fill();\r\n    }\r\n    if (!isNaN(circumference)) {\r\n      endAngle = startAngle + (circumference % TAU || TAU);\r\n    }\r\n  }\r\n  pathArc(ctx, element, offset, spacing, endAngle, circular);\r\n  ctx.fill();\r\n  return endAngle;\r\n}\r\n\r\nfunction drawBorder(\r\n  ctx: CanvasRenderingContext2D,\r\n  element: ArcElement,\r\n  offset: number,\r\n  spacing: number,\r\n  circular: boolean,\r\n) {\r\n  const {fullCircles, startAngle, circumference, options} = element;\r\n  const {borderWidth, borderJoinStyle, borderDash, borderDashOffset} = options;\r\n  const inner = options.borderAlign === 'inner';\r\n\r\n  if (!borderWidth) {\r\n    return;\r\n  }\r\n\r\n  ctx.setLineDash(borderDash || []);\r\n  ctx.lineDashOffset = borderDashOffset;\r\n\r\n  if (inner) {\r\n    ctx.lineWidth = borderWidth * 2;\r\n    ctx.lineJoin = borderJoinStyle || 'round';\r\n  } else {\r\n    ctx.lineWidth = borderWidth;\r\n    ctx.lineJoin = borderJoinStyle || 'bevel';\r\n  }\r\n\r\n  let endAngle = element.endAngle;\r\n  if (fullCircles) {\r\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\r\n    for (let i = 0; i < fullCircles; ++i) {\r\n      ctx.stroke();\r\n    }\r\n    if (!isNaN(circumference)) {\r\n      endAngle = startAngle + (circumference % TAU || TAU);\r\n    }\r\n  }\r\n\r\n  if (inner) {\r\n    clipArc(ctx, element, endAngle);\r\n  }\r\n\r\n  if (!fullCircles) {\r\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\r\n    ctx.stroke();\r\n  }\r\n}\r\n\r\nexport interface ArcProps extends Point {\r\n  startAngle: number;\r\n  endAngle: number;\r\n  innerRadius: number;\r\n  outerRadius: number;\r\n  circumference: number;\r\n}\r\n\r\nexport default class ArcElement extends Element<ArcProps, ArcOptions> {\r\n\r\n  static id = 'arc';\r\n\r\n  static defaults = {\r\n    borderAlign: 'center',\r\n    borderColor: '#fff',\r\n    borderDash: [],\r\n    borderDashOffset: 0,\r\n    borderJoinStyle: undefined,\r\n    borderRadius: 0,\r\n    borderWidth: 2,\r\n    offset: 0,\r\n    spacing: 0,\r\n    angle: undefined,\r\n    circular: true,\r\n  };\r\n\r\n  static defaultRoutes = {\r\n    backgroundColor: 'backgroundColor'\r\n  };\r\n\r\n  static descriptors = {\r\n    _scriptable: true,\r\n    _indexable: (name) => name !== 'borderDash'\r\n  };\r\n\r\n  circumference: number;\r\n  endAngle: number;\r\n  fullCircles: number;\r\n  innerRadius: number;\r\n  outerRadius: number;\r\n  pixelMargin: number;\r\n  startAngle: number;\r\n\r\n  constructor(cfg) {\r\n    super();\r\n\r\n    this.options = undefined;\r\n    this.circumference = undefined;\r\n    this.startAngle = undefined;\r\n    this.endAngle = undefined;\r\n    this.innerRadius = undefined;\r\n    this.outerRadius = undefined;\r\n    this.pixelMargin = 0;\r\n    this.fullCircles = 0;\r\n\r\n    if (cfg) {\r\n      Object.assign(this, cfg);\r\n    }\r\n  }\r\n\r\n  inRange(chartX: number, chartY: number, useFinalPosition: boolean) {\r\n    const point = this.getProps(['x', 'y'], useFinalPosition);\r\n    const {angle, distance} = getAngleFromPoint(point, {x: chartX, y: chartY});\r\n    const {startAngle, endAngle, innerRadius, outerRadius, circumference} = this.getProps([\r\n      'startAngle',\r\n      'endAngle',\r\n      'innerRadius',\r\n      'outerRadius',\r\n      'circumference'\r\n    ], useFinalPosition);\r\n    const rAdjust = this.options.spacing / 2;\r\n    const _circumference = valueOrDefault(circumference, endAngle - startAngle);\r\n    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);\r\n    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);\r\n\r\n    return (betweenAngles && withinRadius);\r\n  }\r\n\r\n  getCenterPoint(useFinalPosition: boolean) {\r\n    const {x, y, startAngle, endAngle, innerRadius, outerRadius} = this.getProps([\r\n      'x',\r\n      'y',\r\n      'startAngle',\r\n      'endAngle',\r\n      'innerRadius',\r\n      'outerRadius'\r\n    ], useFinalPosition);\r\n    const {offset, spacing} = this.options;\r\n    const halfAngle = (startAngle + endAngle) / 2;\r\n    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\r\n    return {\r\n      x: x + Math.cos(halfAngle) * halfRadius,\r\n      y: y + Math.sin(halfAngle) * halfRadius\r\n    };\r\n  }\r\n\r\n  tooltipPosition(useFinalPosition: boolean) {\r\n    return this.getCenterPoint(useFinalPosition);\r\n  }\r\n\r\n  draw(ctx: CanvasRenderingContext2D) {\r\n    const {options, circumference} = this;\r\n    const offset = (options.offset || 0) / 4;\r\n    const spacing = (options.spacing || 0) / 2;\r\n    const circular = options.circular;\r\n    this.pixelMargin = (options.borderAlign === 'inner') ? 0.33 : 0;\r\n    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;\r\n\r\n    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\r\n      return;\r\n    }\r\n\r\n    ctx.save();\r\n\r\n    const halfAngle = (this.startAngle + this.endAngle) / 2;\r\n    ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);\r\n    const fix = 1 - Math.sin(Math.min(PI, circumference || 0));\r\n    const radiusOffset = offset * fix;\r\n\r\n    ctx.fillStyle = options.backgroundColor;\r\n    ctx.strokeStyle = options.borderColor;\r\n\r\n    drawArc(ctx, this, radiusOffset, spacing, circular);\r\n    drawBorder(ctx, this, radiusOffset, spacing, circular);\r\n\r\n    ctx.restore();\r\n  }\r\n}\r\n","import Element from '../core/core.element.js';\r\nimport {_bezierInterpolation, _pointInLine, _steppedInterpolation} from '../helpers/helpers.interpolation.js';\r\nimport {_computeSegments, _boundSegments} from '../helpers/helpers.segment.js';\r\nimport {_steppedLineTo, _bezierCurveTo} from '../helpers/helpers.canvas.js';\r\nimport {_updateBezierControlPoints} from '../helpers/helpers.curve.js';\r\nimport {valueOrDefault} from '../helpers/index.js';\r\n\r\n/**\r\n * @typedef { import('./element.point.js').default } PointElement\r\n */\r\n\r\nfunction setStyle(ctx, options, style = options) {\r\n  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);\r\n  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));\r\n  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);\r\n  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);\r\n  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);\r\n  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);\r\n}\r\n\r\nfunction lineTo(ctx, previous, target) {\r\n  ctx.lineTo(target.x, target.y);\r\n}\r\n\r\n/**\r\n * @returns {any}\r\n */\r\nfunction getLineMethod(options) {\r\n  if (options.stepped) {\r\n    return _steppedLineTo;\r\n  }\r\n\r\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\r\n    return _bezierCurveTo;\r\n  }\r\n\r\n  return lineTo;\r\n}\r\n\r\nfunction pathVars(points, segment, params = {}) {\r\n  const count = points.length;\r\n  const {start: paramsStart = 0, end: paramsEnd = count - 1} = params;\r\n  const {start: segmentStart, end: segmentEnd} = segment;\r\n  const start = Math.max(paramsStart, segmentStart);\r\n  const end = Math.min(paramsEnd, segmentEnd);\r\n  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\r\n\r\n  return {\r\n    count,\r\n    start,\r\n    loop: segment.loop,\r\n    ilen: end < start && !outside ? count + end - start : end - start\r\n  };\r\n}\r\n\r\n/**\r\n * Create path from points, grouping by truncated x-coordinate\r\n * Points need to be in order by x-coordinate for this to work efficiently\r\n * @param {CanvasRenderingContext2D|Path2D} ctx - Context\r\n * @param {LineElement} line\r\n * @param {object} segment\r\n * @param {number} segment.start - start index of the segment, referring the points array\r\n * @param {number} segment.end - end index of the segment, referring the points array\r\n * @param {boolean} segment.loop - indicates that the segment is a loop\r\n * @param {object} params\r\n * @param {boolean} params.move - move to starting point (vs line to it)\r\n * @param {boolean} params.reverse - path the segment from end to start\r\n * @param {number} params.start - limit segment to points starting from `start` index\r\n * @param {number} params.end - limit segment to points ending at `start` + `count` index\r\n */\r\nfunction pathSegment(ctx, line, segment, params) {\r\n  const {points, options} = line;\r\n  const {count, start, loop, ilen} = pathVars(points, segment, params);\r\n  const lineMethod = getLineMethod(options);\r\n  // eslint-disable-next-line prefer-const\r\n  let {move = true, reverse} = params || {};\r\n  let i, point, prev;\r\n\r\n  for (i = 0; i <= ilen; ++i) {\r\n    point = points[(start + (reverse ? ilen - i : i)) % count];\r\n\r\n    if (point.skip) {\r\n      // If there is a skipped point inside a segment, spanGaps must be true\r\n      continue;\r\n    } else if (move) {\r\n      ctx.moveTo(point.x, point.y);\r\n      move = false;\r\n    } else {\r\n      lineMethod(ctx, prev, point, reverse, options.stepped);\r\n    }\r\n\r\n    prev = point;\r\n  }\r\n\r\n  if (loop) {\r\n    point = points[(start + (reverse ? ilen : 0)) % count];\r\n    lineMethod(ctx, prev, point, reverse, options.stepped);\r\n  }\r\n\r\n  return !!loop;\r\n}\r\n\r\n/**\r\n * Create path from points, grouping by truncated x-coordinate\r\n * Points need to be in order by x-coordinate for this to work efficiently\r\n * @param {CanvasRenderingContext2D|Path2D} ctx - Context\r\n * @param {LineElement} line\r\n * @param {object} segment\r\n * @param {number} segment.start - start index of the segment, referring the points array\r\n * @param {number} segment.end - end index of the segment, referring the points array\r\n * @param {boolean} segment.loop - indicates that the segment is a loop\r\n * @param {object} params\r\n * @param {boolean} params.move - move to starting point (vs line to it)\r\n * @param {boolean} params.reverse - path the segment from end to start\r\n * @param {number} params.start - limit segment to points starting from `start` index\r\n * @param {number} params.end - limit segment to points ending at `start` + `count` index\r\n */\r\nfunction fastPathSegment(ctx, line, segment, params) {\r\n  const points = line.points;\r\n  const {count, start, ilen} = pathVars(points, segment, params);\r\n  const {move = true, reverse} = params || {};\r\n  let avgX = 0;\r\n  let countX = 0;\r\n  let i, point, prevX, minY, maxY, lastY;\r\n\r\n  const pointIndex = (index) => (start + (reverse ? ilen - index : index)) % count;\r\n  const drawX = () => {\r\n    if (minY !== maxY) {\r\n      // Draw line to maxY and minY, using the average x-coordinate\r\n      ctx.lineTo(avgX, maxY);\r\n      ctx.lineTo(avgX, minY);\r\n      // Line to y-value of last point in group. So the line continues\r\n      // from correct position. Not using move, to have solid path.\r\n      ctx.lineTo(avgX, lastY);\r\n    }\r\n  };\r\n\r\n  if (move) {\r\n    point = points[pointIndex(0)];\r\n    ctx.moveTo(point.x, point.y);\r\n  }\r\n\r\n  for (i = 0; i <= ilen; ++i) {\r\n    point = points[pointIndex(i)];\r\n\r\n    if (point.skip) {\r\n      // If there is a skipped point inside a segment, spanGaps must be true\r\n      continue;\r\n    }\r\n\r\n    const x = point.x;\r\n    const y = point.y;\r\n    const truncX = x | 0; // truncated x-coordinate\r\n\r\n    if (truncX === prevX) {\r\n      // Determine `minY` / `maxY` and `avgX` while we stay within same x-position\r\n      if (y < minY) {\r\n        minY = y;\r\n      } else if (y > maxY) {\r\n        maxY = y;\r\n      }\r\n      // For first point in group, countX is `0`, so average will be `x` / 1.\r\n      avgX = (countX * avgX + x) / ++countX;\r\n    } else {\r\n      drawX();\r\n      // Draw line to next x-position, using the first (or only)\r\n      // y-value in that group\r\n      ctx.lineTo(x, y);\r\n\r\n      prevX = truncX;\r\n      countX = 0;\r\n      minY = maxY = y;\r\n    }\r\n    // Keep track of the last y-value in group\r\n    lastY = y;\r\n  }\r\n  drawX();\r\n}\r\n\r\n/**\r\n * @param {LineElement} line - the line\r\n * @returns {function}\r\n * @private\r\n */\r\nfunction _getSegmentMethod(line) {\r\n  const opts = line.options;\r\n  const borderDash = opts.borderDash && opts.borderDash.length;\r\n  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;\r\n  return useFastPath ? fastPathSegment : pathSegment;\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nfunction _getInterpolationMethod(options) {\r\n  if (options.stepped) {\r\n    return _steppedInterpolation;\r\n  }\r\n\r\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\r\n    return _bezierInterpolation;\r\n  }\r\n\r\n  return _pointInLine;\r\n}\r\n\r\nfunction strokePathWithCache(ctx, line, start, count) {\r\n  let path = line._path;\r\n  if (!path) {\r\n    path = line._path = new Path2D();\r\n    if (line.path(path, start, count)) {\r\n      path.closePath();\r\n    }\r\n  }\r\n  setStyle(ctx, line.options);\r\n  ctx.stroke(path);\r\n}\r\n\r\nfunction strokePathDirect(ctx, line, start, count) {\r\n  const {segments, options} = line;\r\n  const segmentMethod = _getSegmentMethod(line);\r\n\r\n  for (const segment of segments) {\r\n    setStyle(ctx, options, segment.style);\r\n    ctx.beginPath();\r\n    if (segmentMethod(ctx, line, segment, {start, end: start + count - 1})) {\r\n      ctx.closePath();\r\n    }\r\n    ctx.stroke();\r\n  }\r\n}\r\n\r\nconst usePath2D = typeof Path2D === 'function';\r\n\r\nfunction draw(ctx, line, start, count) {\r\n  if (usePath2D && !line.options.segment) {\r\n    strokePathWithCache(ctx, line, start, count);\r\n  } else {\r\n    strokePathDirect(ctx, line, start, count);\r\n  }\r\n}\r\n\r\nexport default class LineElement extends Element {\r\n\r\n  static id = 'line';\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = {\r\n    borderCapStyle: 'butt',\r\n    borderDash: [],\r\n    borderDashOffset: 0,\r\n    borderJoinStyle: 'miter',\r\n    borderWidth: 3,\r\n    capBezierPoints: true,\r\n    cubicInterpolationMode: 'default',\r\n    fill: false,\r\n    spanGaps: false,\r\n    stepped: false,\r\n    tension: 0,\r\n  };\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaultRoutes = {\r\n    backgroundColor: 'backgroundColor',\r\n    borderColor: 'borderColor'\r\n  };\r\n\r\n\r\n  static descriptors = {\r\n    _scriptable: true,\r\n    _indexable: (name) => name !== 'borderDash' && name !== 'fill',\r\n  };\r\n\r\n\r\n  constructor(cfg) {\r\n    super();\r\n\r\n    this.animated = true;\r\n    this.options = undefined;\r\n    this._chart = undefined;\r\n    this._loop = undefined;\r\n    this._fullLoop = undefined;\r\n    this._path = undefined;\r\n    this._points = undefined;\r\n    this._segments = undefined;\r\n    this._decimated = false;\r\n    this._pointsUpdated = false;\r\n    this._datasetIndex = undefined;\r\n\r\n    if (cfg) {\r\n      Object.assign(this, cfg);\r\n    }\r\n  }\r\n\r\n  updateControlPoints(chartArea, indexAxis) {\r\n    const options = this.options;\r\n    if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {\r\n      const loop = options.spanGaps ? this._loop : this._fullLoop;\r\n      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);\r\n      this._pointsUpdated = true;\r\n    }\r\n  }\r\n\r\n  set points(points) {\r\n    this._points = points;\r\n    delete this._segments;\r\n    delete this._path;\r\n    this._pointsUpdated = false;\r\n  }\r\n\r\n  get points() {\r\n    return this._points;\r\n  }\r\n\r\n  get segments() {\r\n    return this._segments || (this._segments = _computeSegments(this, this.options.segment));\r\n  }\r\n\r\n  /**\r\n\t * First non-skipped point on this line\r\n\t * @returns {PointElement|undefined}\r\n\t */\r\n  first() {\r\n    const segments = this.segments;\r\n    const points = this.points;\r\n    return segments.length && points[segments[0].start];\r\n  }\r\n\r\n  /**\r\n\t * Last non-skipped point on this line\r\n\t * @returns {PointElement|undefined}\r\n\t */\r\n  last() {\r\n    const segments = this.segments;\r\n    const points = this.points;\r\n    const count = segments.length;\r\n    return count && points[segments[count - 1].end];\r\n  }\r\n\r\n  /**\r\n\t * Interpolate a point in this line at the same value on `property` as\r\n\t * the reference `point` provided\r\n\t * @param {PointElement} point - the reference point\r\n\t * @param {string} property - the property to match on\r\n\t * @returns {PointElement|undefined}\r\n\t */\r\n  interpolate(point, property) {\r\n    const options = this.options;\r\n    const value = point[property];\r\n    const points = this.points;\r\n    const segments = _boundSegments(this, {property, start: value, end: value});\r\n\r\n    if (!segments.length) {\r\n      return;\r\n    }\r\n\r\n    const result = [];\r\n    const _interpolate = _getInterpolationMethod(options);\r\n    let i, ilen;\r\n    for (i = 0, ilen = segments.length; i < ilen; ++i) {\r\n      const {start, end} = segments[i];\r\n      const p1 = points[start];\r\n      const p2 = points[end];\r\n      if (p1 === p2) {\r\n        result.push(p1);\r\n        continue;\r\n      }\r\n      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\r\n      const interpolated = _interpolate(p1, p2, t, options.stepped);\r\n      interpolated[property] = point[property];\r\n      result.push(interpolated);\r\n    }\r\n    return result.length === 1 ? result[0] : result;\r\n  }\r\n\r\n  /**\r\n\t * Append a segment of this line to current path.\r\n\t * @param {CanvasRenderingContext2D} ctx\r\n\t * @param {object} segment\r\n\t * @param {number} segment.start - start index of the segment, referring the points array\r\n \t * @param {number} segment.end - end index of the segment, referring the points array\r\n \t * @param {boolean} segment.loop - indicates that the segment is a loop\r\n\t * @param {object} params\r\n\t * @param {boolean} params.move - move to starting point (vs line to it)\r\n\t * @param {boolean} params.reverse - path the segment from end to start\r\n\t * @param {number} params.start - limit segment to points starting from `start` index\r\n\t * @param {number} params.end - limit segment to points ending at `start` + `count` index\r\n\t * @returns {undefined|boolean} - true if the segment is a full loop (path should be closed)\r\n\t */\r\n  pathSegment(ctx, segment, params) {\r\n    const segmentMethod = _getSegmentMethod(this);\r\n    return segmentMethod(ctx, this, segment, params);\r\n  }\r\n\r\n  /**\r\n\t * Append all segments of this line to current path.\r\n\t * @param {CanvasRenderingContext2D|Path2D} ctx\r\n\t * @param {number} [start]\r\n\t * @param {number} [count]\r\n\t * @returns {undefined|boolean} - true if line is a full loop (path should be closed)\r\n\t */\r\n  path(ctx, start, count) {\r\n    const segments = this.segments;\r\n    const segmentMethod = _getSegmentMethod(this);\r\n    let loop = this._loop;\r\n\r\n    start = start || 0;\r\n    count = count || (this.points.length - start);\r\n\r\n    for (const segment of segments) {\r\n      loop &= segmentMethod(ctx, this, segment, {start, end: start + count - 1});\r\n    }\r\n    return !!loop;\r\n  }\r\n\r\n  /**\r\n\t * Draw\r\n\t * @param {CanvasRenderingContext2D} ctx\r\n\t * @param {object} chartArea\r\n\t * @param {number} [start]\r\n\t * @param {number} [count]\r\n\t */\r\n  draw(ctx, chartArea, start, count) {\r\n    const options = this.options || {};\r\n    const points = this.points || [];\r\n\r\n    if (points.length && options.borderWidth) {\r\n      ctx.save();\r\n\r\n      draw(ctx, this, start, count);\r\n\r\n      ctx.restore();\r\n    }\r\n\r\n    if (this.animated) {\r\n      // When line is animated, the control points and path are not cached.\r\n      this._pointsUpdated = false;\r\n      this._path = undefined;\r\n    }\r\n  }\r\n}\r\n","import Element from '../core/core.element.js';\r\nimport {drawPoint, _isPointInArea} from '../helpers/helpers.canvas.js';\r\nimport type {\r\n  CartesianParsedData,\r\n  ChartArea,\r\n  Point,\r\n  PointHoverOptions,\r\n  PointOptions,\r\n} from '../types/index.js';\r\n\r\nfunction inRange(el: PointElement, pos: number, axis: 'x' | 'y', useFinalPosition?: boolean) {\r\n  const options = el.options;\r\n  const {[axis]: value} = el.getProps([axis], useFinalPosition);\r\n\r\n  return (Math.abs(pos - value) < options.radius + options.hitRadius);\r\n}\r\n\r\nexport type PointProps = Point\r\n\r\nexport default class PointElement extends Element<PointProps, PointOptions & PointHoverOptions> {\r\n\r\n  static id = 'point';\r\n\r\n  parsed: CartesianParsedData;\r\n  skip?: boolean;\r\n  stop?: boolean;\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = {\r\n    borderWidth: 1,\r\n    hitRadius: 1,\r\n    hoverBorderWidth: 1,\r\n    hoverRadius: 4,\r\n    pointStyle: 'circle',\r\n    radius: 3,\r\n    rotation: 0\r\n  };\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaultRoutes = {\r\n    backgroundColor: 'backgroundColor',\r\n    borderColor: 'borderColor'\r\n  };\r\n\r\n  constructor(cfg) {\r\n    super();\r\n\r\n    this.options = undefined;\r\n    this.parsed = undefined;\r\n    this.skip = undefined;\r\n    this.stop = undefined;\r\n\r\n    if (cfg) {\r\n      Object.assign(this, cfg);\r\n    }\r\n  }\r\n\r\n  inRange(mouseX: number, mouseY: number, useFinalPosition?: boolean) {\r\n    const options = this.options;\r\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\r\n    return ((Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2)) < Math.pow(options.hitRadius + options.radius, 2));\r\n  }\r\n\r\n  inXRange(mouseX: number, useFinalPosition?: boolean) {\r\n    return inRange(this, mouseX, 'x', useFinalPosition);\r\n  }\r\n\r\n  inYRange(mouseY: number, useFinalPosition?: boolean) {\r\n    return inRange(this, mouseY, 'y', useFinalPosition);\r\n  }\r\n\r\n  getCenterPoint(useFinalPosition?: boolean) {\r\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\r\n    return {x, y};\r\n  }\r\n\r\n  size(options?: Partial<PointOptions & PointHoverOptions>) {\r\n    options = options || this.options || {};\r\n    let radius = options.radius || 0;\r\n    radius = Math.max(radius, radius && options.hoverRadius || 0);\r\n    const borderWidth = radius && options.borderWidth || 0;\r\n    return (radius + borderWidth) * 2;\r\n  }\r\n\r\n  draw(ctx: CanvasRenderingContext2D, area: ChartArea) {\r\n    const options = this.options;\r\n\r\n    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {\r\n      return;\r\n    }\r\n\r\n    ctx.strokeStyle = options.borderColor;\r\n    ctx.lineWidth = options.borderWidth;\r\n    ctx.fillStyle = options.backgroundColor;\r\n    drawPoint(ctx, options, this.x, this.y);\r\n  }\r\n\r\n  getRange() {\r\n    const options = this.options || {};\r\n    // @ts-expect-error Fallbacks should never be hit in practice\r\n    return options.radius + options.hitRadius;\r\n  }\r\n}\r\n","import Element from '../core/core.element.js';\r\nimport {isObject, _isBetween, _limitValue} from '../helpers/index.js';\r\nimport {addRoundedRectPath} from '../helpers/helpers.canvas.js';\r\nimport {toTRBL, toTRBLCorners} from '../helpers/helpers.options.js';\r\n\r\n/** @typedef {{ x: number, y: number, base: number, horizontal: boolean, width: number, height: number }} BarProps */\r\n\r\n/**\r\n * Helper function to get the bounds of the bar regardless of the orientation\r\n * @param {BarElement} bar the bar\r\n * @param {boolean} [useFinalPosition]\r\n * @return {object} bounds of the bar\r\n * @private\r\n */\r\nfunction getBarBounds(bar, useFinalPosition) {\r\n  const {x, y, base, width, height} = /** @type {BarProps} */ (bar.getProps(['x', 'y', 'base', 'width', 'height'], useFinalPosition));\r\n\r\n  let left, right, top, bottom, half;\r\n\r\n  if (bar.horizontal) {\r\n    half = height / 2;\r\n    left = Math.min(x, base);\r\n    right = Math.max(x, base);\r\n    top = y - half;\r\n    bottom = y + half;\r\n  } else {\r\n    half = width / 2;\r\n    left = x - half;\r\n    right = x + half;\r\n    top = Math.min(y, base);\r\n    bottom = Math.max(y, base);\r\n  }\r\n\r\n  return {left, top, right, bottom};\r\n}\r\n\r\nfunction skipOrLimit(skip, value, min, max) {\r\n  return skip ? 0 : _limitValue(value, min, max);\r\n}\r\n\r\nfunction parseBorderWidth(bar, maxW, maxH) {\r\n  const value = bar.options.borderWidth;\r\n  const skip = bar.borderSkipped;\r\n  const o = toTRBL(value);\r\n\r\n  return {\r\n    t: skipOrLimit(skip.top, o.top, 0, maxH),\r\n    r: skipOrLimit(skip.right, o.right, 0, maxW),\r\n    b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\r\n    l: skipOrLimit(skip.left, o.left, 0, maxW)\r\n  };\r\n}\r\n\r\nfunction parseBorderRadius(bar, maxW, maxH) {\r\n  const {enableBorderRadius} = bar.getProps(['enableBorderRadius']);\r\n  const value = bar.options.borderRadius;\r\n  const o = toTRBLCorners(value);\r\n  const maxR = Math.min(maxW, maxH);\r\n  const skip = bar.borderSkipped;\r\n\r\n  // If the value is an object, assume the user knows what they are doing\r\n  // and apply as directed.\r\n  const enableBorder = enableBorderRadius || isObject(value);\r\n\r\n  return {\r\n    topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\r\n    topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\r\n    bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\r\n    bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\r\n  };\r\n}\r\n\r\nfunction boundingRects(bar) {\r\n  const bounds = getBarBounds(bar);\r\n  const width = bounds.right - bounds.left;\r\n  const height = bounds.bottom - bounds.top;\r\n  const border = parseBorderWidth(bar, width / 2, height / 2);\r\n  const radius = parseBorderRadius(bar, width / 2, height / 2);\r\n\r\n  return {\r\n    outer: {\r\n      x: bounds.left,\r\n      y: bounds.top,\r\n      w: width,\r\n      h: height,\r\n      radius\r\n    },\r\n    inner: {\r\n      x: bounds.left + border.l,\r\n      y: bounds.top + border.t,\r\n      w: width - border.l - border.r,\r\n      h: height - border.t - border.b,\r\n      radius: {\r\n        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\r\n        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\r\n        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\r\n        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r)),\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\nfunction inRange(bar, x, y, useFinalPosition) {\r\n  const skipX = x === null;\r\n  const skipY = y === null;\r\n  const skipBoth = skipX && skipY;\r\n  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\r\n\r\n  return bounds\r\n\t\t&& (skipX || _isBetween(x, bounds.left, bounds.right))\r\n\t\t&& (skipY || _isBetween(y, bounds.top, bounds.bottom));\r\n}\r\n\r\nfunction hasRadius(radius) {\r\n  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\r\n}\r\n\r\n/**\r\n * Add a path of a rectangle to the current sub-path\r\n * @param {CanvasRenderingContext2D} ctx Context\r\n * @param {*} rect Bounding rect\r\n */\r\nfunction addNormalRectPath(ctx, rect) {\r\n  ctx.rect(rect.x, rect.y, rect.w, rect.h);\r\n}\r\n\r\nfunction inflateRect(rect, amount, refRect = {}) {\r\n  const x = rect.x !== refRect.x ? -amount : 0;\r\n  const y = rect.y !== refRect.y ? -amount : 0;\r\n  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\r\n  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\r\n  return {\r\n    x: rect.x + x,\r\n    y: rect.y + y,\r\n    w: rect.w + w,\r\n    h: rect.h + h,\r\n    radius: rect.radius\r\n  };\r\n}\r\n\r\nexport default class BarElement extends Element {\r\n\r\n  static id = 'bar';\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = {\r\n    borderSkipped: 'start',\r\n    borderWidth: 0,\r\n    borderRadius: 0,\r\n    inflateAmount: 'auto',\r\n    pointStyle: undefined\r\n  };\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaultRoutes = {\r\n    backgroundColor: 'backgroundColor',\r\n    borderColor: 'borderColor'\r\n  };\r\n\r\n  constructor(cfg) {\r\n    super();\r\n\r\n    this.options = undefined;\r\n    this.horizontal = undefined;\r\n    this.base = undefined;\r\n    this.width = undefined;\r\n    this.height = undefined;\r\n    this.inflateAmount = undefined;\r\n\r\n    if (cfg) {\r\n      Object.assign(this, cfg);\r\n    }\r\n  }\r\n\r\n  draw(ctx) {\r\n    const {inflateAmount, options: {borderColor, backgroundColor}} = this;\r\n    const {inner, outer} = boundingRects(this);\r\n    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;\r\n\r\n    ctx.save();\r\n\r\n    if (outer.w !== inner.w || outer.h !== inner.h) {\r\n      ctx.beginPath();\r\n      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\r\n      ctx.clip();\r\n      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\r\n      ctx.fillStyle = borderColor;\r\n      ctx.fill('evenodd');\r\n    }\r\n\r\n    ctx.beginPath();\r\n    addRectPath(ctx, inflateRect(inner, inflateAmount));\r\n    ctx.fillStyle = backgroundColor;\r\n    ctx.fill();\r\n\r\n    ctx.restore();\r\n  }\r\n\r\n  inRange(mouseX, mouseY, useFinalPosition) {\r\n    return inRange(this, mouseX, mouseY, useFinalPosition);\r\n  }\r\n\r\n  inXRange(mouseX, useFinalPosition) {\r\n    return inRange(this, mouseX, null, useFinalPosition);\r\n  }\r\n\r\n  inYRange(mouseY, useFinalPosition) {\r\n    return inRange(this, null, mouseY, useFinalPosition);\r\n  }\r\n\r\n  getCenterPoint(useFinalPosition) {\r\n    const {x, y, base, horizontal} = /** @type {BarProps} */ (this.getProps(['x', 'y', 'base', 'horizontal'], useFinalPosition));\r\n    return {\r\n      x: horizontal ? (x + base) / 2 : x,\r\n      y: horizontal ? y : (y + base) / 2\r\n    };\r\n  }\r\n\r\n  getRange(axis) {\r\n    return axis === 'x' ? this.width / 2 : this.height / 2;\r\n  }\r\n}\r\n","import {DoughnutController, PolarAreaController} from '../index.js';\r\nimport type {Chart, ChartDataset} from '../types.js';\r\n\r\nexport interface ColorsPluginOptions {\r\n  enabled?: boolean;\r\n  forceOverride?: boolean;\r\n}\r\n\r\ninterface ColorsDescriptor {\r\n  backgroundColor?: unknown;\r\n  borderColor?: unknown;\r\n}\r\n\r\nconst BORDER_COLORS = [\r\n  'rgb(54, 162, 235)', // blue\r\n  'rgb(255, 99, 132)', // red\r\n  'rgb(255, 159, 64)', // orange\r\n  'rgb(255, 205, 86)', // yellow\r\n  'rgb(75, 192, 192)', // green\r\n  'rgb(153, 102, 255)', // purple\r\n  'rgb(201, 203, 207)' // grey\r\n];\r\n\r\n// Border colors with 50% transparency\r\nconst BACKGROUND_COLORS = /* #__PURE__ */ BORDER_COLORS.map(color => color.replace('rgb(', 'rgba(').replace(')', ', 0.5)'));\r\n\r\nfunction getBorderColor(i: number) {\r\n  return BORDER_COLORS[i % BORDER_COLORS.length];\r\n}\r\n\r\nfunction getBackgroundColor(i: number) {\r\n  return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];\r\n}\r\n\r\nfunction colorizeDefaultDataset(dataset: ChartDataset, i: number) {\r\n  dataset.borderColor = getBorderColor(i);\r\n  dataset.backgroundColor = getBackgroundColor(i);\r\n\r\n  return ++i;\r\n}\r\n\r\nfunction colorizeDoughnutDataset(dataset: ChartDataset, i: number) {\r\n  dataset.backgroundColor = dataset.data.map(() => getBorderColor(i++));\r\n\r\n  return i;\r\n}\r\n\r\nfunction colorizePolarAreaDataset(dataset: ChartDataset, i: number) {\r\n  dataset.backgroundColor = dataset.data.map(() => getBackgroundColor(i++));\r\n\r\n  return i;\r\n}\r\n\r\nfunction getColorizer(chart: Chart) {\r\n  let i = 0;\r\n\r\n  return (dataset: ChartDataset, datasetIndex: number) => {\r\n    const controller = chart.getDatasetMeta(datasetIndex).controller;\r\n\r\n    if (controller instanceof DoughnutController) {\r\n      i = colorizeDoughnutDataset(dataset, i);\r\n    } else if (controller instanceof PolarAreaController) {\r\n      i = colorizePolarAreaDataset(dataset, i);\r\n    } else if (controller) {\r\n      i = colorizeDefaultDataset(dataset, i);\r\n    }\r\n  };\r\n}\r\n\r\nfunction containsColorsDefinitions(\r\n  descriptors: ColorsDescriptor[] | Record<string, ColorsDescriptor>\r\n) {\r\n  let k: number | string;\r\n\r\n  for (k in descriptors) {\r\n    if (descriptors[k].borderColor || descriptors[k].backgroundColor) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction containsColorsDefinition(\r\n  descriptor: ColorsDescriptor\r\n) {\r\n  return descriptor && (descriptor.borderColor || descriptor.backgroundColor);\r\n}\r\n\r\nexport default {\r\n  id: 'colors',\r\n\r\n  defaults: {\r\n    enabled: true,\r\n    forceOverride: false\r\n  } as ColorsPluginOptions,\r\n\r\n  beforeLayout(chart: Chart, _args, options: ColorsPluginOptions) {\r\n    if (!options.enabled) {\r\n      return;\r\n    }\r\n\r\n    const {\r\n      data: {datasets},\r\n      options: chartOptions\r\n    } = chart.config;\r\n    const {elements} = chartOptions;\r\n\r\n    if (!options.forceOverride && (containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || (elements && containsColorsDefinitions(elements)))) {\r\n      return;\r\n    }\r\n\r\n    const colorizer = getColorizer(chart);\r\n\r\n    datasets.forEach(colorizer);\r\n  }\r\n};\r\n","import {_limitValue, _lookupByKey, isNullOrUndef, resolve} from '../helpers/index.js';\r\n\r\nfunction lttbDecimation(data, start, count, availableWidth, options) {\r\n  /**\r\n   * Implementation of the Largest Triangle Three Buckets algorithm.\r\n   *\r\n   * This implementation is based on the original implementation by Sveinn Steinarsson\r\n   * in https://github.com/sveinn-steinarsson/flot-downsample/blob/master/jquery.flot.downsample.js\r\n   *\r\n   * The original implementation is MIT licensed.\r\n   */\r\n  const samples = options.samples || availableWidth;\r\n  // There are less points than the threshold, returning the whole array\r\n  if (samples >= count) {\r\n    return data.slice(start, start + count);\r\n  }\r\n\r\n  const decimated = [];\r\n\r\n  const bucketWidth = (count - 2) / (samples - 2);\r\n  let sampledIndex = 0;\r\n  const endIndex = start + count - 1;\r\n  // Starting from offset\r\n  let a = start;\r\n  let i, maxAreaPoint, maxArea, area, nextA;\r\n\r\n  decimated[sampledIndex++] = data[a];\r\n\r\n  for (i = 0; i < samples - 2; i++) {\r\n    let avgX = 0;\r\n    let avgY = 0;\r\n    let j;\r\n\r\n    // Adding offset\r\n    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;\r\n    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;\r\n    const avgRangeLength = avgRangeEnd - avgRangeStart;\r\n\r\n    for (j = avgRangeStart; j < avgRangeEnd; j++) {\r\n      avgX += data[j].x;\r\n      avgY += data[j].y;\r\n    }\r\n\r\n    avgX /= avgRangeLength;\r\n    avgY /= avgRangeLength;\r\n\r\n    // Adding offset\r\n    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;\r\n    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;\r\n    const {x: pointAx, y: pointAy} = data[a];\r\n\r\n    // Note that this is changed from the original algorithm which initializes these\r\n    // values to 1. The reason for this change is that if the area is small, nextA\r\n    // would never be set and thus a crash would occur in the next loop as `a` would become\r\n    // `undefined`. Since the area is always positive, but could be 0 in the case of a flat trace,\r\n    // initializing with a negative number is the correct solution.\r\n    maxArea = area = -1;\r\n\r\n    for (j = rangeOffs; j < rangeTo; j++) {\r\n      area = 0.5 * Math.abs(\r\n        (pointAx - avgX) * (data[j].y - pointAy) -\r\n        (pointAx - data[j].x) * (avgY - pointAy)\r\n      );\r\n\r\n      if (area > maxArea) {\r\n        maxArea = area;\r\n        maxAreaPoint = data[j];\r\n        nextA = j;\r\n      }\r\n    }\r\n\r\n    decimated[sampledIndex++] = maxAreaPoint;\r\n    a = nextA;\r\n  }\r\n\r\n  // Include the last point\r\n  decimated[sampledIndex++] = data[endIndex];\r\n\r\n  return decimated;\r\n}\r\n\r\nfunction minMaxDecimation(data, start, count, availableWidth) {\r\n  let avgX = 0;\r\n  let countX = 0;\r\n  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\r\n  const decimated = [];\r\n  const endIndex = start + count - 1;\r\n\r\n  const xMin = data[start].x;\r\n  const xMax = data[endIndex].x;\r\n  const dx = xMax - xMin;\r\n\r\n  for (i = start; i < start + count; ++i) {\r\n    point = data[i];\r\n    x = (point.x - xMin) / dx * availableWidth;\r\n    y = point.y;\r\n    const truncX = x | 0;\r\n\r\n    if (truncX === prevX) {\r\n      // Determine `minY` / `maxY` and `avgX` while we stay within same x-position\r\n      if (y < minY) {\r\n        minY = y;\r\n        minIndex = i;\r\n      } else if (y > maxY) {\r\n        maxY = y;\r\n        maxIndex = i;\r\n      }\r\n      // For first point in group, countX is `0`, so average will be `x` / 1.\r\n      // Use point.x here because we're computing the average data `x` value\r\n      avgX = (countX * avgX + point.x) / ++countX;\r\n    } else {\r\n      // Push up to 4 points, 3 for the last interval and the first point for this interval\r\n      const lastIndex = i - 1;\r\n\r\n      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {\r\n        // The interval is defined by 4 points: start, min, max, end.\r\n        // The starting point is already considered at this point, so we need to determine which\r\n        // of the other points to add. We need to sort these points to ensure the decimated data\r\n        // is still sorted and then ensure there are no duplicates.\r\n        const intermediateIndex1 = Math.min(minIndex, maxIndex);\r\n        const intermediateIndex2 = Math.max(minIndex, maxIndex);\r\n\r\n        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\r\n          decimated.push({\r\n            ...data[intermediateIndex1],\r\n            x: avgX,\r\n          });\r\n        }\r\n        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\r\n          decimated.push({\r\n            ...data[intermediateIndex2],\r\n            x: avgX\r\n          });\r\n        }\r\n      }\r\n\r\n      // lastIndex === startIndex will occur when a range has only 1 point which could\r\n      // happen with very uneven data\r\n      if (i > 0 && lastIndex !== startIndex) {\r\n        // Last point in the previous interval\r\n        decimated.push(data[lastIndex]);\r\n      }\r\n\r\n      // Start of the new interval\r\n      decimated.push(point);\r\n      prevX = truncX;\r\n      countX = 0;\r\n      minY = maxY = y;\r\n      minIndex = maxIndex = startIndex = i;\r\n    }\r\n  }\r\n\r\n  return decimated;\r\n}\r\n\r\nfunction cleanDecimatedDataset(dataset) {\r\n  if (dataset._decimated) {\r\n    const data = dataset._data;\r\n    delete dataset._decimated;\r\n    delete dataset._data;\r\n    Object.defineProperty(dataset, 'data', {\r\n      configurable: true,\r\n      enumerable: true,\r\n      writable: true,\r\n      value: data,\r\n    });\r\n  }\r\n}\r\n\r\nfunction cleanDecimatedData(chart) {\r\n  chart.data.datasets.forEach((dataset) => {\r\n    cleanDecimatedDataset(dataset);\r\n  });\r\n}\r\n\r\nfunction getStartAndCountOfVisiblePointsSimplified(meta, points) {\r\n  const pointCount = points.length;\r\n\r\n  let start = 0;\r\n  let count;\r\n\r\n  const {iScale} = meta;\r\n  const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\r\n\r\n  if (minDefined) {\r\n    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);\r\n  }\r\n  if (maxDefined) {\r\n    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;\r\n  } else {\r\n    count = pointCount - start;\r\n  }\r\n\r\n  return {start, count};\r\n}\r\n\r\nexport default {\r\n  id: 'decimation',\r\n\r\n  defaults: {\r\n    algorithm: 'min-max',\r\n    enabled: false,\r\n  },\r\n\r\n  beforeElementsUpdate: (chart, args, options) => {\r\n    if (!options.enabled) {\r\n      // The decimation plugin may have been previously enabled. Need to remove old `dataset._data` handlers\r\n      cleanDecimatedData(chart);\r\n      return;\r\n    }\r\n\r\n    // Assume the entire chart is available to show a few more points than needed\r\n    const availableWidth = chart.width;\r\n\r\n    chart.data.datasets.forEach((dataset, datasetIndex) => {\r\n      const {_data, indexAxis} = dataset;\r\n      const meta = chart.getDatasetMeta(datasetIndex);\r\n      const data = _data || dataset.data;\r\n\r\n      if (resolve([indexAxis, chart.options.indexAxis]) === 'y') {\r\n        // Decimation is only supported for lines that have an X indexAxis\r\n        return;\r\n      }\r\n\r\n      if (!meta.controller.supportsDecimation) {\r\n        // Only line datasets are supported\r\n        return;\r\n      }\r\n\r\n      const xAxis = chart.scales[meta.xAxisID];\r\n      if (xAxis.type !== 'linear' && xAxis.type !== 'time') {\r\n        // Only linear interpolation is supported\r\n        return;\r\n      }\r\n\r\n      if (chart.options.parsing) {\r\n        // Plugin only supports data that does not need parsing\r\n        return;\r\n      }\r\n\r\n      let {start, count} = getStartAndCountOfVisiblePointsSimplified(meta, data);\r\n      const threshold = options.threshold || 4 * availableWidth;\r\n      if (count <= threshold) {\r\n        // No decimation is required until we are above this threshold\r\n        cleanDecimatedDataset(dataset);\r\n        return;\r\n      }\r\n\r\n      if (isNullOrUndef(_data)) {\r\n        // First time we are seeing this dataset\r\n        // We override the 'data' property with a setter that stores the\r\n        // raw data in _data, but reads the decimated data from _decimated\r\n        dataset._data = data;\r\n        delete dataset.data;\r\n        Object.defineProperty(dataset, 'data', {\r\n          configurable: true,\r\n          enumerable: true,\r\n          get: function() {\r\n            return this._decimated;\r\n          },\r\n          set: function(d) {\r\n            this._data = d;\r\n          }\r\n        });\r\n      }\r\n\r\n      // Point the chart to the decimated data\r\n      let decimated;\r\n      switch (options.algorithm) {\r\n      case 'lttb':\r\n        decimated = lttbDecimation(data, start, count, availableWidth, options);\r\n        break;\r\n      case 'min-max':\r\n        decimated = minMaxDecimation(data, start, count, availableWidth);\r\n        break;\r\n      default:\r\n        throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);\r\n      }\r\n\r\n      dataset._decimated = decimated;\r\n    });\r\n  },\r\n\r\n  destroy(chart) {\r\n    cleanDecimatedData(chart);\r\n  }\r\n};\r\n","import {_boundSegment, _boundSegments, _normalizeAngle} from '../../helpers/index.js';\r\n\r\nexport function _segments(line, target, property) {\r\n  const segments = line.segments;\r\n  const points = line.points;\r\n  const tpoints = target.points;\r\n  const parts = [];\r\n\r\n  for (const segment of segments) {\r\n    let {start, end} = segment;\r\n    end = _findSegmentEnd(start, end, points);\r\n\r\n    const bounds = _getBounds(property, points[start], points[end], segment.loop);\r\n\r\n    if (!target.segments) {\r\n      // Special case for boundary not supporting `segments` (simpleArc)\r\n      // Bounds are provided as `target` for partial circle, or undefined for full circle\r\n      parts.push({\r\n        source: segment,\r\n        target: bounds,\r\n        start: points[start],\r\n        end: points[end]\r\n      });\r\n      continue;\r\n    }\r\n\r\n    // Get all segments from `target` that intersect the bounds of current segment of `line`\r\n    const targetSegments = _boundSegments(target, bounds);\r\n\r\n    for (const tgt of targetSegments) {\r\n      const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\r\n      const fillSources = _boundSegment(segment, points, subBounds);\r\n\r\n      for (const fillSource of fillSources) {\r\n        parts.push({\r\n          source: fillSource,\r\n          target: tgt,\r\n          start: {\r\n            [property]: _getEdge(bounds, subBounds, 'start', Math.max)\r\n          },\r\n          end: {\r\n            [property]: _getEdge(bounds, subBounds, 'end', Math.min)\r\n          }\r\n        });\r\n      }\r\n    }\r\n  }\r\n  return parts;\r\n}\r\n\r\nexport function _getBounds(property, first, last, loop) {\r\n  if (loop) {\r\n    return;\r\n  }\r\n  let start = first[property];\r\n  let end = last[property];\r\n\r\n  if (property === 'angle') {\r\n    start = _normalizeAngle(start);\r\n    end = _normalizeAngle(end);\r\n  }\r\n  return {property, start, end};\r\n}\r\n\r\nexport function _pointsFromSegments(boundary, line) {\r\n  const {x = null, y = null} = boundary || {};\r\n  const linePoints = line.points;\r\n  const points = [];\r\n  line.segments.forEach(({start, end}) => {\r\n    end = _findSegmentEnd(start, end, linePoints);\r\n    const first = linePoints[start];\r\n    const last = linePoints[end];\r\n    if (y !== null) {\r\n      points.push({x: first.x, y});\r\n      points.push({x: last.x, y});\r\n    } else if (x !== null) {\r\n      points.push({x, y: first.y});\r\n      points.push({x, y: last.y});\r\n    }\r\n  });\r\n  return points;\r\n}\r\n\r\nexport function _findSegmentEnd(start, end, points) {\r\n  for (;end > start; end--) {\r\n    const point = points[end];\r\n    if (!isNaN(point.x) && !isNaN(point.y)) {\r\n      break;\r\n    }\r\n  }\r\n  return end;\r\n}\r\n\r\nfunction _getEdge(a, b, prop, fn) {\r\n  if (a && b) {\r\n    return fn(a[prop], b[prop]);\r\n  }\r\n  return a ? a[prop] : b ? b[prop] : 0;\r\n}\r\n","/**\r\n * @typedef { import('../../core/core.controller.js').default } Chart\r\n * @typedef { import('../../core/core.scale.js').default } Scale\r\n * @typedef { import('../../elements/element.point.js').default } PointElement\r\n */\r\n\r\nimport {LineElement} from '../../elements/index.js';\r\nimport {isArray} from '../../helpers/index.js';\r\nimport {_pointsFromSegments} from './filler.segment.js';\r\n\r\n/**\r\n * @param {PointElement[] | { x: number; y: number; }} boundary\r\n * @param {LineElement} line\r\n * @return {LineElement?}\r\n */\r\nexport function _createBoundaryLine(boundary, line) {\r\n  let points = [];\r\n  let _loop = false;\r\n\r\n  if (isArray(boundary)) {\r\n    _loop = true;\r\n    // @ts-ignore\r\n    points = boundary;\r\n  } else {\r\n    points = _pointsFromSegments(boundary, line);\r\n  }\r\n\r\n  return points.length ? new LineElement({\r\n    points,\r\n    options: {tension: 0},\r\n    _loop,\r\n    _fullLoop: _loop\r\n  }) : null;\r\n}\r\n\r\nexport function _shouldApplyFill(source) {\r\n  return source && source.fill !== false;\r\n}\r\n","import {isObject, isFinite, valueOrDefault} from '../../helpers/helpers.core.js';\r\n\r\n/**\r\n * @typedef { import('../../core/core.scale.js').default } Scale\r\n * @typedef { import('../../elements/element.line.js').default } LineElement\r\n * @typedef { import('../../types/index.js').FillTarget } FillTarget\r\n * @typedef { import('../../types/index.js').ComplexFillTarget } ComplexFillTarget\r\n */\r\n\r\nexport function _resolveTarget(sources, index, propagate) {\r\n  const source = sources[index];\r\n  let fill = source.fill;\r\n  const visited = [index];\r\n  let target;\r\n\r\n  if (!propagate) {\r\n    return fill;\r\n  }\r\n\r\n  while (fill !== false && visited.indexOf(fill) === -1) {\r\n    if (!isFinite(fill)) {\r\n      return fill;\r\n    }\r\n\r\n    target = sources[fill];\r\n    if (!target) {\r\n      return false;\r\n    }\r\n\r\n    if (target.visible) {\r\n      return fill;\r\n    }\r\n\r\n    visited.push(fill);\r\n    fill = target.fill;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * @param {LineElement} line\r\n * @param {number} index\r\n * @param {number} count\r\n */\r\nexport function _decodeFill(line, index, count) {\r\n  /** @type {string | {value: number}} */\r\n  const fill = parseFillOption(line);\r\n\r\n  if (isObject(fill)) {\r\n    return isNaN(fill.value) ? false : fill;\r\n  }\r\n\r\n  let target = parseFloat(fill);\r\n\r\n  if (isFinite(target) && Math.floor(target) === target) {\r\n    return decodeTargetIndex(fill[0], index, target, count);\r\n  }\r\n\r\n  return ['origin', 'start', 'end', 'stack', 'shape'].indexOf(fill) >= 0 && fill;\r\n}\r\n\r\nfunction decodeTargetIndex(firstCh, index, target, count) {\r\n  if (firstCh === '-' || firstCh === '+') {\r\n    target = index + target;\r\n  }\r\n\r\n  if (target === index || target < 0 || target >= count) {\r\n    return false;\r\n  }\r\n\r\n  return target;\r\n}\r\n\r\n/**\r\n * @param {FillTarget | ComplexFillTarget} fill\r\n * @param {Scale} scale\r\n * @returns {number | null}\r\n */\r\nexport function _getTargetPixel(fill, scale) {\r\n  let pixel = null;\r\n  if (fill === 'start') {\r\n    pixel = scale.bottom;\r\n  } else if (fill === 'end') {\r\n    pixel = scale.top;\r\n  } else if (isObject(fill)) {\r\n    // @ts-ignore\r\n    pixel = scale.getPixelForValue(fill.value);\r\n  } else if (scale.getBasePixel) {\r\n    pixel = scale.getBasePixel();\r\n  }\r\n  return pixel;\r\n}\r\n\r\n/**\r\n * @param {FillTarget | ComplexFillTarget} fill\r\n * @param {Scale} scale\r\n * @param {number} startValue\r\n * @returns {number | undefined}\r\n */\r\nexport function _getTargetValue(fill, scale, startValue) {\r\n  let value;\r\n\r\n  if (fill === 'start') {\r\n    value = startValue;\r\n  } else if (fill === 'end') {\r\n    value = scale.options.reverse ? scale.min : scale.max;\r\n  } else if (isObject(fill)) {\r\n    // @ts-ignore\r\n    value = fill.value;\r\n  } else {\r\n    value = scale.getBaseValue();\r\n  }\r\n  return value;\r\n}\r\n\r\n/**\r\n * @param {LineElement} line\r\n */\r\nfunction parseFillOption(line) {\r\n  const options = line.options;\r\n  const fillOption = options.fill;\r\n  let fill = valueOrDefault(fillOption && fillOption.target, fillOption);\r\n\r\n  if (fill === undefined) {\r\n    fill = !!options.backgroundColor;\r\n  }\r\n\r\n  if (fill === false || fill === null) {\r\n    return false;\r\n  }\r\n\r\n  if (fill === true) {\r\n    return 'origin';\r\n  }\r\n  return fill;\r\n}\r\n","/**\r\n * @typedef { import('../../core/core.controller.js').default } Chart\r\n * @typedef { import('../../core/core.scale.js').default } Scale\r\n * @typedef { import('../../elements/element.point.js').default } PointElement\r\n */\r\n\r\nimport {LineElement} from '../../elements/index.js';\r\nimport {_isBetween} from '../../helpers/index.js';\r\nimport {_createBoundaryLine} from './filler.helper.js';\r\n\r\n/**\r\n * @param {{ chart: Chart; scale: Scale; index: number; line: LineElement; }} source\r\n * @return {LineElement}\r\n */\r\nexport function _buildStackLine(source) {\r\n  const {scale, index, line} = source;\r\n  const points = [];\r\n  const segments = line.segments;\r\n  const sourcePoints = line.points;\r\n  const linesBelow = getLinesBelow(scale, index);\r\n  linesBelow.push(_createBoundaryLine({x: null, y: scale.bottom}, line));\r\n\r\n  for (let i = 0; i < segments.length; i++) {\r\n    const segment = segments[i];\r\n    for (let j = segment.start; j <= segment.end; j++) {\r\n      addPointsBelow(points, sourcePoints[j], linesBelow);\r\n    }\r\n  }\r\n  return new LineElement({points, options: {}});\r\n}\r\n\r\n/**\r\n * @param {Scale} scale\r\n * @param {number} index\r\n * @return {LineElement[]}\r\n */\r\nfunction getLinesBelow(scale, index) {\r\n  const below = [];\r\n  const metas = scale.getMatchingVisibleMetas('line');\r\n\r\n  for (let i = 0; i < metas.length; i++) {\r\n    const meta = metas[i];\r\n    if (meta.index === index) {\r\n      break;\r\n    }\r\n    if (!meta.hidden) {\r\n      below.unshift(meta.dataset);\r\n    }\r\n  }\r\n  return below;\r\n}\r\n\r\n/**\r\n * @param {PointElement[]} points\r\n * @param {PointElement} sourcePoint\r\n * @param {LineElement[]} linesBelow\r\n */\r\nfunction addPointsBelow(points, sourcePoint, linesBelow) {\r\n  const postponed = [];\r\n  for (let j = 0; j < linesBelow.length; j++) {\r\n    const line = linesBelow[j];\r\n    const {first, last, point} = findPoint(line, sourcePoint, 'x');\r\n\r\n    if (!point || (first && last)) {\r\n      continue;\r\n    }\r\n    if (first) {\r\n      // First point of an segment -> need to add another point before this,\r\n      // from next line below.\r\n      postponed.unshift(point);\r\n    } else {\r\n      points.push(point);\r\n      if (!last) {\r\n        // In the middle of an segment, no need to add more points.\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  points.push(...postponed);\r\n}\r\n\r\n/**\r\n * @param {LineElement} line\r\n * @param {PointElement} sourcePoint\r\n * @param {string} property\r\n * @returns {{point?: PointElement, first?: boolean, last?: boolean}}\r\n */\r\nfunction findPoint(line, sourcePoint, property) {\r\n  const point = line.interpolate(sourcePoint, property);\r\n  if (!point) {\r\n    return {};\r\n  }\r\n\r\n  const pointValue = point[property];\r\n  const segments = line.segments;\r\n  const linePoints = line.points;\r\n  let first = false;\r\n  let last = false;\r\n  for (let i = 0; i < segments.length; i++) {\r\n    const segment = segments[i];\r\n    const firstValue = linePoints[segment.start][property];\r\n    const lastValue = linePoints[segment.end][property];\r\n    if (_isBetween(pointValue, firstValue, lastValue)) {\r\n      first = pointValue === firstValue;\r\n      last = pointValue === lastValue;\r\n      break;\r\n    }\r\n  }\r\n  return {first, last, point};\r\n}\r\n","import {TAU} from '../../helpers/index.js';\r\n\r\n// TODO: use elements.ArcElement instead\r\nexport class simpleArc {\r\n  constructor(opts) {\r\n    this.x = opts.x;\r\n    this.y = opts.y;\r\n    this.radius = opts.radius;\r\n  }\r\n\r\n  pathSegment(ctx, bounds, opts) {\r\n    const {x, y, radius} = this;\r\n    bounds = bounds || {start: 0, end: TAU};\r\n    ctx.arc(x, y, radius, bounds.end, bounds.start, true);\r\n    return !opts.bounds;\r\n  }\r\n\r\n  interpolate(point) {\r\n    const {x, y, radius} = this;\r\n    const angle = point.angle;\r\n    return {\r\n      x: x + Math.cos(angle) * radius,\r\n      y: y + Math.sin(angle) * radius,\r\n      angle\r\n    };\r\n  }\r\n}\r\n","import {isFinite} from '../../helpers/index.js';\r\nimport {_createBoundaryLine} from './filler.helper.js';\r\nimport {_getTargetPixel, _getTargetValue} from './filler.options.js';\r\nimport {_buildStackLine} from './filler.target.stack.js';\r\nimport {simpleArc} from './simpleArc.js';\r\n\r\n/**\r\n * @typedef { import('../../core/core.controller.js').default } Chart\r\n * @typedef { import('../../core/core.scale.js').default } Scale\r\n * @typedef { import('../../elements/element.point.js').default } PointElement\r\n */\r\n\r\nexport function _getTarget(source) {\r\n  const {chart, fill, line} = source;\r\n\r\n  if (isFinite(fill)) {\r\n    return getLineByIndex(chart, fill);\r\n  }\r\n\r\n  if (fill === 'stack') {\r\n    return _buildStackLine(source);\r\n  }\r\n\r\n  if (fill === 'shape') {\r\n    return true;\r\n  }\r\n\r\n  const boundary = computeBoundary(source);\r\n\r\n  if (boundary instanceof simpleArc) {\r\n    return boundary;\r\n  }\r\n\r\n  return _createBoundaryLine(boundary, line);\r\n}\r\n\r\n/**\r\n * @param {Chart} chart\r\n * @param {number} index\r\n */\r\nfunction getLineByIndex(chart, index) {\r\n  const meta = chart.getDatasetMeta(index);\r\n  const visible = meta && chart.isDatasetVisible(index);\r\n  return visible ? meta.dataset : null;\r\n}\r\n\r\nfunction computeBoundary(source) {\r\n  const scale = source.scale || {};\r\n\r\n  if (scale.getPointPositionForValue) {\r\n    return computeCircularBoundary(source);\r\n  }\r\n  return computeLinearBoundary(source);\r\n}\r\n\r\n\r\nfunction computeLinearBoundary(source) {\r\n  const {scale = {}, fill} = source;\r\n  const pixel = _getTargetPixel(fill, scale);\r\n\r\n  if (isFinite(pixel)) {\r\n    const horizontal = scale.isHorizontal();\r\n\r\n    return {\r\n      x: horizontal ? pixel : null,\r\n      y: horizontal ? null : pixel\r\n    };\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction computeCircularBoundary(source) {\r\n  const {scale, fill} = source;\r\n  const options = scale.options;\r\n  const length = scale.getLabels().length;\r\n  const start = options.reverse ? scale.max : scale.min;\r\n  const value = _getTargetValue(fill, scale, start);\r\n  const target = [];\r\n\r\n  if (options.grid.circular) {\r\n    const center = scale.getPointPositionForValue(0, start);\r\n    return new simpleArc({\r\n      x: center.x,\r\n      y: center.y,\r\n      radius: scale.getDistanceFromCenterForValue(value)\r\n    });\r\n  }\r\n\r\n  for (let i = 0; i < length; ++i) {\r\n    target.push(scale.getPointPositionForValue(i, value));\r\n  }\r\n  return target;\r\n}\r\n\r\n","import {clipArea, unclipArea} from '../../helpers/index.js';\r\nimport {_findSegmentEnd, _getBounds, _segments} from './filler.segment.js';\r\nimport {_getTarget} from './filler.target.js';\r\n\r\nexport function _drawfill(ctx, source, area) {\r\n  const target = _getTarget(source);\r\n  const {line, scale, axis} = source;\r\n  const lineOpts = line.options;\r\n  const fillOption = lineOpts.fill;\r\n  const color = lineOpts.backgroundColor;\r\n  const {above = color, below = color} = fillOption || {};\r\n  if (target && line.points.length) {\r\n    clipArea(ctx, area);\r\n    doFill(ctx, {line, target, above, below, area, scale, axis});\r\n    unclipArea(ctx);\r\n  }\r\n}\r\n\r\nfunction doFill(ctx, cfg) {\r\n  const {line, target, above, below, area, scale} = cfg;\r\n  const property = line._loop ? 'angle' : cfg.axis;\r\n\r\n  ctx.save();\r\n\r\n  if (property === 'x' && below !== above) {\r\n    clipVertical(ctx, target, area.top);\r\n    fill(ctx, {line, target, color: above, scale, property});\r\n    ctx.restore();\r\n    ctx.save();\r\n    clipVertical(ctx, target, area.bottom);\r\n  }\r\n  fill(ctx, {line, target, color: below, scale, property});\r\n\r\n  ctx.restore();\r\n}\r\n\r\nfunction clipVertical(ctx, target, clipY) {\r\n  const {segments, points} = target;\r\n  let first = true;\r\n  let lineLoop = false;\r\n\r\n  ctx.beginPath();\r\n  for (const segment of segments) {\r\n    const {start, end} = segment;\r\n    const firstPoint = points[start];\r\n    const lastPoint = points[_findSegmentEnd(start, end, points)];\r\n    if (first) {\r\n      ctx.moveTo(firstPoint.x, firstPoint.y);\r\n      first = false;\r\n    } else {\r\n      ctx.lineTo(firstPoint.x, clipY);\r\n      ctx.lineTo(firstPoint.x, firstPoint.y);\r\n    }\r\n    lineLoop = !!target.pathSegment(ctx, segment, {move: lineLoop});\r\n    if (lineLoop) {\r\n      ctx.closePath();\r\n    } else {\r\n      ctx.lineTo(lastPoint.x, clipY);\r\n    }\r\n  }\r\n\r\n  ctx.lineTo(target.first().x, clipY);\r\n  ctx.closePath();\r\n  ctx.clip();\r\n}\r\n\r\nfunction fill(ctx, cfg) {\r\n  const {line, target, property, color, scale} = cfg;\r\n  const segments = _segments(line, target, property);\r\n\r\n  for (const {source: src, target: tgt, start, end} of segments) {\r\n    const {style: {backgroundColor = color} = {}} = src;\r\n    const notShape = target !== true;\r\n\r\n    ctx.save();\r\n    ctx.fillStyle = backgroundColor;\r\n\r\n    clipBounds(ctx, scale, notShape && _getBounds(property, start, end));\r\n\r\n    ctx.beginPath();\r\n\r\n    const lineLoop = !!line.pathSegment(ctx, src);\r\n\r\n    let loop;\r\n    if (notShape) {\r\n      if (lineLoop) {\r\n        ctx.closePath();\r\n      } else {\r\n        interpolatedLineTo(ctx, target, end, property);\r\n      }\r\n\r\n      const targetLoop = !!target.pathSegment(ctx, tgt, {move: lineLoop, reverse: true});\r\n      loop = lineLoop && targetLoop;\r\n      if (!loop) {\r\n        interpolatedLineTo(ctx, target, start, property);\r\n      }\r\n    }\r\n\r\n    ctx.closePath();\r\n    ctx.fill(loop ? 'evenodd' : 'nonzero');\r\n\r\n    ctx.restore();\r\n  }\r\n}\r\n\r\nfunction clipBounds(ctx, scale, bounds) {\r\n  const {top, bottom} = scale.chart.chartArea;\r\n  const {property, start, end} = bounds || {};\r\n  if (property === 'x') {\r\n    ctx.beginPath();\r\n    ctx.rect(start, top, end - start, bottom - top);\r\n    ctx.clip();\r\n  }\r\n}\r\n\r\nfunction interpolatedLineTo(ctx, target, point, property) {\r\n  const interpolatedPoint = target.interpolate(point, property);\r\n  if (interpolatedPoint) {\r\n    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\r\n  }\r\n}\r\n\r\n","/**\r\n * Plugin based on discussion from the following Chart.js issues:\r\n * @see https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569\r\n * @see https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897\r\n */\r\n\r\nimport LineElement from '../../elements/element.line.js';\r\nimport {_drawfill} from './filler.drawing.js';\r\nimport {_shouldApplyFill} from './filler.helper.js';\r\nimport {_decodeFill, _resolveTarget} from './filler.options.js';\r\n\r\nexport default {\r\n  id: 'filler',\r\n\r\n  afterDatasetsUpdate(chart, _args, options) {\r\n    const count = (chart.data.datasets || []).length;\r\n    const sources = [];\r\n    let meta, i, line, source;\r\n\r\n    for (i = 0; i < count; ++i) {\r\n      meta = chart.getDatasetMeta(i);\r\n      line = meta.dataset;\r\n      source = null;\r\n\r\n      if (line && line.options && line instanceof LineElement) {\r\n        source = {\r\n          visible: chart.isDatasetVisible(i),\r\n          index: i,\r\n          fill: _decodeFill(line, i, count),\r\n          chart,\r\n          axis: meta.controller.options.indexAxis,\r\n          scale: meta.vScale,\r\n          line,\r\n        };\r\n      }\r\n\r\n      meta.$filler = source;\r\n      sources.push(source);\r\n    }\r\n\r\n    for (i = 0; i < count; ++i) {\r\n      source = sources[i];\r\n      if (!source || source.fill === false) {\r\n        continue;\r\n      }\r\n\r\n      source.fill = _resolveTarget(sources, i, options.propagate);\r\n    }\r\n  },\r\n\r\n  beforeDraw(chart, _args, options) {\r\n    const draw = options.drawTime === 'beforeDraw';\r\n    const metasets = chart.getSortedVisibleDatasetMetas();\r\n    const area = chart.chartArea;\r\n    for (let i = metasets.length - 1; i >= 0; --i) {\r\n      const source = metasets[i].$filler;\r\n      if (!source) {\r\n        continue;\r\n      }\r\n\r\n      source.line.updateControlPoints(area, source.axis);\r\n      if (draw && source.fill) {\r\n        _drawfill(chart.ctx, source, area);\r\n      }\r\n    }\r\n  },\r\n\r\n  beforeDatasetsDraw(chart, _args, options) {\r\n    if (options.drawTime !== 'beforeDatasetsDraw') {\r\n      return;\r\n    }\r\n\r\n    const metasets = chart.getSortedVisibleDatasetMetas();\r\n    for (let i = metasets.length - 1; i >= 0; --i) {\r\n      const source = metasets[i].$filler;\r\n\r\n      if (_shouldApplyFill(source)) {\r\n        _drawfill(chart.ctx, source, chart.chartArea);\r\n      }\r\n    }\r\n  },\r\n\r\n  beforeDatasetDraw(chart, args, options) {\r\n    const source = args.meta.$filler;\r\n\r\n    if (!_shouldApplyFill(source) || options.drawTime !== 'beforeDatasetDraw') {\r\n      return;\r\n    }\r\n\r\n    _drawfill(chart.ctx, source, chart.chartArea);\r\n  },\r\n\r\n  defaults: {\r\n    propagate: true,\r\n    drawTime: 'beforeDatasetDraw'\r\n  }\r\n};\r\n","import defaults from '../core/core.defaults.js';\r\nimport Element from '../core/core.element.js';\r\nimport layouts from '../core/core.layouts.js';\r\nimport {addRoundedRectPath, drawPointLegend, renderText} from '../helpers/helpers.canvas.js';\r\nimport {\r\n  _isBetween,\r\n  callback as call,\r\n  clipArea,\r\n  getRtlAdapter,\r\n  overrideTextDirection,\r\n  restoreTextDirection,\r\n  toFont,\r\n  toPadding,\r\n  unclipArea,\r\n  valueOrDefault,\r\n} from '../helpers/index.js';\r\nimport {_alignStartEnd, _textX, _toLeftRightCenter} from '../helpers/helpers.extras.js';\r\nimport {toTRBLCorners} from '../helpers/helpers.options.js';\r\n\r\n/**\r\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\r\n */\r\n\r\nconst getBoxSize = (labelOpts, fontSize) => {\r\n  let {boxHeight = fontSize, boxWidth = fontSize} = labelOpts;\r\n\r\n  if (labelOpts.usePointStyle) {\r\n    boxHeight = Math.min(boxHeight, fontSize);\r\n    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);\r\n  }\r\n\r\n  return {\r\n    boxWidth,\r\n    boxHeight,\r\n    itemHeight: Math.max(fontSize, boxHeight)\r\n  };\r\n};\r\n\r\nconst itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\r\n\r\nexport class Legend extends Element {\r\n\r\n  /**\r\n\t * @param {{ ctx: any; options: any; chart: any; }} config\r\n\t */\r\n  constructor(config) {\r\n    super();\r\n\r\n    this._added = false;\r\n\r\n    // Contains hit boxes for each dataset (in dataset order)\r\n    this.legendHitBoxes = [];\r\n\r\n    /**\r\n \t\t * @private\r\n \t\t */\r\n    this._hoveredItem = null;\r\n\r\n    // Are we in doughnut mode which has a different data type\r\n    this.doughnutMode = false;\r\n\r\n    this.chart = config.chart;\r\n    this.options = config.options;\r\n    this.ctx = config.ctx;\r\n    this.legendItems = undefined;\r\n    this.columnSizes = undefined;\r\n    this.lineWidths = undefined;\r\n    this.maxHeight = undefined;\r\n    this.maxWidth = undefined;\r\n    this.top = undefined;\r\n    this.bottom = undefined;\r\n    this.left = undefined;\r\n    this.right = undefined;\r\n    this.height = undefined;\r\n    this.width = undefined;\r\n    this._margins = undefined;\r\n    this.position = undefined;\r\n    this.weight = undefined;\r\n    this.fullSize = undefined;\r\n  }\r\n\r\n  update(maxWidth, maxHeight, margins) {\r\n    this.maxWidth = maxWidth;\r\n    this.maxHeight = maxHeight;\r\n    this._margins = margins;\r\n\r\n    this.setDimensions();\r\n    this.buildLabels();\r\n    this.fit();\r\n  }\r\n\r\n  setDimensions() {\r\n    if (this.isHorizontal()) {\r\n      this.width = this.maxWidth;\r\n      this.left = this._margins.left;\r\n      this.right = this.width;\r\n    } else {\r\n      this.height = this.maxHeight;\r\n      this.top = this._margins.top;\r\n      this.bottom = this.height;\r\n    }\r\n  }\r\n\r\n  buildLabels() {\r\n    const labelOpts = this.options.labels || {};\r\n    let legendItems = call(labelOpts.generateLabels, [this.chart], this) || [];\r\n\r\n    if (labelOpts.filter) {\r\n      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));\r\n    }\r\n\r\n    if (labelOpts.sort) {\r\n      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));\r\n    }\r\n\r\n    if (this.options.reverse) {\r\n      legendItems.reverse();\r\n    }\r\n\r\n    this.legendItems = legendItems;\r\n  }\r\n\r\n  fit() {\r\n    const {options, ctx} = this;\r\n\r\n    // The legend may not be displayed for a variety of reasons including\r\n    // the fact that the defaults got set to `false`.\r\n    // When the legend is not displayed, there are no guarantees that the options\r\n    // are correctly formatted so we need to bail out as early as possible.\r\n    if (!options.display) {\r\n      this.width = this.height = 0;\r\n      return;\r\n    }\r\n\r\n    const labelOpts = options.labels;\r\n    const labelFont = toFont(labelOpts.font);\r\n    const fontSize = labelFont.size;\r\n    const titleHeight = this._computeTitleHeight();\r\n    const {boxWidth, itemHeight} = getBoxSize(labelOpts, fontSize);\r\n\r\n    let width, height;\r\n\r\n    ctx.font = labelFont.string;\r\n\r\n    if (this.isHorizontal()) {\r\n      width = this.maxWidth; // fill all the width\r\n      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\r\n    } else {\r\n      height = this.maxHeight; // fill all the height\r\n      width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;\r\n    }\r\n\r\n    this.width = Math.min(width, options.maxWidth || this.maxWidth);\r\n    this.height = Math.min(height, options.maxHeight || this.maxHeight);\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\r\n    const {ctx, maxWidth, options: {labels: {padding}}} = this;\r\n    const hitboxes = this.legendHitBoxes = [];\r\n    // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\r\n    const lineWidths = this.lineWidths = [0];\r\n    const lineHeight = itemHeight + padding;\r\n    let totalHeight = titleHeight;\r\n\r\n    ctx.textAlign = 'left';\r\n    ctx.textBaseline = 'middle';\r\n\r\n    let row = -1;\r\n    let top = -lineHeight;\r\n    this.legendItems.forEach((legendItem, i) => {\r\n      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\r\n\r\n      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\r\n        totalHeight += lineHeight;\r\n        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\r\n        top += lineHeight;\r\n        row++;\r\n      }\r\n\r\n      hitboxes[i] = {left: 0, top, row, width: itemWidth, height: itemHeight};\r\n\r\n      lineWidths[lineWidths.length - 1] += itemWidth + padding;\r\n    });\r\n\r\n    return totalHeight;\r\n  }\r\n\r\n  _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {\r\n    const {ctx, maxHeight, options: {labels: {padding}}} = this;\r\n    const hitboxes = this.legendHitBoxes = [];\r\n    const columnSizes = this.columnSizes = [];\r\n    const heightLimit = maxHeight - titleHeight;\r\n\r\n    let totalWidth = padding;\r\n    let currentColWidth = 0;\r\n    let currentColHeight = 0;\r\n\r\n    let left = 0;\r\n    let col = 0;\r\n\r\n    this.legendItems.forEach((legendItem, i) => {\r\n      const {itemWidth, itemHeight} = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);\r\n\r\n      // If too tall, go to new column\r\n      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\r\n        totalWidth += currentColWidth + padding;\r\n        columnSizes.push({width: currentColWidth, height: currentColHeight}); // previous column size\r\n        left += currentColWidth + padding;\r\n        col++;\r\n        currentColWidth = currentColHeight = 0;\r\n      }\r\n\r\n      // Store the hitbox width and height here. Final position will be updated in `draw`\r\n      hitboxes[i] = {left, top: currentColHeight, col, width: itemWidth, height: itemHeight};\r\n\r\n      // Get max width\r\n      currentColWidth = Math.max(currentColWidth, itemWidth);\r\n      currentColHeight += itemHeight + padding;\r\n    });\r\n\r\n    totalWidth += currentColWidth;\r\n    columnSizes.push({width: currentColWidth, height: currentColHeight}); // previous column size\r\n\r\n    return totalWidth;\r\n  }\r\n\r\n  adjustHitBoxes() {\r\n    if (!this.options.display) {\r\n      return;\r\n    }\r\n    const titleHeight = this._computeTitleHeight();\r\n    const {legendHitBoxes: hitboxes, options: {align, labels: {padding}, rtl}} = this;\r\n    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);\r\n    if (this.isHorizontal()) {\r\n      let row = 0;\r\n      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\r\n      for (const hitbox of hitboxes) {\r\n        if (row !== hitbox.row) {\r\n          row = hitbox.row;\r\n          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\r\n        }\r\n        hitbox.top += this.top + titleHeight + padding;\r\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\r\n        left += hitbox.width + padding;\r\n      }\r\n    } else {\r\n      let col = 0;\r\n      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\r\n      for (const hitbox of hitboxes) {\r\n        if (hitbox.col !== col) {\r\n          col = hitbox.col;\r\n          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\r\n        }\r\n        hitbox.top = top;\r\n        hitbox.left += this.left + padding;\r\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);\r\n        top += hitbox.height + padding;\r\n      }\r\n    }\r\n  }\r\n\r\n  isHorizontal() {\r\n    return this.options.position === 'top' || this.options.position === 'bottom';\r\n  }\r\n\r\n  draw() {\r\n    if (this.options.display) {\r\n      const ctx = this.ctx;\r\n      clipArea(ctx, this);\r\n\r\n      this._draw();\r\n\r\n      unclipArea(ctx);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _draw() {\r\n    const {options: opts, columnSizes, lineWidths, ctx} = this;\r\n    const {align, labels: labelOpts} = opts;\r\n    const defaultColor = defaults.color;\r\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\r\n    const labelFont = toFont(labelOpts.font);\r\n    const {padding} = labelOpts;\r\n    const fontSize = labelFont.size;\r\n    const halfFontSize = fontSize / 2;\r\n    let cursor;\r\n\r\n    this.drawTitle();\r\n\r\n    // Canvas setup\r\n    ctx.textAlign = rtlHelper.textAlign('left');\r\n    ctx.textBaseline = 'middle';\r\n    ctx.lineWidth = 0.5;\r\n    ctx.font = labelFont.string;\r\n\r\n    const {boxWidth, boxHeight, itemHeight} = getBoxSize(labelOpts, fontSize);\r\n\r\n    // current position\r\n    const drawLegendBox = function(x, y, legendItem) {\r\n      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\r\n        return;\r\n      }\r\n\r\n      // Set the ctx for the box\r\n      ctx.save();\r\n\r\n      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);\r\n      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\r\n      ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');\r\n      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);\r\n      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');\r\n      ctx.lineWidth = lineWidth;\r\n      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\r\n\r\n      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));\r\n\r\n      if (labelOpts.usePointStyle) {\r\n        // Recalculate x and y for drawPoint() because its expecting\r\n        // x and y to be center of figure (instead of top left)\r\n        const drawOptions = {\r\n          radius: boxHeight * Math.SQRT2 / 2,\r\n          pointStyle: legendItem.pointStyle,\r\n          rotation: legendItem.rotation,\r\n          borderWidth: lineWidth\r\n        };\r\n        const centerX = rtlHelper.xPlus(x, boxWidth / 2);\r\n        const centerY = y + halfFontSize;\r\n\r\n        // Draw pointStyle as legend symbol\r\n        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);\r\n      } else {\r\n        // Draw box as legend symbol\r\n        // Adjust position when boxHeight < fontSize (want it centered)\r\n        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\r\n        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\r\n        const borderRadius = toTRBLCorners(legendItem.borderRadius);\r\n\r\n        ctx.beginPath();\r\n\r\n        if (Object.values(borderRadius).some(v => v !== 0)) {\r\n          addRoundedRectPath(ctx, {\r\n            x: xBoxLeft,\r\n            y: yBoxTop,\r\n            w: boxWidth,\r\n            h: boxHeight,\r\n            radius: borderRadius,\r\n          });\r\n        } else {\r\n          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\r\n        }\r\n\r\n        ctx.fill();\r\n        if (lineWidth !== 0) {\r\n          ctx.stroke();\r\n        }\r\n      }\r\n\r\n      ctx.restore();\r\n    };\r\n\r\n    const fillText = function(x, y, legendItem) {\r\n      renderText(ctx, legendItem.text, x, y + (itemHeight / 2), labelFont, {\r\n        strikethrough: legendItem.hidden,\r\n        textAlign: rtlHelper.textAlign(legendItem.textAlign)\r\n      });\r\n    };\r\n\r\n    // Horizontal\r\n    const isHorizontal = this.isHorizontal();\r\n    const titleHeight = this._computeTitleHeight();\r\n    if (isHorizontal) {\r\n      cursor = {\r\n        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),\r\n        y: this.top + padding + titleHeight,\r\n        line: 0\r\n      };\r\n    } else {\r\n      cursor = {\r\n        x: this.left + padding,\r\n        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),\r\n        line: 0\r\n      };\r\n    }\r\n\r\n    overrideTextDirection(this.ctx, opts.textDirection);\r\n\r\n    const lineHeight = itemHeight + padding;\r\n    this.legendItems.forEach((legendItem, i) => {\r\n      ctx.strokeStyle = legendItem.fontColor; // for strikethrough effect\r\n      ctx.fillStyle = legendItem.fontColor; // render in correct colour\r\n\r\n      const textWidth = ctx.measureText(legendItem.text).width;\r\n      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\r\n      const width = boxWidth + halfFontSize + textWidth;\r\n      let x = cursor.x;\r\n      let y = cursor.y;\r\n\r\n      rtlHelper.setWidth(this.width);\r\n\r\n      if (isHorizontal) {\r\n        if (i > 0 && x + width + padding > this.right) {\r\n          y = cursor.y += lineHeight;\r\n          cursor.line++;\r\n          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);\r\n        }\r\n      } else if (i > 0 && y + lineHeight > this.bottom) {\r\n        x = cursor.x = x + columnSizes[cursor.line].width + padding;\r\n        cursor.line++;\r\n        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);\r\n      }\r\n\r\n      const realX = rtlHelper.x(x);\r\n\r\n      drawLegendBox(realX, y, legendItem);\r\n\r\n      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);\r\n\r\n      // Fill the actual label\r\n      fillText(rtlHelper.x(x), y, legendItem);\r\n\r\n      if (isHorizontal) {\r\n        cursor.x += width + padding;\r\n      } else if (typeof legendItem.text !== 'string') {\r\n        const fontLineHeight = labelFont.lineHeight;\r\n        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight);\r\n      } else {\r\n        cursor.y += lineHeight;\r\n      }\r\n    });\r\n\r\n    restoreTextDirection(this.ctx, opts.textDirection);\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  drawTitle() {\r\n    const opts = this.options;\r\n    const titleOpts = opts.title;\r\n    const titleFont = toFont(titleOpts.font);\r\n    const titlePadding = toPadding(titleOpts.padding);\r\n\r\n    if (!titleOpts.display) {\r\n      return;\r\n    }\r\n\r\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\r\n    const ctx = this.ctx;\r\n    const position = titleOpts.position;\r\n    const halfFontSize = titleFont.size / 2;\r\n    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\r\n    let y;\r\n\r\n    // These defaults are used when the legend is vertical.\r\n    // When horizontal, they are computed below.\r\n    let left = this.left;\r\n    let maxWidth = this.width;\r\n\r\n    if (this.isHorizontal()) {\r\n      // Move left / right so that the title is above the legend lines\r\n      maxWidth = Math.max(...this.lineWidths);\r\n      y = this.top + topPaddingPlusHalfFontSize;\r\n      left = _alignStartEnd(opts.align, left, this.right - maxWidth);\r\n    } else {\r\n      // Move down so that the title is above the legend stack in every alignment\r\n      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);\r\n      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());\r\n    }\r\n\r\n    // Now that we know the left edge of the inner legend box, compute the correct\r\n    // X coordinate from the title alignment\r\n    const x = _alignStartEnd(position, left, left + maxWidth);\r\n\r\n    // Canvas setup\r\n    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));\r\n    ctx.textBaseline = 'middle';\r\n    ctx.strokeStyle = titleOpts.color;\r\n    ctx.fillStyle = titleOpts.color;\r\n    ctx.font = titleFont.string;\r\n\r\n    renderText(ctx, titleOpts.text, x, y, titleFont);\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _computeTitleHeight() {\r\n    const titleOpts = this.options.title;\r\n    const titleFont = toFont(titleOpts.font);\r\n    const titlePadding = toPadding(titleOpts.padding);\r\n    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _getLegendItemAt(x, y) {\r\n    let i, hitBox, lh;\r\n\r\n    if (_isBetween(x, this.left, this.right)\r\n      && _isBetween(y, this.top, this.bottom)) {\r\n      // See if we are touching one of the dataset boxes\r\n      lh = this.legendHitBoxes;\r\n      for (i = 0; i < lh.length; ++i) {\r\n        hitBox = lh[i];\r\n\r\n        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width)\r\n          && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {\r\n          // Touching an element\r\n          return this.legendItems[i];\r\n        }\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n\t * Handle an event\r\n\t * @param {ChartEvent} e - The event to handle\r\n\t */\r\n  handleEvent(e) {\r\n    const opts = this.options;\r\n    if (!isListened(e.type, opts)) {\r\n      return;\r\n    }\r\n\r\n    // Chart event already has relative position in it\r\n    const hoveredItem = this._getLegendItemAt(e.x, e.y);\r\n\r\n    if (e.type === 'mousemove' || e.type === 'mouseout') {\r\n      const previous = this._hoveredItem;\r\n      const sameItem = itemsEqual(previous, hoveredItem);\r\n      if (previous && !sameItem) {\r\n        call(opts.onLeave, [e, previous, this], this);\r\n      }\r\n\r\n      this._hoveredItem = hoveredItem;\r\n\r\n      if (hoveredItem && !sameItem) {\r\n        call(opts.onHover, [e, hoveredItem, this], this);\r\n      }\r\n    } else if (hoveredItem) {\r\n      call(opts.onClick, [e, hoveredItem, this], this);\r\n    }\r\n  }\r\n}\r\n\r\nfunction calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {\r\n  const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);\r\n  const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);\r\n  return {itemWidth, itemHeight};\r\n}\r\n\r\nfunction calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {\r\n  let legendItemText = legendItem.text;\r\n  if (legendItemText && typeof legendItemText !== 'string') {\r\n    legendItemText = legendItemText.reduce((a, b) => a.length > b.length ? a : b);\r\n  }\r\n  return boxWidth + (labelFont.size / 2) + ctx.measureText(legendItemText).width;\r\n}\r\n\r\nfunction calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {\r\n  let itemHeight = _itemHeight;\r\n  if (typeof legendItem.text !== 'string') {\r\n    itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);\r\n  }\r\n  return itemHeight;\r\n}\r\n\r\nfunction calculateLegendItemHeight(legendItem, fontLineHeight) {\r\n  const labelHeight = legendItem.text ? legendItem.text.length + 0.5 : 0;\r\n  return fontLineHeight * labelHeight;\r\n}\r\n\r\nfunction isListened(type, opts) {\r\n  if ((type === 'mousemove' || type === 'mouseout') && (opts.onHover || opts.onLeave)) {\r\n    return true;\r\n  }\r\n  if (opts.onClick && (type === 'click' || type === 'mouseup')) {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nexport default {\r\n  id: 'legend',\r\n\r\n  /**\r\n\t * For tests\r\n\t * @private\r\n\t */\r\n  _element: Legend,\r\n\r\n  start(chart, _args, options) {\r\n    const legend = chart.legend = new Legend({ctx: chart.ctx, options, chart});\r\n    layouts.configure(chart, legend, options);\r\n    layouts.addBox(chart, legend);\r\n  },\r\n\r\n  stop(chart) {\r\n    layouts.removeBox(chart, chart.legend);\r\n    delete chart.legend;\r\n  },\r\n\r\n  // During the beforeUpdate step, the layout configuration needs to run\r\n  // This ensures that if the legend position changes (via an option update)\r\n  // the layout system respects the change. See https://github.com/chartjs/Chart.js/issues/7527\r\n  beforeUpdate(chart, _args, options) {\r\n    const legend = chart.legend;\r\n    layouts.configure(chart, legend, options);\r\n    legend.options = options;\r\n  },\r\n\r\n  // The labels need to be built after datasets are updated to ensure that colors\r\n  // and other styling are correct. See https://github.com/chartjs/Chart.js/issues/6968\r\n  afterUpdate(chart) {\r\n    const legend = chart.legend;\r\n    legend.buildLabels();\r\n    legend.adjustHitBoxes();\r\n  },\r\n\r\n\r\n  afterEvent(chart, args) {\r\n    if (!args.replay) {\r\n      chart.legend.handleEvent(args.event);\r\n    }\r\n  },\r\n\r\n  defaults: {\r\n    display: true,\r\n    position: 'top',\r\n    align: 'center',\r\n    fullSize: true,\r\n    reverse: false,\r\n    weight: 1000,\r\n\r\n    // a callback that will handle\r\n    onClick(e, legendItem, legend) {\r\n      const index = legendItem.datasetIndex;\r\n      const ci = legend.chart;\r\n      if (ci.isDatasetVisible(index)) {\r\n        ci.hide(index);\r\n        legendItem.hidden = true;\r\n      } else {\r\n        ci.show(index);\r\n        legendItem.hidden = false;\r\n      }\r\n    },\r\n\r\n    onHover: null,\r\n    onLeave: null,\r\n\r\n    labels: {\r\n      color: (ctx) => ctx.chart.options.color,\r\n      boxWidth: 40,\r\n      padding: 10,\r\n      // Generates labels shown in the legend\r\n      // Valid properties to return:\r\n      // text : text to display\r\n      // fillStyle : fill of coloured box\r\n      // strokeStyle: stroke of coloured box\r\n      // hidden : if this legend item refers to a hidden item\r\n      // lineCap : cap style for line\r\n      // lineDash\r\n      // lineDashOffset :\r\n      // lineJoin :\r\n      // lineWidth :\r\n      generateLabels(chart) {\r\n        const datasets = chart.data.datasets;\r\n        const {labels: {usePointStyle, pointStyle, textAlign, color, useBorderRadius, borderRadius}} = chart.legend.options;\r\n\r\n        return chart._getSortedDatasetMetas().map((meta) => {\r\n          const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\r\n          const borderWidth = toPadding(style.borderWidth);\r\n\r\n          return {\r\n            text: datasets[meta.index].label,\r\n            fillStyle: style.backgroundColor,\r\n            fontColor: color,\r\n            hidden: !meta.visible,\r\n            lineCap: style.borderCapStyle,\r\n            lineDash: style.borderDash,\r\n            lineDashOffset: style.borderDashOffset,\r\n            lineJoin: style.borderJoinStyle,\r\n            lineWidth: (borderWidth.width + borderWidth.height) / 4,\r\n            strokeStyle: style.borderColor,\r\n            pointStyle: pointStyle || style.pointStyle,\r\n            rotation: style.rotation,\r\n            textAlign: textAlign || style.textAlign,\r\n            borderRadius: useBorderRadius && (borderRadius || style.borderRadius),\r\n\r\n            // Below is extra data used for toggling the datasets\r\n            datasetIndex: meta.index\r\n          };\r\n        }, this);\r\n      }\r\n    },\r\n\r\n    title: {\r\n      color: (ctx) => ctx.chart.options.color,\r\n      display: false,\r\n      position: 'center',\r\n      text: '',\r\n    }\r\n  },\r\n\r\n  descriptors: {\r\n    _scriptable: (name) => !name.startsWith('on'),\r\n    labels: {\r\n      _scriptable: (name) => !['generateLabels', 'filter', 'sort'].includes(name),\r\n    }\r\n  },\r\n};\r\n","import Element from '../core/core.element.js';\r\nimport layouts from '../core/core.layouts.js';\r\nimport {PI, isArray, toPadding, toFont} from '../helpers/index.js';\r\nimport {_toLeftRightCenter, _alignStartEnd} from '../helpers/helpers.extras.js';\r\nimport {renderText} from '../helpers/helpers.canvas.js';\r\n\r\nexport class Title extends Element {\r\n  /**\r\n\t * @param {{ ctx: any; options: any; chart: any; }} config\r\n\t */\r\n  constructor(config) {\r\n    super();\r\n\r\n    this.chart = config.chart;\r\n    this.options = config.options;\r\n    this.ctx = config.ctx;\r\n    this._padding = undefined;\r\n    this.top = undefined;\r\n    this.bottom = undefined;\r\n    this.left = undefined;\r\n    this.right = undefined;\r\n    this.width = undefined;\r\n    this.height = undefined;\r\n    this.position = undefined;\r\n    this.weight = undefined;\r\n    this.fullSize = undefined;\r\n  }\r\n\r\n  update(maxWidth, maxHeight) {\r\n    const opts = this.options;\r\n\r\n    this.left = 0;\r\n    this.top = 0;\r\n\r\n    if (!opts.display) {\r\n      this.width = this.height = this.right = this.bottom = 0;\r\n      return;\r\n    }\r\n\r\n    this.width = this.right = maxWidth;\r\n    this.height = this.bottom = maxHeight;\r\n\r\n    const lineCount = isArray(opts.text) ? opts.text.length : 1;\r\n    this._padding = toPadding(opts.padding);\r\n    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;\r\n\r\n    if (this.isHorizontal()) {\r\n      this.height = textSize;\r\n    } else {\r\n      this.width = textSize;\r\n    }\r\n  }\r\n\r\n  isHorizontal() {\r\n    const pos = this.options.position;\r\n    return pos === 'top' || pos === 'bottom';\r\n  }\r\n\r\n  _drawArgs(offset) {\r\n    const {top, left, bottom, right, options} = this;\r\n    const align = options.align;\r\n    let rotation = 0;\r\n    let maxWidth, titleX, titleY;\r\n\r\n    if (this.isHorizontal()) {\r\n      titleX = _alignStartEnd(align, left, right);\r\n      titleY = top + offset;\r\n      maxWidth = right - left;\r\n    } else {\r\n      if (options.position === 'left') {\r\n        titleX = left + offset;\r\n        titleY = _alignStartEnd(align, bottom, top);\r\n        rotation = PI * -0.5;\r\n      } else {\r\n        titleX = right - offset;\r\n        titleY = _alignStartEnd(align, top, bottom);\r\n        rotation = PI * 0.5;\r\n      }\r\n      maxWidth = bottom - top;\r\n    }\r\n    return {titleX, titleY, maxWidth, rotation};\r\n  }\r\n\r\n  draw() {\r\n    const ctx = this.ctx;\r\n    const opts = this.options;\r\n\r\n    if (!opts.display) {\r\n      return;\r\n    }\r\n\r\n    const fontOpts = toFont(opts.font);\r\n    const lineHeight = fontOpts.lineHeight;\r\n    const offset = lineHeight / 2 + this._padding.top;\r\n    const {titleX, titleY, maxWidth, rotation} = this._drawArgs(offset);\r\n\r\n    renderText(ctx, opts.text, 0, 0, fontOpts, {\r\n      color: opts.color,\r\n      maxWidth,\r\n      rotation,\r\n      textAlign: _toLeftRightCenter(opts.align),\r\n      textBaseline: 'middle',\r\n      translation: [titleX, titleY],\r\n    });\r\n  }\r\n}\r\n\r\nfunction createTitle(chart, titleOpts) {\r\n  const title = new Title({\r\n    ctx: chart.ctx,\r\n    options: titleOpts,\r\n    chart\r\n  });\r\n\r\n  layouts.configure(chart, title, titleOpts);\r\n  layouts.addBox(chart, title);\r\n  chart.titleBlock = title;\r\n}\r\n\r\nexport default {\r\n  id: 'title',\r\n\r\n  /**\r\n\t * For tests\r\n\t * @private\r\n\t */\r\n  _element: Title,\r\n\r\n  start(chart, _args, options) {\r\n    createTitle(chart, options);\r\n  },\r\n\r\n  stop(chart) {\r\n    const titleBlock = chart.titleBlock;\r\n    layouts.removeBox(chart, titleBlock);\r\n    delete chart.titleBlock;\r\n  },\r\n\r\n  beforeUpdate(chart, _args, options) {\r\n    const title = chart.titleBlock;\r\n    layouts.configure(chart, title, options);\r\n    title.options = options;\r\n  },\r\n\r\n  defaults: {\r\n    align: 'center',\r\n    display: false,\r\n    font: {\r\n      weight: 'bold',\r\n    },\r\n    fullSize: true,\r\n    padding: 10,\r\n    position: 'top',\r\n    text: '',\r\n    weight: 2000         // by default greater than legend (1000) to be above\r\n  },\r\n\r\n  defaultRoutes: {\r\n    color: 'color'\r\n  },\r\n\r\n  descriptors: {\r\n    _scriptable: true,\r\n    _indexable: false,\r\n  },\r\n};\r\n","import {Title} from './plugin.title.js';\r\nimport layouts from '../core/core.layouts.js';\r\n\r\nconst map = new WeakMap();\r\n\r\nexport default {\r\n  id: 'subtitle',\r\n\r\n  start(chart, _args, options) {\r\n    const title = new Title({\r\n      ctx: chart.ctx,\r\n      options,\r\n      chart\r\n    });\r\n\r\n    layouts.configure(chart, title, options);\r\n    layouts.addBox(chart, title);\r\n    map.set(chart, title);\r\n  },\r\n\r\n  stop(chart) {\r\n    layouts.removeBox(chart, map.get(chart));\r\n    map.delete(chart);\r\n  },\r\n\r\n  beforeUpdate(chart, _args, options) {\r\n    const title = map.get(chart);\r\n    layouts.configure(chart, title, options);\r\n    title.options = options;\r\n  },\r\n\r\n  defaults: {\r\n    align: 'center',\r\n    display: false,\r\n    font: {\r\n      weight: 'normal',\r\n    },\r\n    fullSize: true,\r\n    padding: 0,\r\n    position: 'top',\r\n    text: '',\r\n    weight: 1500         // by default greater than legend (1000) and smaller than title (2000)\r\n  },\r\n\r\n  defaultRoutes: {\r\n    color: 'color'\r\n  },\r\n\r\n  descriptors: {\r\n    _scriptable: true,\r\n    _indexable: false,\r\n  },\r\n};\r\n","import Animations from '../core/core.animations.js';\r\nimport Element from '../core/core.element.js';\r\nimport {addRoundedRectPath} from '../helpers/helpers.canvas.js';\r\nimport {each, noop, isNullOrUndef, isArray, _elementsEqual, isObject} from '../helpers/helpers.core.js';\r\nimport {toFont, toPadding, toTRBLCorners} from '../helpers/helpers.options.js';\r\nimport {getRtlAdapter, overrideTextDirection, restoreTextDirection} from '../helpers/helpers.rtl.js';\r\nimport {distanceBetweenPoints, _limitValue} from '../helpers/helpers.math.js';\r\nimport {createContext, drawPoint} from '../helpers/index.js';\r\n\r\n/**\r\n * @typedef { import('../platform/platform.base.js').Chart } Chart\r\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\r\n * @typedef { import('../types/index.js').ActiveElement } ActiveElement\r\n * @typedef { import('../core/core.interaction.js').InteractionItem } InteractionItem\r\n */\r\n\r\nconst positioners = {\r\n  /**\r\n\t * Average mode places the tooltip at the average position of the elements shown\r\n\t */\r\n  average(items) {\r\n    if (!items.length) {\r\n      return false;\r\n    }\r\n\r\n    let i, len;\r\n    let x = 0;\r\n    let y = 0;\r\n    let count = 0;\r\n\r\n    for (i = 0, len = items.length; i < len; ++i) {\r\n      const el = items[i].element;\r\n      if (el && el.hasValue()) {\r\n        const pos = el.tooltipPosition();\r\n        x += pos.x;\r\n        y += pos.y;\r\n        ++count;\r\n      }\r\n    }\r\n\r\n    return {\r\n      x: x / count,\r\n      y: y / count\r\n    };\r\n  },\r\n\r\n  /**\r\n\t * Gets the tooltip position nearest of the item nearest to the event position\r\n\t */\r\n  nearest(items, eventPosition) {\r\n    if (!items.length) {\r\n      return false;\r\n    }\r\n\r\n    let x = eventPosition.x;\r\n    let y = eventPosition.y;\r\n    let minDistance = Number.POSITIVE_INFINITY;\r\n    let i, len, nearestElement;\r\n\r\n    for (i = 0, len = items.length; i < len; ++i) {\r\n      const el = items[i].element;\r\n      if (el && el.hasValue()) {\r\n        const center = el.getCenterPoint();\r\n        const d = distanceBetweenPoints(eventPosition, center);\r\n\r\n        if (d < minDistance) {\r\n          minDistance = d;\r\n          nearestElement = el;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (nearestElement) {\r\n      const tp = nearestElement.tooltipPosition();\r\n      x = tp.x;\r\n      y = tp.y;\r\n    }\r\n\r\n    return {\r\n      x,\r\n      y\r\n    };\r\n  }\r\n};\r\n\r\n// Helper to push or concat based on if the 2nd parameter is an array or not\r\nfunction pushOrConcat(base, toPush) {\r\n  if (toPush) {\r\n    if (isArray(toPush)) {\r\n      // base = base.concat(toPush);\r\n      Array.prototype.push.apply(base, toPush);\r\n    } else {\r\n      base.push(toPush);\r\n    }\r\n  }\r\n\r\n  return base;\r\n}\r\n\r\n/**\r\n * Returns array of strings split by newline\r\n * @param {*} str - The value to split by newline.\r\n * @returns {string|string[]} value if newline present - Returned from String split() method\r\n * @function\r\n */\r\nfunction splitNewlines(str) {\r\n  if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\r\n    return str.split('\\n');\r\n  }\r\n  return str;\r\n}\r\n\r\n\r\n/**\r\n * Private helper to create a tooltip item model\r\n * @param {Chart} chart\r\n * @param {ActiveElement} item - {element, index, datasetIndex} to create the tooltip item for\r\n * @return new tooltip item\r\n */\r\nfunction createTooltipItem(chart, item) {\r\n  const {element, datasetIndex, index} = item;\r\n  const controller = chart.getDatasetMeta(datasetIndex).controller;\r\n  const {label, value} = controller.getLabelAndValue(index);\r\n\r\n  return {\r\n    chart,\r\n    label,\r\n    parsed: controller.getParsed(index),\r\n    raw: chart.data.datasets[datasetIndex].data[index],\r\n    formattedValue: value,\r\n    dataset: controller.getDataset(),\r\n    dataIndex: index,\r\n    datasetIndex,\r\n    element\r\n  };\r\n}\r\n\r\n/**\r\n * Get the size of the tooltip\r\n */\r\nfunction getTooltipSize(tooltip, options) {\r\n  const ctx = tooltip.chart.ctx;\r\n  const {body, footer, title} = tooltip;\r\n  const {boxWidth, boxHeight} = options;\r\n  const bodyFont = toFont(options.bodyFont);\r\n  const titleFont = toFont(options.titleFont);\r\n  const footerFont = toFont(options.footerFont);\r\n  const titleLineCount = title.length;\r\n  const footerLineCount = footer.length;\r\n  const bodyLineItemCount = body.length;\r\n\r\n  const padding = toPadding(options.padding);\r\n  let height = padding.height;\r\n  let width = 0;\r\n\r\n  // Count of all lines in the body\r\n  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\r\n  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\r\n\r\n  if (titleLineCount) {\r\n    height += titleLineCount * titleFont.lineHeight\r\n\t\t\t+ (titleLineCount - 1) * options.titleSpacing\r\n\t\t\t+ options.titleMarginBottom;\r\n  }\r\n  if (combinedBodyLength) {\r\n    // Body lines may include some extra height depending on boxHeight\r\n    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\r\n    height += bodyLineItemCount * bodyLineHeight\r\n\t\t\t+ (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight\r\n\t\t\t+ (combinedBodyLength - 1) * options.bodySpacing;\r\n  }\r\n  if (footerLineCount) {\r\n    height += options.footerMarginTop\r\n\t\t\t+ footerLineCount * footerFont.lineHeight\r\n\t\t\t+ (footerLineCount - 1) * options.footerSpacing;\r\n  }\r\n\r\n  // Title width\r\n  let widthPadding = 0;\r\n  const maxLineWidth = function(line) {\r\n    width = Math.max(width, ctx.measureText(line).width + widthPadding);\r\n  };\r\n\r\n  ctx.save();\r\n\r\n  ctx.font = titleFont.string;\r\n  each(tooltip.title, maxLineWidth);\r\n\r\n  // Body width\r\n  ctx.font = bodyFont.string;\r\n  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\r\n\r\n  // Body lines may include some extra width due to the color box\r\n  widthPadding = options.displayColors ? (boxWidth + 2 + options.boxPadding) : 0;\r\n  each(body, (bodyItem) => {\r\n    each(bodyItem.before, maxLineWidth);\r\n    each(bodyItem.lines, maxLineWidth);\r\n    each(bodyItem.after, maxLineWidth);\r\n  });\r\n\r\n  // Reset back to 0\r\n  widthPadding = 0;\r\n\r\n  // Footer width\r\n  ctx.font = footerFont.string;\r\n  each(tooltip.footer, maxLineWidth);\r\n\r\n  ctx.restore();\r\n\r\n  // Add padding\r\n  width += padding.width;\r\n\r\n  return {width, height};\r\n}\r\n\r\nfunction determineYAlign(chart, size) {\r\n  const {y, height} = size;\r\n\r\n  if (y < height / 2) {\r\n    return 'top';\r\n  } else if (y > (chart.height - height / 2)) {\r\n    return 'bottom';\r\n  }\r\n  return 'center';\r\n}\r\n\r\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\r\n  const {x, width} = size;\r\n  const caret = options.caretSize + options.caretPadding;\r\n  if (xAlign === 'left' && x + width + caret > chart.width) {\r\n    return true;\r\n  }\r\n\r\n  if (xAlign === 'right' && x - width - caret < 0) {\r\n    return true;\r\n  }\r\n}\r\n\r\nfunction determineXAlign(chart, options, size, yAlign) {\r\n  const {x, width} = size;\r\n  const {width: chartWidth, chartArea: {left, right}} = chart;\r\n  let xAlign = 'center';\r\n\r\n  if (yAlign === 'center') {\r\n    xAlign = x <= (left + right) / 2 ? 'left' : 'right';\r\n  } else if (x <= width / 2) {\r\n    xAlign = 'left';\r\n  } else if (x >= chartWidth - width / 2) {\r\n    xAlign = 'right';\r\n  }\r\n\r\n  if (doesNotFitWithAlign(xAlign, chart, options, size)) {\r\n    xAlign = 'center';\r\n  }\r\n\r\n  return xAlign;\r\n}\r\n\r\n/**\r\n * Helper to get the alignment of a tooltip given the size\r\n */\r\nfunction determineAlignment(chart, options, size) {\r\n  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);\r\n\r\n  return {\r\n    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),\r\n    yAlign\r\n  };\r\n}\r\n\r\nfunction alignX(size, xAlign) {\r\n  let {x, width} = size;\r\n  if (xAlign === 'right') {\r\n    x -= width;\r\n  } else if (xAlign === 'center') {\r\n    x -= (width / 2);\r\n  }\r\n  return x;\r\n}\r\n\r\nfunction alignY(size, yAlign, paddingAndSize) {\r\n  // eslint-disable-next-line prefer-const\r\n  let {y, height} = size;\r\n  if (yAlign === 'top') {\r\n    y += paddingAndSize;\r\n  } else if (yAlign === 'bottom') {\r\n    y -= height + paddingAndSize;\r\n  } else {\r\n    y -= (height / 2);\r\n  }\r\n  return y;\r\n}\r\n\r\n/**\r\n * Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment\r\n */\r\nfunction getBackgroundPoint(options, size, alignment, chart) {\r\n  const {caretSize, caretPadding, cornerRadius} = options;\r\n  const {xAlign, yAlign} = alignment;\r\n  const paddingAndSize = caretSize + caretPadding;\r\n  const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\r\n\r\n  let x = alignX(size, xAlign);\r\n  const y = alignY(size, yAlign, paddingAndSize);\r\n\r\n  if (yAlign === 'center') {\r\n    if (xAlign === 'left') {\r\n      x += paddingAndSize;\r\n    } else if (xAlign === 'right') {\r\n      x -= paddingAndSize;\r\n    }\r\n  } else if (xAlign === 'left') {\r\n    x -= Math.max(topLeft, bottomLeft) + caretSize;\r\n  } else if (xAlign === 'right') {\r\n    x += Math.max(topRight, bottomRight) + caretSize;\r\n  }\r\n\r\n  return {\r\n    x: _limitValue(x, 0, chart.width - size.width),\r\n    y: _limitValue(y, 0, chart.height - size.height)\r\n  };\r\n}\r\n\r\nfunction getAlignedX(tooltip, align, options) {\r\n  const padding = toPadding(options.padding);\r\n\r\n  return align === 'center'\r\n    ? tooltip.x + tooltip.width / 2\r\n    : align === 'right'\r\n      ? tooltip.x + tooltip.width - padding.right\r\n      : tooltip.x + padding.left;\r\n}\r\n\r\n/**\r\n * Helper to build before and after body lines\r\n */\r\nfunction getBeforeAfterBodyLines(callback) {\r\n  return pushOrConcat([], splitNewlines(callback));\r\n}\r\n\r\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\r\n  return createContext(parent, {\r\n    tooltip,\r\n    tooltipItems,\r\n    type: 'tooltip'\r\n  });\r\n}\r\n\r\nfunction overrideCallbacks(callbacks, context) {\r\n  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\r\n  return override ? callbacks.override(override) : callbacks;\r\n}\r\n\r\nconst defaultCallbacks = {\r\n  // Args are: (tooltipItems, data)\r\n  beforeTitle: noop,\r\n  title(tooltipItems) {\r\n    if (tooltipItems.length > 0) {\r\n      const item = tooltipItems[0];\r\n      const labels = item.chart.data.labels;\r\n      const labelCount = labels ? labels.length : 0;\r\n\r\n      if (this && this.options && this.options.mode === 'dataset') {\r\n        return item.dataset.label || '';\r\n      } else if (item.label) {\r\n        return item.label;\r\n      } else if (labelCount > 0 && item.dataIndex < labelCount) {\r\n        return labels[item.dataIndex];\r\n      }\r\n    }\r\n\r\n    return '';\r\n  },\r\n  afterTitle: noop,\r\n\r\n  // Args are: (tooltipItems, data)\r\n  beforeBody: noop,\r\n\r\n  // Args are: (tooltipItem, data)\r\n  beforeLabel: noop,\r\n  label(tooltipItem) {\r\n    if (this && this.options && this.options.mode === 'dataset') {\r\n      return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;\r\n    }\r\n\r\n    let label = tooltipItem.dataset.label || '';\r\n\r\n    if (label) {\r\n      label += ': ';\r\n    }\r\n    const value = tooltipItem.formattedValue;\r\n    if (!isNullOrUndef(value)) {\r\n      label += value;\r\n    }\r\n    return label;\r\n  },\r\n  labelColor(tooltipItem) {\r\n    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\r\n    const options = meta.controller.getStyle(tooltipItem.dataIndex);\r\n    return {\r\n      borderColor: options.borderColor,\r\n      backgroundColor: options.backgroundColor,\r\n      borderWidth: options.borderWidth,\r\n      borderDash: options.borderDash,\r\n      borderDashOffset: options.borderDashOffset,\r\n      borderRadius: 0,\r\n    };\r\n  },\r\n  labelTextColor() {\r\n    return this.options.bodyColor;\r\n  },\r\n  labelPointStyle(tooltipItem) {\r\n    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\r\n    const options = meta.controller.getStyle(tooltipItem.dataIndex);\r\n    return {\r\n      pointStyle: options.pointStyle,\r\n      rotation: options.rotation,\r\n    };\r\n  },\r\n  afterLabel: noop,\r\n\r\n  // Args are: (tooltipItems, data)\r\n  afterBody: noop,\r\n\r\n  // Args are: (tooltipItems, data)\r\n  beforeFooter: noop,\r\n  footer: noop,\r\n  afterFooter: noop\r\n};\r\n\r\n/**\r\n * Invoke callback from object with context and arguments.\r\n * If callback returns `undefined`, then will be invoked default callback.\r\n * @param {Record<keyof typeof defaultCallbacks, Function>} callbacks\r\n * @param {keyof typeof defaultCallbacks} name\r\n * @param {*} ctx\r\n * @param {*} arg\r\n * @returns {any}\r\n */\r\nfunction invokeCallbackWithFallback(callbacks, name, ctx, arg) {\r\n  const result = callbacks[name].call(ctx, arg);\r\n\r\n  if (typeof result === 'undefined') {\r\n    return defaultCallbacks[name].call(ctx, arg);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nexport class Tooltip extends Element {\r\n\r\n  /**\r\n   * @namespace Chart.Tooltip.positioners\r\n   */\r\n  static positioners = positioners;\r\n\r\n  constructor(config) {\r\n    super();\r\n\r\n    this.opacity = 0;\r\n    this._active = [];\r\n    this._eventPosition = undefined;\r\n    this._size = undefined;\r\n    this._cachedAnimations = undefined;\r\n    this._tooltipItems = [];\r\n    this.$animations = undefined;\r\n    this.$context = undefined;\r\n    this.chart = config.chart;\r\n    this.options = config.options;\r\n    this.dataPoints = undefined;\r\n    this.title = undefined;\r\n    this.beforeBody = undefined;\r\n    this.body = undefined;\r\n    this.afterBody = undefined;\r\n    this.footer = undefined;\r\n    this.xAlign = undefined;\r\n    this.yAlign = undefined;\r\n    this.x = undefined;\r\n    this.y = undefined;\r\n    this.height = undefined;\r\n    this.width = undefined;\r\n    this.caretX = undefined;\r\n    this.caretY = undefined;\r\n    // TODO: V4, make this private, rename to `_labelStyles`, and combine with `labelPointStyles`\r\n    // and `labelTextColors` to create a single variable\r\n    this.labelColors = undefined;\r\n    this.labelPointStyles = undefined;\r\n    this.labelTextColors = undefined;\r\n  }\r\n\r\n  initialize(options) {\r\n    this.options = options;\r\n    this._cachedAnimations = undefined;\r\n    this.$context = undefined;\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _resolveAnimations() {\r\n    const cached = this._cachedAnimations;\r\n\r\n    if (cached) {\r\n      return cached;\r\n    }\r\n\r\n    const chart = this.chart;\r\n    const options = this.options.setContext(this.getContext());\r\n    const opts = options.enabled && chart.options.animation && options.animations;\r\n    const animations = new Animations(this.chart, opts);\r\n    if (opts._cacheable) {\r\n      this._cachedAnimations = Object.freeze(animations);\r\n    }\r\n\r\n    return animations;\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  getContext() {\r\n    return this.$context ||\r\n\t\t\t(this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));\r\n  }\r\n\r\n  getTitle(context, options) {\r\n    const {callbacks} = options;\r\n\r\n    const beforeTitle = invokeCallbackWithFallback(callbacks, 'beforeTitle', this, context);\r\n    const title = invokeCallbackWithFallback(callbacks, 'title', this, context);\r\n    const afterTitle = invokeCallbackWithFallback(callbacks, 'afterTitle', this, context);\r\n\r\n    let lines = [];\r\n    lines = pushOrConcat(lines, splitNewlines(beforeTitle));\r\n    lines = pushOrConcat(lines, splitNewlines(title));\r\n    lines = pushOrConcat(lines, splitNewlines(afterTitle));\r\n\r\n    return lines;\r\n  }\r\n\r\n  getBeforeBody(tooltipItems, options) {\r\n    return getBeforeAfterBodyLines(\r\n      invokeCallbackWithFallback(options.callbacks, 'beforeBody', this, tooltipItems)\r\n    );\r\n  }\r\n\r\n  getBody(tooltipItems, options) {\r\n    const {callbacks} = options;\r\n    const bodyItems = [];\r\n\r\n    each(tooltipItems, (context) => {\r\n      const bodyItem = {\r\n        before: [],\r\n        lines: [],\r\n        after: []\r\n      };\r\n      const scoped = overrideCallbacks(callbacks, context);\r\n      pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, 'beforeLabel', this, context)));\r\n      pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, 'label', this, context));\r\n      pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, 'afterLabel', this, context)));\r\n\r\n      bodyItems.push(bodyItem);\r\n    });\r\n\r\n    return bodyItems;\r\n  }\r\n\r\n  getAfterBody(tooltipItems, options) {\r\n    return getBeforeAfterBodyLines(\r\n      invokeCallbackWithFallback(options.callbacks, 'afterBody', this, tooltipItems)\r\n    );\r\n  }\r\n\r\n  // Get the footer and beforeFooter and afterFooter lines\r\n  getFooter(tooltipItems, options) {\r\n    const {callbacks} = options;\r\n\r\n    const beforeFooter = invokeCallbackWithFallback(callbacks, 'beforeFooter', this, tooltipItems);\r\n    const footer = invokeCallbackWithFallback(callbacks, 'footer', this, tooltipItems);\r\n    const afterFooter = invokeCallbackWithFallback(callbacks, 'afterFooter', this, tooltipItems);\r\n\r\n    let lines = [];\r\n    lines = pushOrConcat(lines, splitNewlines(beforeFooter));\r\n    lines = pushOrConcat(lines, splitNewlines(footer));\r\n    lines = pushOrConcat(lines, splitNewlines(afterFooter));\r\n\r\n    return lines;\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _createItems(options) {\r\n    const active = this._active;\r\n    const data = this.chart.data;\r\n    const labelColors = [];\r\n    const labelPointStyles = [];\r\n    const labelTextColors = [];\r\n    let tooltipItems = [];\r\n    let i, len;\r\n\r\n    for (i = 0, len = active.length; i < len; ++i) {\r\n      tooltipItems.push(createTooltipItem(this.chart, active[i]));\r\n    }\r\n\r\n    // If the user provided a filter function, use it to modify the tooltip items\r\n    if (options.filter) {\r\n      tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));\r\n    }\r\n\r\n    // If the user provided a sorting function, use it to modify the tooltip items\r\n    if (options.itemSort) {\r\n      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));\r\n    }\r\n\r\n    // Determine colors for boxes\r\n    each(tooltipItems, (context) => {\r\n      const scoped = overrideCallbacks(options.callbacks, context);\r\n      labelColors.push(invokeCallbackWithFallback(scoped, 'labelColor', this, context));\r\n      labelPointStyles.push(invokeCallbackWithFallback(scoped, 'labelPointStyle', this, context));\r\n      labelTextColors.push(invokeCallbackWithFallback(scoped, 'labelTextColor', this, context));\r\n    });\r\n\r\n    this.labelColors = labelColors;\r\n    this.labelPointStyles = labelPointStyles;\r\n    this.labelTextColors = labelTextColors;\r\n    this.dataPoints = tooltipItems;\r\n    return tooltipItems;\r\n  }\r\n\r\n  update(changed, replay) {\r\n    const options = this.options.setContext(this.getContext());\r\n    const active = this._active;\r\n    let properties;\r\n    let tooltipItems = [];\r\n\r\n    if (!active.length) {\r\n      if (this.opacity !== 0) {\r\n        properties = {\r\n          opacity: 0\r\n        };\r\n      }\r\n    } else {\r\n      const position = positioners[options.position].call(this, active, this._eventPosition);\r\n      tooltipItems = this._createItems(options);\r\n\r\n      this.title = this.getTitle(tooltipItems, options);\r\n      this.beforeBody = this.getBeforeBody(tooltipItems, options);\r\n      this.body = this.getBody(tooltipItems, options);\r\n      this.afterBody = this.getAfterBody(tooltipItems, options);\r\n      this.footer = this.getFooter(tooltipItems, options);\r\n\r\n      const size = this._size = getTooltipSize(this, options);\r\n      const positionAndSize = Object.assign({}, position, size);\r\n      const alignment = determineAlignment(this.chart, options, positionAndSize);\r\n      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);\r\n\r\n      this.xAlign = alignment.xAlign;\r\n      this.yAlign = alignment.yAlign;\r\n\r\n      properties = {\r\n        opacity: 1,\r\n        x: backgroundPoint.x,\r\n        y: backgroundPoint.y,\r\n        width: size.width,\r\n        height: size.height,\r\n        caretX: position.x,\r\n        caretY: position.y\r\n      };\r\n    }\r\n\r\n    this._tooltipItems = tooltipItems;\r\n    this.$context = undefined;\r\n\r\n    if (properties) {\r\n      this._resolveAnimations().update(this, properties);\r\n    }\r\n\r\n    if (changed && options.external) {\r\n      options.external.call(this, {chart: this.chart, tooltip: this, replay});\r\n    }\r\n  }\r\n\r\n  drawCaret(tooltipPoint, ctx, size, options) {\r\n    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\r\n\r\n    ctx.lineTo(caretPosition.x1, caretPosition.y1);\r\n    ctx.lineTo(caretPosition.x2, caretPosition.y2);\r\n    ctx.lineTo(caretPosition.x3, caretPosition.y3);\r\n  }\r\n\r\n  getCaretPosition(tooltipPoint, size, options) {\r\n    const {xAlign, yAlign} = this;\r\n    const {caretSize, cornerRadius} = options;\r\n    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\r\n    const {x: ptX, y: ptY} = tooltipPoint;\r\n    const {width, height} = size;\r\n    let x1, x2, x3, y1, y2, y3;\r\n\r\n    if (yAlign === 'center') {\r\n      y2 = ptY + (height / 2);\r\n\r\n      if (xAlign === 'left') {\r\n        x1 = ptX;\r\n        x2 = x1 - caretSize;\r\n\r\n        // Left draws bottom -> top, this y1 is on the bottom\r\n        y1 = y2 + caretSize;\r\n        y3 = y2 - caretSize;\r\n      } else {\r\n        x1 = ptX + width;\r\n        x2 = x1 + caretSize;\r\n\r\n        // Right draws top -> bottom, thus y1 is on the top\r\n        y1 = y2 - caretSize;\r\n        y3 = y2 + caretSize;\r\n      }\r\n\r\n      x3 = x1;\r\n    } else {\r\n      if (xAlign === 'left') {\r\n        x2 = ptX + Math.max(topLeft, bottomLeft) + (caretSize);\r\n      } else if (xAlign === 'right') {\r\n        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;\r\n      } else {\r\n        x2 = this.caretX;\r\n      }\r\n\r\n      if (yAlign === 'top') {\r\n        y1 = ptY;\r\n        y2 = y1 - caretSize;\r\n\r\n        // Top draws left -> right, thus x1 is on the left\r\n        x1 = x2 - caretSize;\r\n        x3 = x2 + caretSize;\r\n      } else {\r\n        y1 = ptY + height;\r\n        y2 = y1 + caretSize;\r\n\r\n        // Bottom draws right -> left, thus x1 is on the right\r\n        x1 = x2 + caretSize;\r\n        x3 = x2 - caretSize;\r\n      }\r\n      y3 = y1;\r\n    }\r\n    return {x1, x2, x3, y1, y2, y3};\r\n  }\r\n\r\n  drawTitle(pt, ctx, options) {\r\n    const title = this.title;\r\n    const length = title.length;\r\n    let titleFont, titleSpacing, i;\r\n\r\n    if (length) {\r\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\r\n\r\n      pt.x = getAlignedX(this, options.titleAlign, options);\r\n\r\n      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\r\n      ctx.textBaseline = 'middle';\r\n\r\n      titleFont = toFont(options.titleFont);\r\n      titleSpacing = options.titleSpacing;\r\n\r\n      ctx.fillStyle = options.titleColor;\r\n      ctx.font = titleFont.string;\r\n\r\n      for (i = 0; i < length; ++i) {\r\n        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\r\n        pt.y += titleFont.lineHeight + titleSpacing; // Line Height and spacing\r\n\r\n        if (i + 1 === length) {\r\n          pt.y += options.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _drawColorBox(ctx, pt, i, rtlHelper, options) {\r\n    const labelColor = this.labelColors[i];\r\n    const labelPointStyle = this.labelPointStyles[i];\r\n    const {boxHeight, boxWidth} = options;\r\n    const bodyFont = toFont(options.bodyFont);\r\n    const colorX = getAlignedX(this, 'left', options);\r\n    const rtlColorX = rtlHelper.x(colorX);\r\n    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\r\n    const colorY = pt.y + yOffSet;\r\n\r\n    if (options.usePointStyle) {\r\n      const drawOptions = {\r\n        radius: Math.min(boxWidth, boxHeight) / 2, // fit the circle in the box\r\n        pointStyle: labelPointStyle.pointStyle,\r\n        rotation: labelPointStyle.rotation,\r\n        borderWidth: 1\r\n      };\r\n      // Recalculate x and y for drawPoint() because its expecting\r\n      // x and y to be center of figure (instead of top left)\r\n      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\r\n      const centerY = colorY + boxHeight / 2;\r\n\r\n      // Fill the point with white so that colours merge nicely if the opacity is < 1\r\n      ctx.strokeStyle = options.multiKeyBackground;\r\n      ctx.fillStyle = options.multiKeyBackground;\r\n      drawPoint(ctx, drawOptions, centerX, centerY);\r\n\r\n      // Draw the point\r\n      ctx.strokeStyle = labelColor.borderColor;\r\n      ctx.fillStyle = labelColor.backgroundColor;\r\n      drawPoint(ctx, drawOptions, centerX, centerY);\r\n    } else {\r\n      // Border\r\n      ctx.lineWidth = isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : (labelColor.borderWidth || 1); // TODO, v4 remove fallback\r\n      ctx.strokeStyle = labelColor.borderColor;\r\n      ctx.setLineDash(labelColor.borderDash || []);\r\n      ctx.lineDashOffset = labelColor.borderDashOffset || 0;\r\n\r\n      // Fill a white rect so that colours merge nicely if the opacity is < 1\r\n      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);\r\n      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);\r\n      const borderRadius = toTRBLCorners(labelColor.borderRadius);\r\n\r\n      if (Object.values(borderRadius).some(v => v !== 0)) {\r\n        ctx.beginPath();\r\n        ctx.fillStyle = options.multiKeyBackground;\r\n        addRoundedRectPath(ctx, {\r\n          x: outerX,\r\n          y: colorY,\r\n          w: boxWidth,\r\n          h: boxHeight,\r\n          radius: borderRadius,\r\n        });\r\n        ctx.fill();\r\n        ctx.stroke();\r\n\r\n        // Inner square\r\n        ctx.fillStyle = labelColor.backgroundColor;\r\n        ctx.beginPath();\r\n        addRoundedRectPath(ctx, {\r\n          x: innerX,\r\n          y: colorY + 1,\r\n          w: boxWidth - 2,\r\n          h: boxHeight - 2,\r\n          radius: borderRadius,\r\n        });\r\n        ctx.fill();\r\n      } else {\r\n        // Normal rect\r\n        ctx.fillStyle = options.multiKeyBackground;\r\n        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\r\n        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\r\n        // Inner square\r\n        ctx.fillStyle = labelColor.backgroundColor;\r\n        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\r\n      }\r\n    }\r\n\r\n    // restore fillStyle\r\n    ctx.fillStyle = this.labelTextColors[i];\r\n  }\r\n\r\n  drawBody(pt, ctx, options) {\r\n    const {body} = this;\r\n    const {bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding} = options;\r\n    const bodyFont = toFont(options.bodyFont);\r\n    let bodyLineHeight = bodyFont.lineHeight;\r\n    let xLinePadding = 0;\r\n\r\n    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\r\n\r\n    const fillLineOfText = function(line) {\r\n      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\r\n      pt.y += bodyLineHeight + bodySpacing;\r\n    };\r\n\r\n    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\r\n    let bodyItem, textColor, lines, i, j, ilen, jlen;\r\n\r\n    ctx.textAlign = bodyAlign;\r\n    ctx.textBaseline = 'middle';\r\n    ctx.font = bodyFont.string;\r\n\r\n    pt.x = getAlignedX(this, bodyAlignForCalculation, options);\r\n\r\n    // Before body lines\r\n    ctx.fillStyle = options.bodyColor;\r\n    each(this.beforeBody, fillLineOfText);\r\n\r\n    xLinePadding = displayColors && bodyAlignForCalculation !== 'right'\r\n      ? bodyAlign === 'center' ? (boxWidth / 2 + boxPadding) : (boxWidth + 2 + boxPadding)\r\n      : 0;\r\n\r\n    // Draw body lines now\r\n    for (i = 0, ilen = body.length; i < ilen; ++i) {\r\n      bodyItem = body[i];\r\n      textColor = this.labelTextColors[i];\r\n\r\n      ctx.fillStyle = textColor;\r\n      each(bodyItem.before, fillLineOfText);\r\n\r\n      lines = bodyItem.lines;\r\n      // Draw Legend-like boxes if needed\r\n      if (displayColors && lines.length) {\r\n        this._drawColorBox(ctx, pt, i, rtlHelper, options);\r\n        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\r\n      }\r\n\r\n      for (j = 0, jlen = lines.length; j < jlen; ++j) {\r\n        fillLineOfText(lines[j]);\r\n        // Reset for any lines that don't include colorbox\r\n        bodyLineHeight = bodyFont.lineHeight;\r\n      }\r\n\r\n      each(bodyItem.after, fillLineOfText);\r\n    }\r\n\r\n    // Reset back to 0 for after body\r\n    xLinePadding = 0;\r\n    bodyLineHeight = bodyFont.lineHeight;\r\n\r\n    // After body lines\r\n    each(this.afterBody, fillLineOfText);\r\n    pt.y -= bodySpacing; // Remove last body spacing\r\n  }\r\n\r\n  drawFooter(pt, ctx, options) {\r\n    const footer = this.footer;\r\n    const length = footer.length;\r\n    let footerFont, i;\r\n\r\n    if (length) {\r\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\r\n\r\n      pt.x = getAlignedX(this, options.footerAlign, options);\r\n      pt.y += options.footerMarginTop;\r\n\r\n      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\r\n      ctx.textBaseline = 'middle';\r\n\r\n      footerFont = toFont(options.footerFont);\r\n\r\n      ctx.fillStyle = options.footerColor;\r\n      ctx.font = footerFont.string;\r\n\r\n      for (i = 0; i < length; ++i) {\r\n        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\r\n        pt.y += footerFont.lineHeight + options.footerSpacing;\r\n      }\r\n    }\r\n  }\r\n\r\n  drawBackground(pt, ctx, tooltipSize, options) {\r\n    const {xAlign, yAlign} = this;\r\n    const {x, y} = pt;\r\n    const {width, height} = tooltipSize;\r\n    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(options.cornerRadius);\r\n\r\n    ctx.fillStyle = options.backgroundColor;\r\n    ctx.strokeStyle = options.borderColor;\r\n    ctx.lineWidth = options.borderWidth;\r\n\r\n    ctx.beginPath();\r\n    ctx.moveTo(x + topLeft, y);\r\n    if (yAlign === 'top') {\r\n      this.drawCaret(pt, ctx, tooltipSize, options);\r\n    }\r\n    ctx.lineTo(x + width - topRight, y);\r\n    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\r\n    if (yAlign === 'center' && xAlign === 'right') {\r\n      this.drawCaret(pt, ctx, tooltipSize, options);\r\n    }\r\n    ctx.lineTo(x + width, y + height - bottomRight);\r\n    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);\r\n    if (yAlign === 'bottom') {\r\n      this.drawCaret(pt, ctx, tooltipSize, options);\r\n    }\r\n    ctx.lineTo(x + bottomLeft, y + height);\r\n    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\r\n    if (yAlign === 'center' && xAlign === 'left') {\r\n      this.drawCaret(pt, ctx, tooltipSize, options);\r\n    }\r\n    ctx.lineTo(x, y + topLeft);\r\n    ctx.quadraticCurveTo(x, y, x + topLeft, y);\r\n    ctx.closePath();\r\n\r\n    ctx.fill();\r\n\r\n    if (options.borderWidth > 0) {\r\n      ctx.stroke();\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * Update x/y animation targets when _active elements are animating too\r\n\t * @private\r\n\t */\r\n  _updateAnimationTarget(options) {\r\n    const chart = this.chart;\r\n    const anims = this.$animations;\r\n    const animX = anims && anims.x;\r\n    const animY = anims && anims.y;\r\n    if (animX || animY) {\r\n      const position = positioners[options.position].call(this, this._active, this._eventPosition);\r\n      if (!position) {\r\n        return;\r\n      }\r\n      const size = this._size = getTooltipSize(this, options);\r\n      const positionAndSize = Object.assign({}, position, this._size);\r\n      const alignment = determineAlignment(chart, options, positionAndSize);\r\n      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\r\n      if (animX._to !== point.x || animY._to !== point.y) {\r\n        this.xAlign = alignment.xAlign;\r\n        this.yAlign = alignment.yAlign;\r\n        this.width = size.width;\r\n        this.height = size.height;\r\n        this.caretX = position.x;\r\n        this.caretY = position.y;\r\n        this._resolveAnimations().update(this, point);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Determine if the tooltip will draw anything\r\n   * @returns {boolean} True if the tooltip will render\r\n   */\r\n  _willRender() {\r\n    return !!this.opacity;\r\n  }\r\n\r\n  draw(ctx) {\r\n    const options = this.options.setContext(this.getContext());\r\n    let opacity = this.opacity;\r\n\r\n    if (!opacity) {\r\n      return;\r\n    }\r\n\r\n    this._updateAnimationTarget(options);\r\n\r\n    const tooltipSize = {\r\n      width: this.width,\r\n      height: this.height\r\n    };\r\n    const pt = {\r\n      x: this.x,\r\n      y: this.y\r\n    };\r\n\r\n    // IE11/Edge does not like very small opacities, so snap to 0\r\n    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\r\n\r\n    const padding = toPadding(options.padding);\r\n\r\n    // Truthy/falsey value for empty tooltip\r\n    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\r\n\r\n    if (options.enabled && hasTooltipContent) {\r\n      ctx.save();\r\n      ctx.globalAlpha = opacity;\r\n\r\n      // Draw Background\r\n      this.drawBackground(pt, ctx, tooltipSize, options);\r\n\r\n      overrideTextDirection(ctx, options.textDirection);\r\n\r\n      pt.y += padding.top;\r\n\r\n      // Titles\r\n      this.drawTitle(pt, ctx, options);\r\n\r\n      // Body\r\n      this.drawBody(pt, ctx, options);\r\n\r\n      // Footer\r\n      this.drawFooter(pt, ctx, options);\r\n\r\n      restoreTextDirection(ctx, options.textDirection);\r\n\r\n      ctx.restore();\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * Get active elements in the tooltip\r\n\t * @returns {Array} Array of elements that are active in the tooltip\r\n\t */\r\n  getActiveElements() {\r\n    return this._active || [];\r\n  }\r\n\r\n  /**\r\n\t * Set active elements in the tooltip\r\n\t * @param {array} activeElements Array of active datasetIndex/index pairs.\r\n\t * @param {object} eventPosition Synthetic event position used in positioning\r\n\t */\r\n  setActiveElements(activeElements, eventPosition) {\r\n    const lastActive = this._active;\r\n    const active = activeElements.map(({datasetIndex, index}) => {\r\n      const meta = this.chart.getDatasetMeta(datasetIndex);\r\n\r\n      if (!meta) {\r\n        throw new Error('Cannot find a dataset at index ' + datasetIndex);\r\n      }\r\n\r\n      return {\r\n        datasetIndex,\r\n        element: meta.data[index],\r\n        index,\r\n      };\r\n    });\r\n    const changed = !_elementsEqual(lastActive, active);\r\n    const positionChanged = this._positionChanged(active, eventPosition);\r\n\r\n    if (changed || positionChanged) {\r\n      this._active = active;\r\n      this._eventPosition = eventPosition;\r\n      this._ignoreReplayEvents = true;\r\n      this.update(true);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * Handle an event\r\n\t * @param {ChartEvent} e - The event to handle\r\n\t * @param {boolean} [replay] - This is a replayed event (from update)\r\n\t * @param {boolean} [inChartArea] - The event is inside chartArea\r\n\t * @returns {boolean} true if the tooltip changed\r\n\t */\r\n  handleEvent(e, replay, inChartArea = true) {\r\n    if (replay && this._ignoreReplayEvents) {\r\n      return false;\r\n    }\r\n    this._ignoreReplayEvents = false;\r\n\r\n    const options = this.options;\r\n    const lastActive = this._active || [];\r\n    const active = this._getActiveElements(e, lastActive, replay, inChartArea);\r\n\r\n    // When there are multiple items shown, but the tooltip position is nearest mode\r\n    // an update may need to be made because our position may have changed even though\r\n    // the items are the same as before.\r\n    const positionChanged = this._positionChanged(active, e);\r\n\r\n    // Remember Last Actives\r\n    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;\r\n\r\n    // Only handle target event on tooltip change\r\n    if (changed) {\r\n      this._active = active;\r\n\r\n      if (options.enabled || options.external) {\r\n        this._eventPosition = {\r\n          x: e.x,\r\n          y: e.y\r\n        };\r\n\r\n        this.update(true, replay);\r\n      }\r\n    }\r\n\r\n    return changed;\r\n  }\r\n\r\n  /**\r\n\t * Helper for determining the active elements for event\r\n\t * @param {ChartEvent} e - The event to handle\r\n\t * @param {InteractionItem[]} lastActive - Previously active elements\r\n\t * @param {boolean} [replay] - This is a replayed event (from update)\r\n\t * @param {boolean} [inChartArea] - The event is inside chartArea\r\n\t * @returns {InteractionItem[]} - Active elements\r\n\t * @private\r\n\t */\r\n  _getActiveElements(e, lastActive, replay, inChartArea) {\r\n    const options = this.options;\r\n\r\n    if (e.type === 'mouseout') {\r\n      return [];\r\n    }\r\n\r\n    if (!inChartArea) {\r\n      // Let user control the active elements outside chartArea. Eg. using Legend.\r\n      return lastActive;\r\n    }\r\n\r\n    // Find Active Elements for tooltips\r\n    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);\r\n\r\n    if (options.reverse) {\r\n      active.reverse();\r\n    }\r\n\r\n    return active;\r\n  }\r\n\r\n  /**\r\n\t * Determine if the active elements + event combination changes the\r\n\t * tooltip position\r\n\t * @param {array} active - Active elements\r\n\t * @param {ChartEvent} e - Event that triggered the position change\r\n\t * @returns {boolean} True if the position has changed\r\n\t */\r\n  _positionChanged(active, e) {\r\n    const {caretX, caretY, options} = this;\r\n    const position = positioners[options.position].call(this, active, e);\r\n    return position !== false && (caretX !== position.x || caretY !== position.y);\r\n  }\r\n}\r\n\r\nexport default {\r\n  id: 'tooltip',\r\n  _element: Tooltip,\r\n  positioners,\r\n\r\n  afterInit(chart, _args, options) {\r\n    if (options) {\r\n      chart.tooltip = new Tooltip({chart, options});\r\n    }\r\n  },\r\n\r\n  beforeUpdate(chart, _args, options) {\r\n    if (chart.tooltip) {\r\n      chart.tooltip.initialize(options);\r\n    }\r\n  },\r\n\r\n  reset(chart, _args, options) {\r\n    if (chart.tooltip) {\r\n      chart.tooltip.initialize(options);\r\n    }\r\n  },\r\n\r\n  afterDraw(chart) {\r\n    const tooltip = chart.tooltip;\r\n\r\n    if (tooltip && tooltip._willRender()) {\r\n      const args = {\r\n        tooltip\r\n      };\r\n\r\n      if (chart.notifyPlugins('beforeTooltipDraw', {...args, cancelable: true}) === false) {\r\n        return;\r\n      }\r\n\r\n      tooltip.draw(chart.ctx);\r\n\r\n      chart.notifyPlugins('afterTooltipDraw', args);\r\n    }\r\n  },\r\n\r\n  afterEvent(chart, args) {\r\n    if (chart.tooltip) {\r\n      // If the event is replayed from `update`, we should evaluate with the final positions.\r\n      const useFinalPosition = args.replay;\r\n      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {\r\n        // notify chart about the change, so it will render\r\n        args.changed = true;\r\n      }\r\n    }\r\n  },\r\n\r\n  defaults: {\r\n    enabled: true,\r\n    external: null,\r\n    position: 'average',\r\n    backgroundColor: 'rgba(0,0,0,0.8)',\r\n    titleColor: '#fff',\r\n    titleFont: {\r\n      weight: 'bold',\r\n    },\r\n    titleSpacing: 2,\r\n    titleMarginBottom: 6,\r\n    titleAlign: 'left',\r\n    bodyColor: '#fff',\r\n    bodySpacing: 2,\r\n    bodyFont: {\r\n    },\r\n    bodyAlign: 'left',\r\n    footerColor: '#fff',\r\n    footerSpacing: 2,\r\n    footerMarginTop: 6,\r\n    footerFont: {\r\n      weight: 'bold',\r\n    },\r\n    footerAlign: 'left',\r\n    padding: 6,\r\n    caretPadding: 2,\r\n    caretSize: 5,\r\n    cornerRadius: 6,\r\n    boxHeight: (ctx, opts) => opts.bodyFont.size,\r\n    boxWidth: (ctx, opts) => opts.bodyFont.size,\r\n    multiKeyBackground: '#fff',\r\n    displayColors: true,\r\n    boxPadding: 0,\r\n    borderColor: 'rgba(0,0,0,0)',\r\n    borderWidth: 0,\r\n    animation: {\r\n      duration: 400,\r\n      easing: 'easeOutQuart',\r\n    },\r\n    animations: {\r\n      numbers: {\r\n        type: 'number',\r\n        properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'],\r\n      },\r\n      opacity: {\r\n        easing: 'linear',\r\n        duration: 200\r\n      }\r\n    },\r\n    callbacks: defaultCallbacks\r\n  },\r\n\r\n  defaultRoutes: {\r\n    bodyFont: 'font',\r\n    footerFont: 'font',\r\n    titleFont: 'font'\r\n  },\r\n\r\n  descriptors: {\r\n    _scriptable: (name) => name !== 'filter' && name !== 'itemSort' && name !== 'external',\r\n    _indexable: false,\r\n    callbacks: {\r\n      _scriptable: false,\r\n      _indexable: false,\r\n    },\r\n    animation: {\r\n      _fallback: false\r\n    },\r\n    animations: {\r\n      _fallback: 'animation'\r\n    }\r\n  },\r\n\r\n  // Resolve additionally from `interaction` options and defaults.\r\n  additionalOptionScopes: ['interaction']\r\n};\r\n","import Scale from '../core/core.scale.js';\r\nimport {isNullOrUndef, valueOrDefault, _limitValue} from '../helpers/index.js';\r\n\r\nconst addIfString = (labels, raw, index, addedLabels) => {\r\n  if (typeof raw === 'string') {\r\n    index = labels.push(raw) - 1;\r\n    addedLabels.unshift({index, label: raw});\r\n  } else if (isNaN(raw)) {\r\n    index = null;\r\n  }\r\n  return index;\r\n};\r\n\r\nfunction findOrAddLabel(labels, raw, index, addedLabels) {\r\n  const first = labels.indexOf(raw);\r\n  if (first === -1) {\r\n    return addIfString(labels, raw, index, addedLabels);\r\n  }\r\n  const last = labels.lastIndexOf(raw);\r\n  return first !== last ? index : first;\r\n}\r\n\r\nconst validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);\r\n\r\nfunction _getLabelForValue(value) {\r\n  const labels = this.getLabels();\r\n\r\n  if (value >= 0 && value < labels.length) {\r\n    return labels[value];\r\n  }\r\n  return value;\r\n}\r\n\r\nexport default class CategoryScale extends Scale {\r\n\r\n  static id = 'category';\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = {\r\n    ticks: {\r\n      callback: _getLabelForValue\r\n    }\r\n  };\r\n\r\n  constructor(cfg) {\r\n    super(cfg);\r\n\r\n    /** @type {number} */\r\n    this._startValue = undefined;\r\n    this._valueRange = 0;\r\n    this._addedLabels = [];\r\n  }\r\n\r\n  init(scaleOptions) {\r\n    const added = this._addedLabels;\r\n    if (added.length) {\r\n      const labels = this.getLabels();\r\n      for (const {index, label} of added) {\r\n        if (labels[index] === label) {\r\n          labels.splice(index, 1);\r\n        }\r\n      }\r\n      this._addedLabels = [];\r\n    }\r\n    super.init(scaleOptions);\r\n  }\r\n\r\n  parse(raw, index) {\r\n    if (isNullOrUndef(raw)) {\r\n      return null;\r\n    }\r\n    const labels = this.getLabels();\r\n    index = isFinite(index) && labels[index] === raw ? index\r\n      : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);\r\n    return validIndex(index, labels.length - 1);\r\n  }\r\n\r\n  determineDataLimits() {\r\n    const {minDefined, maxDefined} = this.getUserBounds();\r\n    let {min, max} = this.getMinMax(true);\r\n\r\n    if (this.options.bounds === 'ticks') {\r\n      if (!minDefined) {\r\n        min = 0;\r\n      }\r\n      if (!maxDefined) {\r\n        max = this.getLabels().length - 1;\r\n      }\r\n    }\r\n\r\n    this.min = min;\r\n    this.max = max;\r\n  }\r\n\r\n  buildTicks() {\r\n    const min = this.min;\r\n    const max = this.max;\r\n    const offset = this.options.offset;\r\n    const ticks = [];\r\n    let labels = this.getLabels();\r\n\r\n    // If we are viewing some subset of labels, slice the original array\r\n    labels = (min === 0 && max === labels.length - 1) ? labels : labels.slice(min, max + 1);\r\n\r\n    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\r\n    this._startValue = this.min - (offset ? 0.5 : 0);\r\n\r\n    for (let value = min; value <= max; value++) {\r\n      ticks.push({value});\r\n    }\r\n    return ticks;\r\n  }\r\n\r\n  getLabelForValue(value) {\r\n    return _getLabelForValue.call(this, value);\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  configure() {\r\n    super.configure();\r\n\r\n    if (!this.isHorizontal()) {\r\n      // For backward compatibility, vertical category scale reverse is inverted.\r\n      this._reversePixels = !this._reversePixels;\r\n    }\r\n  }\r\n\r\n  // Used to get data value locations. Value can either be an index or a numerical value\r\n  getPixelForValue(value) {\r\n    if (typeof value !== 'number') {\r\n      value = this.parse(value);\r\n    }\r\n\r\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\r\n  }\r\n\r\n  // Must override base implementation because it calls getPixelForValue\r\n  // and category scale can have duplicate values\r\n  getPixelForTick(index) {\r\n    const ticks = this.ticks;\r\n    if (index < 0 || index > ticks.length - 1) {\r\n      return null;\r\n    }\r\n    return this.getPixelForValue(ticks[index].value);\r\n  }\r\n\r\n  getValueForPixel(pixel) {\r\n    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);\r\n  }\r\n\r\n  getBasePixel() {\r\n    return this.bottom;\r\n  }\r\n}\r\n","import {isNullOrUndef} from '../helpers/helpers.core.js';\r\nimport {almostEquals, almostWhole, niceNum, _decimalPlaces, _setMinAndMaxByKey, sign, toRadians} from '../helpers/helpers.math.js';\r\nimport Scale from '../core/core.scale.js';\r\nimport {formatNumber} from '../helpers/helpers.intl.js';\r\n\r\n/**\r\n * Generate a set of linear ticks for an axis\r\n * 1. If generationOptions.min, generationOptions.max, and generationOptions.step are defined:\r\n *    if (max - min) / step is an integer, ticks are generated as [min, min + step, ..., max]\r\n *    Note that the generationOptions.maxCount setting is respected in this scenario\r\n *\r\n * 2. If generationOptions.min, generationOptions.max, and generationOptions.count is defined\r\n *    spacing = (max - min) / count\r\n *    Ticks are generated as [min, min + spacing, ..., max]\r\n *\r\n * 3. If generationOptions.count is defined\r\n *    spacing = (niceMax - niceMin) / count\r\n *\r\n * 4. Compute optimal spacing of ticks using niceNum algorithm\r\n *\r\n * @param generationOptions the options used to generate the ticks\r\n * @param dataRange the range of the data\r\n * @returns {object[]} array of tick objects\r\n */\r\nfunction generateTicks(generationOptions, dataRange) {\r\n  const ticks = [];\r\n  // To get a \"nice\" value for the tick spacing, we will use the appropriately named\r\n  // \"nice number\" algorithm. See https://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\r\n  // for details.\r\n\r\n  const MIN_SPACING = 1e-14;\r\n  const {bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds} = generationOptions;\r\n  const unit = step || 1;\r\n  const maxSpaces = maxTicks - 1;\r\n  const {min: rmin, max: rmax} = dataRange;\r\n  const minDefined = !isNullOrUndef(min);\r\n  const maxDefined = !isNullOrUndef(max);\r\n  const countDefined = !isNullOrUndef(count);\r\n  const minSpacing = (rmax - rmin) / (maxDigits + 1);\r\n  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;\r\n  let factor, niceMin, niceMax, numSpaces;\r\n\r\n  // Beyond MIN_SPACING floating point numbers being to lose precision\r\n  // such that we can't do the math necessary to generate ticks\r\n  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\r\n    return [{value: rmin}, {value: rmax}];\r\n  }\r\n\r\n  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\r\n  if (numSpaces > maxSpaces) {\r\n    // If the calculated num of spaces exceeds maxNumSpaces, recalculate it\r\n    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;\r\n  }\r\n\r\n  if (!isNullOrUndef(precision)) {\r\n    // If the user specified a precision, round to that number of decimal places\r\n    factor = Math.pow(10, precision);\r\n    spacing = Math.ceil(spacing * factor) / factor;\r\n  }\r\n\r\n  if (bounds === 'ticks') {\r\n    niceMin = Math.floor(rmin / spacing) * spacing;\r\n    niceMax = Math.ceil(rmax / spacing) * spacing;\r\n  } else {\r\n    niceMin = rmin;\r\n    niceMax = rmax;\r\n  }\r\n\r\n  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {\r\n    // Case 1: If min, max and stepSize are set and they make an evenly spaced scale use it.\r\n    // spacing = step;\r\n    // numSpaces = (max - min) / spacing;\r\n    // Note that we round here to handle the case where almostWhole translated an FP error\r\n    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\r\n    spacing = (max - min) / numSpaces;\r\n    niceMin = min;\r\n    niceMax = max;\r\n  } else if (countDefined) {\r\n    // Cases 2 & 3, we have a count specified. Handle optional user defined edges to the range.\r\n    // Sometimes these are no-ops, but it makes the code a lot clearer\r\n    // and when a user defined range is specified, we want the correct ticks\r\n    niceMin = minDefined ? min : niceMin;\r\n    niceMax = maxDefined ? max : niceMax;\r\n    numSpaces = count - 1;\r\n    spacing = (niceMax - niceMin) / numSpaces;\r\n  } else {\r\n    // Case 4\r\n    numSpaces = (niceMax - niceMin) / spacing;\r\n\r\n    // If very close to our rounded value, use it.\r\n    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\r\n      numSpaces = Math.round(numSpaces);\r\n    } else {\r\n      numSpaces = Math.ceil(numSpaces);\r\n    }\r\n  }\r\n\r\n  // The spacing will have changed in cases 1, 2, and 3 so the factor cannot be computed\r\n  // until this point\r\n  const decimalPlaces = Math.max(\r\n    _decimalPlaces(spacing),\r\n    _decimalPlaces(niceMin)\r\n  );\r\n  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);\r\n  niceMin = Math.round(niceMin * factor) / factor;\r\n  niceMax = Math.round(niceMax * factor) / factor;\r\n\r\n  let j = 0;\r\n  if (minDefined) {\r\n    if (includeBounds && niceMin !== min) {\r\n      ticks.push({value: min});\r\n\r\n      if (niceMin < min) {\r\n        j++; // Skip niceMin\r\n      }\r\n      // If the next nice tick is close to min, skip it\r\n      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\r\n        j++;\r\n      }\r\n    } else if (niceMin < min) {\r\n      j++;\r\n    }\r\n  }\r\n\r\n  for (; j < numSpaces; ++j) {\r\n    const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;\r\n    if (maxDefined && tickValue > max) {\r\n      break;\r\n    }\r\n    ticks.push({value: tickValue});\r\n  }\r\n\r\n  if (maxDefined && includeBounds && niceMax !== max) {\r\n    // If the previous tick is too close to max, replace it with max, else add max\r\n    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\r\n      ticks[ticks.length - 1].value = max;\r\n    } else {\r\n      ticks.push({value: max});\r\n    }\r\n  } else if (!maxDefined || niceMax === max) {\r\n    ticks.push({value: niceMax});\r\n  }\r\n\r\n  return ticks;\r\n}\r\n\r\nfunction relativeLabelSize(value, minSpacing, {horizontal, minRotation}) {\r\n  const rad = toRadians(minRotation);\r\n  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\r\n  const length = 0.75 * minSpacing * ('' + value).length;\r\n  return Math.min(minSpacing / ratio, length);\r\n}\r\n\r\nexport default class LinearScaleBase extends Scale {\r\n\r\n  constructor(cfg) {\r\n    super(cfg);\r\n\r\n    /** @type {number} */\r\n    this.start = undefined;\r\n    /** @type {number} */\r\n    this.end = undefined;\r\n    /** @type {number} */\r\n    this._startValue = undefined;\r\n    /** @type {number} */\r\n    this._endValue = undefined;\r\n    this._valueRange = 0;\r\n  }\r\n\r\n  parse(raw, index) { // eslint-disable-line no-unused-vars\r\n    if (isNullOrUndef(raw)) {\r\n      return null;\r\n    }\r\n    if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {\r\n      return null;\r\n    }\r\n\r\n    return +raw;\r\n  }\r\n\r\n  handleTickRangeOptions() {\r\n    const {beginAtZero} = this.options;\r\n    const {minDefined, maxDefined} = this.getUserBounds();\r\n    let {min, max} = this;\r\n\r\n    const setMin = v => (min = minDefined ? min : v);\r\n    const setMax = v => (max = maxDefined ? max : v);\r\n\r\n    if (beginAtZero) {\r\n      const minSign = sign(min);\r\n      const maxSign = sign(max);\r\n\r\n      if (minSign < 0 && maxSign < 0) {\r\n        setMax(0);\r\n      } else if (minSign > 0 && maxSign > 0) {\r\n        setMin(0);\r\n      }\r\n    }\r\n\r\n    if (min === max) {\r\n      let offset = max === 0 ? 1 : Math.abs(max * 0.05);\r\n\r\n      setMax(max + offset);\r\n\r\n      if (!beginAtZero) {\r\n        setMin(min - offset);\r\n      }\r\n    }\r\n    this.min = min;\r\n    this.max = max;\r\n  }\r\n\r\n  getTickLimit() {\r\n    const tickOpts = this.options.ticks;\r\n    // eslint-disable-next-line prefer-const\r\n    let {maxTicksLimit, stepSize} = tickOpts;\r\n    let maxTicks;\r\n\r\n    if (stepSize) {\r\n      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;\r\n      if (maxTicks > 1000) {\r\n        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);\r\n        maxTicks = 1000;\r\n      }\r\n    } else {\r\n      maxTicks = this.computeTickLimit();\r\n      maxTicksLimit = maxTicksLimit || 11;\r\n    }\r\n\r\n    if (maxTicksLimit) {\r\n      maxTicks = Math.min(maxTicksLimit, maxTicks);\r\n    }\r\n\r\n    return maxTicks;\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  computeTickLimit() {\r\n    return Number.POSITIVE_INFINITY;\r\n  }\r\n\r\n  buildTicks() {\r\n    const opts = this.options;\r\n    const tickOpts = opts.ticks;\r\n\r\n    // Figure out what the max number of ticks we can support it is based on the size of\r\n    // the axis area. For now, we say that the minimum tick spacing in pixels must be 40\r\n    // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\r\n    // the graph. Make sure we always have at least 2 ticks\r\n    let maxTicks = this.getTickLimit();\r\n    maxTicks = Math.max(2, maxTicks);\r\n\r\n    const numericGeneratorOptions = {\r\n      maxTicks,\r\n      bounds: opts.bounds,\r\n      min: opts.min,\r\n      max: opts.max,\r\n      precision: tickOpts.precision,\r\n      step: tickOpts.stepSize,\r\n      count: tickOpts.count,\r\n      maxDigits: this._maxDigits(),\r\n      horizontal: this.isHorizontal(),\r\n      minRotation: tickOpts.minRotation || 0,\r\n      includeBounds: tickOpts.includeBounds !== false\r\n    };\r\n    const dataRange = this._range || this;\r\n    const ticks = generateTicks(numericGeneratorOptions, dataRange);\r\n\r\n    // At this point, we need to update our max and min given the tick values,\r\n    // since we probably have expanded the range of the scale\r\n    if (opts.bounds === 'ticks') {\r\n      _setMinAndMaxByKey(ticks, this, 'value');\r\n    }\r\n\r\n    if (opts.reverse) {\r\n      ticks.reverse();\r\n\r\n      this.start = this.max;\r\n      this.end = this.min;\r\n    } else {\r\n      this.start = this.min;\r\n      this.end = this.max;\r\n    }\r\n\r\n    return ticks;\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  configure() {\r\n    const ticks = this.ticks;\r\n    let start = this.min;\r\n    let end = this.max;\r\n\r\n    super.configure();\r\n\r\n    if (this.options.offset && ticks.length) {\r\n      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\r\n      start -= offset;\r\n      end += offset;\r\n    }\r\n    this._startValue = start;\r\n    this._endValue = end;\r\n    this._valueRange = end - start;\r\n  }\r\n\r\n  getLabelForValue(value) {\r\n    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);\r\n  }\r\n}\r\n","import {isFinite} from '../helpers/helpers.core.js';\r\nimport LinearScaleBase from './scale.linearbase.js';\r\nimport Ticks from '../core/core.ticks.js';\r\nimport {toRadians} from '../helpers/index.js';\r\n\r\nexport default class LinearScale extends LinearScaleBase {\r\n\r\n  static id = 'linear';\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = {\r\n    ticks: {\r\n      callback: Ticks.formatters.numeric\r\n    }\r\n  };\r\n\r\n\r\n  determineDataLimits() {\r\n    const {min, max} = this.getMinMax(true);\r\n\r\n    this.min = isFinite(min) ? min : 0;\r\n    this.max = isFinite(max) ? max : 1;\r\n\r\n    // Common base implementation to handle min, max, beginAtZero\r\n    this.handleTickRangeOptions();\r\n  }\r\n\r\n  /**\r\n\t * Returns the maximum number of ticks based on the scale dimension\r\n\t * @protected\r\n \t */\r\n  computeTickLimit() {\r\n    const horizontal = this.isHorizontal();\r\n    const length = horizontal ? this.width : this.height;\r\n    const minRotation = toRadians(this.options.ticks.minRotation);\r\n    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\r\n    const tickFont = this._resolveTickFontOptions(0);\r\n    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\r\n  }\r\n\r\n  // Utils\r\n  getPixelForValue(value) {\r\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\r\n  }\r\n\r\n  getValueForPixel(pixel) {\r\n    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\r\n  }\r\n}\r\n","import {finiteOrDefault, isFinite} from '../helpers/helpers.core.js';\r\nimport {formatNumber} from '../helpers/helpers.intl.js';\r\nimport {_setMinAndMaxByKey, log10} from '../helpers/helpers.math.js';\r\nimport Scale from '../core/core.scale.js';\r\nimport LinearScaleBase from './scale.linearbase.js';\r\nimport Ticks from '../core/core.ticks.js';\r\n\r\nconst log10Floor = v => Math.floor(log10(v));\r\nconst changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);\r\n\r\nfunction isMajor(tickVal) {\r\n  const remain = tickVal / (Math.pow(10, log10Floor(tickVal)));\r\n  return remain === 1;\r\n}\r\n\r\nfunction steps(min, max, rangeExp) {\r\n  const rangeStep = Math.pow(10, rangeExp);\r\n  const start = Math.floor(min / rangeStep);\r\n  const end = Math.ceil(max / rangeStep);\r\n  return end - start;\r\n}\r\n\r\nfunction startExp(min, max) {\r\n  const range = max - min;\r\n  let rangeExp = log10Floor(range);\r\n  while (steps(min, max, rangeExp) > 10) {\r\n    rangeExp++;\r\n  }\r\n  while (steps(min, max, rangeExp) < 10) {\r\n    rangeExp--;\r\n  }\r\n  return Math.min(rangeExp, log10Floor(min));\r\n}\r\n\r\n\r\n/**\r\n * Generate a set of logarithmic ticks\r\n * @param generationOptions the options used to generate the ticks\r\n * @param dataRange the range of the data\r\n * @returns {object[]} array of tick objects\r\n */\r\nfunction generateTicks(generationOptions, {min, max}) {\r\n  min = finiteOrDefault(generationOptions.min, min);\r\n  const ticks = [];\r\n  const minExp = log10Floor(min);\r\n  let exp = startExp(min, max);\r\n  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\r\n  const stepSize = Math.pow(10, exp);\r\n  const base = minExp > exp ? Math.pow(10, minExp) : 0;\r\n  const start = Math.round((min - base) * precision) / precision;\r\n  const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;\r\n  let significand = Math.floor((start - offset) / Math.pow(10, exp));\r\n  let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);\r\n  while (value < max) {\r\n    ticks.push({value, major: isMajor(value), significand});\r\n    if (significand >= 10) {\r\n      significand = significand < 15 ? 15 : 20;\r\n    } else {\r\n      significand++;\r\n    }\r\n    if (significand >= 20) {\r\n      exp++;\r\n      significand = 2;\r\n      precision = exp >= 0 ? 1 : precision;\r\n    }\r\n    value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;\r\n  }\r\n  const lastTick = finiteOrDefault(generationOptions.max, value);\r\n  ticks.push({value: lastTick, major: isMajor(lastTick), significand});\r\n\r\n  return ticks;\r\n}\r\n\r\nexport default class LogarithmicScale extends Scale {\r\n\r\n  static id = 'logarithmic';\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = {\r\n    ticks: {\r\n      callback: Ticks.formatters.logarithmic,\r\n      major: {\r\n        enabled: true\r\n      }\r\n    }\r\n  };\r\n\r\n\r\n  constructor(cfg) {\r\n    super(cfg);\r\n\r\n    /** @type {number} */\r\n    this.start = undefined;\r\n    /** @type {number} */\r\n    this.end = undefined;\r\n    /** @type {number} */\r\n    this._startValue = undefined;\r\n    this._valueRange = 0;\r\n  }\r\n\r\n  parse(raw, index) {\r\n    const value = LinearScaleBase.prototype.parse.apply(this, [raw, index]);\r\n    if (value === 0) {\r\n      this._zero = true;\r\n      return undefined;\r\n    }\r\n    return isFinite(value) && value > 0 ? value : null;\r\n  }\r\n\r\n  determineDataLimits() {\r\n    const {min, max} = this.getMinMax(true);\r\n\r\n    this.min = isFinite(min) ? Math.max(0, min) : null;\r\n    this.max = isFinite(max) ? Math.max(0, max) : null;\r\n\r\n    if (this.options.beginAtZero) {\r\n      this._zero = true;\r\n    }\r\n\r\n    // if data has `0` in it or `beginAtZero` is true, min (non zero) value is at bottom\r\n    // of scale, and it does not equal suggestedMin, lower the min bound by one exp.\r\n    if (this._zero && this.min !== this._suggestedMin && !isFinite(this._userMin)) {\r\n      this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);\r\n    }\r\n\r\n    this.handleTickRangeOptions();\r\n  }\r\n\r\n  handleTickRangeOptions() {\r\n    const {minDefined, maxDefined} = this.getUserBounds();\r\n    let min = this.min;\r\n    let max = this.max;\r\n\r\n    const setMin = v => (min = minDefined ? min : v);\r\n    const setMax = v => (max = maxDefined ? max : v);\r\n\r\n    if (min === max) {\r\n      if (min <= 0) { // includes null\r\n        setMin(1);\r\n        setMax(10);\r\n      } else {\r\n        setMin(changeExponent(min, -1));\r\n        setMax(changeExponent(max, +1));\r\n      }\r\n    }\r\n    if (min <= 0) {\r\n      setMin(changeExponent(max, -1));\r\n    }\r\n    if (max <= 0) {\r\n\r\n      setMax(changeExponent(min, +1));\r\n    }\r\n\r\n    this.min = min;\r\n    this.max = max;\r\n  }\r\n\r\n  buildTicks() {\r\n    const opts = this.options;\r\n\r\n    const generationOptions = {\r\n      min: this._userMin,\r\n      max: this._userMax\r\n    };\r\n    const ticks = generateTicks(generationOptions, this);\r\n\r\n    // At this point, we need to update our max and min given the tick values,\r\n    // since we probably have expanded the range of the scale\r\n    if (opts.bounds === 'ticks') {\r\n      _setMinAndMaxByKey(ticks, this, 'value');\r\n    }\r\n\r\n    if (opts.reverse) {\r\n      ticks.reverse();\r\n\r\n      this.start = this.max;\r\n      this.end = this.min;\r\n    } else {\r\n      this.start = this.min;\r\n      this.end = this.max;\r\n    }\r\n\r\n    return ticks;\r\n  }\r\n\r\n  /**\r\n\t * @param {number} value\r\n\t * @return {string}\r\n\t */\r\n  getLabelForValue(value) {\r\n    return value === undefined\r\n      ? '0'\r\n      : formatNumber(value, this.chart.options.locale, this.options.ticks.format);\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  configure() {\r\n    const start = this.min;\r\n\r\n    super.configure();\r\n\r\n    this._startValue = log10(start);\r\n    this._valueRange = log10(this.max) - log10(start);\r\n  }\r\n\r\n  getPixelForValue(value) {\r\n    if (value === undefined || value === 0) {\r\n      value = this.min;\r\n    }\r\n    if (value === null || isNaN(value)) {\r\n      return NaN;\r\n    }\r\n    return this.getPixelForDecimal(value === this.min\r\n      ? 0\r\n      : (log10(value) - this._startValue) / this._valueRange);\r\n  }\r\n\r\n  getValueForPixel(pixel) {\r\n    const decimal = this.getDecimalForPixel(pixel);\r\n    return Math.pow(10, this._startValue + decimal * this._valueRange);\r\n  }\r\n}\r\n","import defaults from '../core/core.defaults.js';\r\nimport {_longestText, addRoundedRectPath, renderText} from '../helpers/helpers.canvas.js';\r\nimport {HALF_PI, TAU, toDegrees, toRadians, _normalizeAngle, PI} from '../helpers/helpers.math.js';\r\nimport LinearScaleBase from './scale.linearbase.js';\r\nimport Ticks from '../core/core.ticks.js';\r\nimport {valueOrDefault, isArray, isFinite, callback as callCallback, isNullOrUndef} from '../helpers/helpers.core.js';\r\nimport {createContext, toFont, toPadding, toTRBLCorners} from '../helpers/helpers.options.js';\r\n\r\nfunction getTickBackdropHeight(opts) {\r\n  const tickOpts = opts.ticks;\r\n\r\n  if (tickOpts.display && opts.display) {\r\n    const padding = toPadding(tickOpts.backdropPadding);\r\n    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;\r\n  }\r\n  return 0;\r\n}\r\n\r\nfunction measureLabelSize(ctx, font, label) {\r\n  label = isArray(label) ? label : [label];\r\n  return {\r\n    w: _longestText(ctx, font.string, label),\r\n    h: label.length * font.lineHeight\r\n  };\r\n}\r\n\r\nfunction determineLimits(angle, pos, size, min, max) {\r\n  if (angle === min || angle === max) {\r\n    return {\r\n      start: pos - (size / 2),\r\n      end: pos + (size / 2)\r\n    };\r\n  } else if (angle < min || angle > max) {\r\n    return {\r\n      start: pos - size,\r\n      end: pos\r\n    };\r\n  }\r\n\r\n  return {\r\n    start: pos,\r\n    end: pos + size\r\n  };\r\n}\r\n\r\n/**\r\n * Helper function to fit a radial linear scale with point labels\r\n */\r\nfunction fitWithPointLabels(scale) {\r\n\r\n  // Right, this is really confusing and there is a lot of maths going on here\r\n  // The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\r\n  //\r\n  // Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\r\n  //\r\n  // Solution:\r\n  //\r\n  // We assume the radius of the polygon is half the size of the canvas at first\r\n  // at each index we check if the text overlaps.\r\n  //\r\n  // Where it does, we store that angle and that index.\r\n  //\r\n  // After finding the largest index and angle we calculate how much we need to remove\r\n  // from the shape radius to move the point inwards by that x.\r\n  //\r\n  // We average the left and right distances to get the maximum shape radius that can fit in the box\r\n  // along with labels.\r\n  //\r\n  // Once we have that, we can find the centre point for the chart, by taking the x text protrusion\r\n  // on each side, removing that from the size, halving it and adding the left x protrusion width.\r\n  //\r\n  // This will mean we have a shape fitted to the canvas, as large as it can be with the labels\r\n  // and position it in the most space efficient manner\r\n  //\r\n  // https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\r\n\r\n  // Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\r\n  // Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\r\n  const orig = {\r\n    l: scale.left + scale._padding.left,\r\n    r: scale.right - scale._padding.right,\r\n    t: scale.top + scale._padding.top,\r\n    b: scale.bottom - scale._padding.bottom\r\n  };\r\n  const limits = Object.assign({}, orig);\r\n  const labelSizes = [];\r\n  const padding = [];\r\n  const valueCount = scale._pointLabels.length;\r\n  const pointLabelOpts = scale.options.pointLabels;\r\n  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;\r\n\r\n  for (let i = 0; i < valueCount; i++) {\r\n    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));\r\n    padding[i] = opts.padding;\r\n    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);\r\n    const plFont = toFont(opts.font);\r\n    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\r\n    labelSizes[i] = textSize;\r\n\r\n    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);\r\n    const angle = Math.round(toDegrees(angleRadians));\r\n    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\r\n    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\r\n    updateLimits(limits, orig, angleRadians, hLimits, vLimits);\r\n  }\r\n\r\n  scale.setCenterPoint(\r\n    orig.l - limits.l,\r\n    limits.r - orig.r,\r\n    orig.t - limits.t,\r\n    limits.b - orig.b\r\n  );\r\n\r\n  // Now that text size is determined, compute the full positions\r\n  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\r\n}\r\n\r\nfunction updateLimits(limits, orig, angle, hLimits, vLimits) {\r\n  const sin = Math.abs(Math.sin(angle));\r\n  const cos = Math.abs(Math.cos(angle));\r\n  let x = 0;\r\n  let y = 0;\r\n  if (hLimits.start < orig.l) {\r\n    x = (orig.l - hLimits.start) / sin;\r\n    limits.l = Math.min(limits.l, orig.l - x);\r\n  } else if (hLimits.end > orig.r) {\r\n    x = (hLimits.end - orig.r) / sin;\r\n    limits.r = Math.max(limits.r, orig.r + x);\r\n  }\r\n  if (vLimits.start < orig.t) {\r\n    y = (orig.t - vLimits.start) / cos;\r\n    limits.t = Math.min(limits.t, orig.t - y);\r\n  } else if (vLimits.end > orig.b) {\r\n    y = (vLimits.end - orig.b) / cos;\r\n    limits.b = Math.max(limits.b, orig.b + y);\r\n  }\r\n}\r\n\r\nfunction buildPointLabelItems(scale, labelSizes, padding) {\r\n  const items = [];\r\n  const valueCount = scale._pointLabels.length;\r\n  const opts = scale.options;\r\n  const extra = getTickBackdropHeight(opts) / 2;\r\n  const outerDistance = scale.drawingArea;\r\n  const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;\r\n\r\n  for (let i = 0; i < valueCount; i++) {\r\n    const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);\r\n    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));\r\n    const size = labelSizes[i];\r\n    const y = yForAngle(pointLabelPosition.y, size.h, angle);\r\n    const textAlign = getTextAlignForAngle(angle);\r\n    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\r\n\r\n    items.push({\r\n      // Text position\r\n      x: pointLabelPosition.x,\r\n      y,\r\n\r\n      // Text rendering data\r\n      textAlign,\r\n\r\n      // Bounding box\r\n      left,\r\n      top: y,\r\n      right: left + size.w,\r\n      bottom: y + size.h\r\n    });\r\n  }\r\n  return items;\r\n}\r\n\r\nfunction getTextAlignForAngle(angle) {\r\n  if (angle === 0 || angle === 180) {\r\n    return 'center';\r\n  } else if (angle < 180) {\r\n    return 'left';\r\n  }\r\n\r\n  return 'right';\r\n}\r\n\r\nfunction leftForTextAlign(x, w, align) {\r\n  if (align === 'right') {\r\n    x -= w;\r\n  } else if (align === 'center') {\r\n    x -= (w / 2);\r\n  }\r\n  return x;\r\n}\r\n\r\nfunction yForAngle(y, h, angle) {\r\n  if (angle === 90 || angle === 270) {\r\n    y -= (h / 2);\r\n  } else if (angle > 270 || angle < 90) {\r\n    y -= h;\r\n  }\r\n  return y;\r\n}\r\n\r\nfunction drawPointLabels(scale, labelCount) {\r\n  const {ctx, options: {pointLabels}} = scale;\r\n\r\n  for (let i = labelCount - 1; i >= 0; i--) {\r\n    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\r\n    const plFont = toFont(optsAtIndex.font);\r\n    const {x, y, textAlign, left, top, right, bottom} = scale._pointLabelItems[i];\r\n    const {backdropColor} = optsAtIndex;\r\n\r\n    if (!isNullOrUndef(backdropColor)) {\r\n      const borderRadius = toTRBLCorners(optsAtIndex.borderRadius);\r\n      const padding = toPadding(optsAtIndex.backdropPadding);\r\n      ctx.fillStyle = backdropColor;\r\n\r\n      const backdropLeft = left - padding.left;\r\n      const backdropTop = top - padding.top;\r\n      const backdropWidth = right - left + padding.width;\r\n      const backdropHeight = bottom - top + padding.height;\r\n\r\n      if (Object.values(borderRadius).some(v => v !== 0)) {\r\n        ctx.beginPath();\r\n        addRoundedRectPath(ctx, {\r\n          x: backdropLeft,\r\n          y: backdropTop,\r\n          w: backdropWidth,\r\n          h: backdropHeight,\r\n          radius: borderRadius,\r\n        });\r\n        ctx.fill();\r\n      } else {\r\n        ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);\r\n      }\r\n    }\r\n\r\n    renderText(\r\n      ctx,\r\n      scale._pointLabels[i],\r\n      x,\r\n      y + (plFont.lineHeight / 2),\r\n      plFont,\r\n      {\r\n        color: optsAtIndex.color,\r\n        textAlign: textAlign,\r\n        textBaseline: 'middle'\r\n      }\r\n    );\r\n  }\r\n}\r\n\r\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\r\n  const {ctx} = scale;\r\n  if (circular) {\r\n    // Draw circular arcs between the points\r\n    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);\r\n  } else {\r\n    // Draw straight lines connecting each index\r\n    let pointPosition = scale.getPointPosition(0, radius);\r\n    ctx.moveTo(pointPosition.x, pointPosition.y);\r\n\r\n    for (let i = 1; i < labelCount; i++) {\r\n      pointPosition = scale.getPointPosition(i, radius);\r\n      ctx.lineTo(pointPosition.x, pointPosition.y);\r\n    }\r\n  }\r\n}\r\n\r\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {\r\n  const ctx = scale.ctx;\r\n  const circular = gridLineOpts.circular;\r\n\r\n  const {color, lineWidth} = gridLineOpts;\r\n\r\n  if ((!circular && !labelCount) || !color || !lineWidth || radius < 0) {\r\n    return;\r\n  }\r\n\r\n  ctx.save();\r\n  ctx.strokeStyle = color;\r\n  ctx.lineWidth = lineWidth;\r\n  ctx.setLineDash(borderOpts.dash);\r\n  ctx.lineDashOffset = borderOpts.dashOffset;\r\n\r\n  ctx.beginPath();\r\n  pathRadiusLine(scale, radius, circular, labelCount);\r\n  ctx.closePath();\r\n  ctx.stroke();\r\n  ctx.restore();\r\n}\r\n\r\nfunction createPointLabelContext(parent, index, label) {\r\n  return createContext(parent, {\r\n    label,\r\n    index,\r\n    type: 'pointLabel'\r\n  });\r\n}\r\n\r\nexport default class RadialLinearScale extends LinearScaleBase {\r\n\r\n  static id = 'radialLinear';\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = {\r\n    display: true,\r\n\r\n    // Boolean - Whether to animate scaling the chart from the centre\r\n    animate: true,\r\n    position: 'chartArea',\r\n\r\n    angleLines: {\r\n      display: true,\r\n      lineWidth: 1,\r\n      borderDash: [],\r\n      borderDashOffset: 0.0\r\n    },\r\n\r\n    grid: {\r\n      circular: false\r\n    },\r\n\r\n    startAngle: 0,\r\n\r\n    // label settings\r\n    ticks: {\r\n      // Boolean - Show a backdrop to the scale label\r\n      showLabelBackdrop: true,\r\n\r\n      callback: Ticks.formatters.numeric\r\n    },\r\n\r\n    pointLabels: {\r\n      backdropColor: undefined,\r\n\r\n      // Number - The backdrop padding above & below the label in pixels\r\n      backdropPadding: 2,\r\n\r\n      // Boolean - if true, show point labels\r\n      display: true,\r\n\r\n      // Number - Point label font size in pixels\r\n      font: {\r\n        size: 10\r\n      },\r\n\r\n      // Function - Used to convert point labels\r\n      callback(label) {\r\n        return label;\r\n      },\r\n\r\n      // Number - Additionl padding between scale and pointLabel\r\n      padding: 5,\r\n\r\n      // Boolean - if true, center point labels to slices in polar chart\r\n      centerPointLabels: false\r\n    }\r\n  };\r\n\r\n  static defaultRoutes = {\r\n    'angleLines.color': 'borderColor',\r\n    'pointLabels.color': 'color',\r\n    'ticks.color': 'color'\r\n  };\r\n\r\n  static descriptors = {\r\n    angleLines: {\r\n      _fallback: 'grid'\r\n    }\r\n  };\r\n\r\n  constructor(cfg) {\r\n    super(cfg);\r\n\r\n    /** @type {number} */\r\n    this.xCenter = undefined;\r\n    /** @type {number} */\r\n    this.yCenter = undefined;\r\n    /** @type {number} */\r\n    this.drawingArea = undefined;\r\n    /** @type {string[]} */\r\n    this._pointLabels = [];\r\n    this._pointLabelItems = [];\r\n  }\r\n\r\n  setDimensions() {\r\n    // Set the unconstrained dimension before label rotation\r\n    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);\r\n    const w = this.width = this.maxWidth - padding.width;\r\n    const h = this.height = this.maxHeight - padding.height;\r\n    this.xCenter = Math.floor(this.left + w / 2 + padding.left);\r\n    this.yCenter = Math.floor(this.top + h / 2 + padding.top);\r\n    this.drawingArea = Math.floor(Math.min(w, h) / 2);\r\n  }\r\n\r\n  determineDataLimits() {\r\n    const {min, max} = this.getMinMax(false);\r\n\r\n    this.min = isFinite(min) && !isNaN(min) ? min : 0;\r\n    this.max = isFinite(max) && !isNaN(max) ? max : 0;\r\n\r\n    // Common base implementation to handle min, max, beginAtZero\r\n    this.handleTickRangeOptions();\r\n  }\r\n\r\n  /**\r\n\t * Returns the maximum number of ticks based on the scale dimension\r\n\t * @protected\r\n\t */\r\n  computeTickLimit() {\r\n    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\r\n  }\r\n\r\n  generateTickLabels(ticks) {\r\n    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);\r\n\r\n    // Point labels\r\n    this._pointLabels = this.getLabels()\r\n      .map((value, index) => {\r\n        const label = callCallback(this.options.pointLabels.callback, [value, index], this);\r\n        return label || label === 0 ? label : '';\r\n      })\r\n      .filter((v, i) => this.chart.getDataVisibility(i));\r\n  }\r\n\r\n  fit() {\r\n    const opts = this.options;\r\n\r\n    if (opts.display && opts.pointLabels.display) {\r\n      fitWithPointLabels(this);\r\n    } else {\r\n      this.setCenterPoint(0, 0, 0, 0);\r\n    }\r\n  }\r\n\r\n  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\r\n    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);\r\n    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);\r\n    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));\r\n  }\r\n\r\n  getIndexAngle(index) {\r\n    const angleMultiplier = TAU / (this._pointLabels.length || 1);\r\n    const startAngle = this.options.startAngle || 0;\r\n\r\n    return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));\r\n  }\r\n\r\n  getDistanceFromCenterForValue(value) {\r\n    if (isNullOrUndef(value)) {\r\n      return NaN;\r\n    }\r\n\r\n    // Take into account half font size + the yPadding of the top value\r\n    const scalingFactor = this.drawingArea / (this.max - this.min);\r\n    if (this.options.reverse) {\r\n      return (this.max - value) * scalingFactor;\r\n    }\r\n    return (value - this.min) * scalingFactor;\r\n  }\r\n\r\n  getValueForDistanceFromCenter(distance) {\r\n    if (isNullOrUndef(distance)) {\r\n      return NaN;\r\n    }\r\n\r\n    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));\r\n    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;\r\n  }\r\n\r\n  getPointLabelContext(index) {\r\n    const pointLabels = this._pointLabels || [];\r\n\r\n    if (index >= 0 && index < pointLabels.length) {\r\n      const pointLabel = pointLabels[index];\r\n      return createPointLabelContext(this.getContext(), index, pointLabel);\r\n    }\r\n  }\r\n\r\n  getPointPosition(index, distanceFromCenter, additionalAngle = 0) {\r\n    const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;\r\n    return {\r\n      x: Math.cos(angle) * distanceFromCenter + this.xCenter,\r\n      y: Math.sin(angle) * distanceFromCenter + this.yCenter,\r\n      angle\r\n    };\r\n  }\r\n\r\n  getPointPositionForValue(index, value) {\r\n    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\r\n  }\r\n\r\n  getBasePosition(index) {\r\n    return this.getPointPositionForValue(index || 0, this.getBaseValue());\r\n  }\r\n\r\n  getPointLabelPosition(index) {\r\n    const {left, top, right, bottom} = this._pointLabelItems[index];\r\n    return {\r\n      left,\r\n      top,\r\n      right,\r\n      bottom,\r\n    };\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  drawBackground() {\r\n    const {backgroundColor, grid: {circular}} = this.options;\r\n    if (backgroundColor) {\r\n      const ctx = this.ctx;\r\n      ctx.save();\r\n      ctx.beginPath();\r\n      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);\r\n      ctx.closePath();\r\n      ctx.fillStyle = backgroundColor;\r\n      ctx.fill();\r\n      ctx.restore();\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  drawGrid() {\r\n    const ctx = this.ctx;\r\n    const opts = this.options;\r\n    const {angleLines, grid, border} = opts;\r\n    const labelCount = this._pointLabels.length;\r\n\r\n    let i, offset, position;\r\n\r\n    if (opts.pointLabels.display) {\r\n      drawPointLabels(this, labelCount);\r\n    }\r\n\r\n    if (grid.display) {\r\n      this.ticks.forEach((tick, index) => {\r\n        if (index !== 0) {\r\n          offset = this.getDistanceFromCenterForValue(tick.value);\r\n          const context = this.getContext(index);\r\n          const optsAtIndex = grid.setContext(context);\r\n          const optsAtIndexBorder = border.setContext(context);\r\n\r\n          drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);\r\n        }\r\n      });\r\n    }\r\n\r\n    if (angleLines.display) {\r\n      ctx.save();\r\n\r\n      for (i = labelCount - 1; i >= 0; i--) {\r\n        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));\r\n        const {color, lineWidth} = optsAtIndex;\r\n\r\n        if (!lineWidth || !color) {\r\n          continue;\r\n        }\r\n\r\n        ctx.lineWidth = lineWidth;\r\n        ctx.strokeStyle = color;\r\n\r\n        ctx.setLineDash(optsAtIndex.borderDash);\r\n        ctx.lineDashOffset = optsAtIndex.borderDashOffset;\r\n\r\n        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);\r\n        position = this.getPointPosition(i, offset);\r\n        ctx.beginPath();\r\n        ctx.moveTo(this.xCenter, this.yCenter);\r\n        ctx.lineTo(position.x, position.y);\r\n        ctx.stroke();\r\n      }\r\n\r\n      ctx.restore();\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  drawBorder() {}\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  drawLabels() {\r\n    const ctx = this.ctx;\r\n    const opts = this.options;\r\n    const tickOpts = opts.ticks;\r\n\r\n    if (!tickOpts.display) {\r\n      return;\r\n    }\r\n\r\n    const startAngle = this.getIndexAngle(0);\r\n    let offset, width;\r\n\r\n    ctx.save();\r\n    ctx.translate(this.xCenter, this.yCenter);\r\n    ctx.rotate(startAngle);\r\n    ctx.textAlign = 'center';\r\n    ctx.textBaseline = 'middle';\r\n\r\n    this.ticks.forEach((tick, index) => {\r\n      if (index === 0 && !opts.reverse) {\r\n        return;\r\n      }\r\n\r\n      const optsAtIndex = tickOpts.setContext(this.getContext(index));\r\n      const tickFont = toFont(optsAtIndex.font);\r\n      offset = this.getDistanceFromCenterForValue(this.ticks[index].value);\r\n\r\n      if (optsAtIndex.showLabelBackdrop) {\r\n        ctx.font = tickFont.string;\r\n        width = ctx.measureText(tick.label).width;\r\n        ctx.fillStyle = optsAtIndex.backdropColor;\r\n\r\n        const padding = toPadding(optsAtIndex.backdropPadding);\r\n        ctx.fillRect(\r\n          -width / 2 - padding.left,\r\n          -offset - tickFont.size / 2 - padding.top,\r\n          width + padding.width,\r\n          tickFont.size + padding.height\r\n        );\r\n      }\r\n\r\n      renderText(ctx, tick.label, 0, -offset, tickFont, {\r\n        color: optsAtIndex.color,\r\n      });\r\n    });\r\n\r\n    ctx.restore();\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  drawTitle() {}\r\n}\r\n","import adapters from '../core/core.adapters.js';\r\nimport {callback as call, isFinite, isNullOrUndef, mergeIf, valueOrDefault} from '../helpers/helpers.core.js';\r\nimport {toRadians, isNumber, _limitValue} from '../helpers/helpers.math.js';\r\nimport Scale from '../core/core.scale.js';\r\nimport {_arrayUnique, _filterBetween, _lookup} from '../helpers/helpers.collection.js';\r\n\r\n/**\r\n * @typedef { import('../core/core.adapters.js').TimeUnit } Unit\r\n * @typedef {{common: boolean, size: number, steps?: number}} Interval\r\n * @typedef { import('../core/core.adapters.js').DateAdapter } DateAdapter\r\n */\r\n\r\n/**\r\n * @type {Object<Unit, Interval>}\r\n */\r\nconst INTERVALS = {\r\n  millisecond: {common: true, size: 1, steps: 1000},\r\n  second: {common: true, size: 1000, steps: 60},\r\n  minute: {common: true, size: 60000, steps: 60},\r\n  hour: {common: true, size: 3600000, steps: 24},\r\n  day: {common: true, size: 86400000, steps: 30},\r\n  week: {common: false, size: 604800000, steps: 4},\r\n  month: {common: true, size: 2.628e9, steps: 12},\r\n  quarter: {common: false, size: 7.884e9, steps: 4},\r\n  year: {common: true, size: 3.154e10}\r\n};\r\n\r\n/**\r\n * @type {Unit[]}\r\n */\r\nconst UNITS = /** @type Unit[] */ /* #__PURE__ */ (Object.keys(INTERVALS));\r\n\r\n/**\r\n * @param {number} a\r\n * @param {number} b\r\n */\r\nfunction sorter(a, b) {\r\n  return a - b;\r\n}\r\n\r\n/**\r\n * @param {TimeScale} scale\r\n * @param {*} input\r\n * @return {number}\r\n */\r\nfunction parse(scale, input) {\r\n  if (isNullOrUndef(input)) {\r\n    return null;\r\n  }\r\n\r\n  const adapter = scale._adapter;\r\n  const {parser, round, isoWeekday} = scale._parseOpts;\r\n  let value = input;\r\n\r\n  if (typeof parser === 'function') {\r\n    value = parser(value);\r\n  }\r\n\r\n  // Only parse if its not a timestamp already\r\n  if (!isFinite(value)) {\r\n    value = typeof parser === 'string'\r\n      ? adapter.parse(value, /** @type {Unit} */ (parser))\r\n      : adapter.parse(value);\r\n  }\r\n\r\n  if (value === null) {\r\n    return null;\r\n  }\r\n\r\n  if (round) {\r\n    value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true)\r\n      ? adapter.startOf(value, 'isoWeek', isoWeekday)\r\n      : adapter.startOf(value, round);\r\n  }\r\n\r\n  return +value;\r\n}\r\n\r\n/**\r\n * Figures out what unit results in an appropriate number of auto-generated ticks\r\n * @param {Unit} minUnit\r\n * @param {number} min\r\n * @param {number} max\r\n * @param {number} capacity\r\n * @return {object}\r\n */\r\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\r\n  const ilen = UNITS.length;\r\n\r\n  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\r\n    const interval = INTERVALS[UNITS[i]];\r\n    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\r\n\r\n    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\r\n      return UNITS[i];\r\n    }\r\n  }\r\n\r\n  return UNITS[ilen - 1];\r\n}\r\n\r\n/**\r\n * Figures out what unit to format a set of ticks with\r\n * @param {TimeScale} scale\r\n * @param {number} numTicks\r\n * @param {Unit} minUnit\r\n * @param {number} min\r\n * @param {number} max\r\n * @return {Unit}\r\n */\r\nfunction determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\r\n  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {\r\n    const unit = UNITS[i];\r\n    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\r\n      return unit;\r\n    }\r\n  }\r\n\r\n  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\r\n}\r\n\r\n/**\r\n * @param {Unit} unit\r\n * @return {object}\r\n */\r\nfunction determineMajorUnit(unit) {\r\n  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\r\n    if (INTERVALS[UNITS[i]].common) {\r\n      return UNITS[i];\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @param {object} ticks\r\n * @param {number} time\r\n * @param {number[]} [timestamps] - if defined, snap to these timestamps\r\n */\r\nfunction addTick(ticks, time, timestamps) {\r\n  if (!timestamps) {\r\n    ticks[time] = true;\r\n  } else if (timestamps.length) {\r\n    const {lo, hi} = _lookup(timestamps, time);\r\n    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\r\n    ticks[timestamp] = true;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {TimeScale} scale\r\n * @param {object[]} ticks\r\n * @param {object} map\r\n * @param {Unit} majorUnit\r\n * @return {object[]}\r\n */\r\nfunction setMajorTicks(scale, ticks, map, majorUnit) {\r\n  const adapter = scale._adapter;\r\n  const first = +adapter.startOf(ticks[0].value, majorUnit);\r\n  const last = ticks[ticks.length - 1].value;\r\n  let major, index;\r\n\r\n  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {\r\n    index = map[major];\r\n    if (index >= 0) {\r\n      ticks[index].major = true;\r\n    }\r\n  }\r\n  return ticks;\r\n}\r\n\r\n/**\r\n * @param {TimeScale} scale\r\n * @param {number[]} values\r\n * @param {Unit|undefined} [majorUnit]\r\n * @return {object[]}\r\n */\r\nfunction ticksFromTimestamps(scale, values, majorUnit) {\r\n  const ticks = [];\r\n  /** @type {Object<number,object>} */\r\n  const map = {};\r\n  const ilen = values.length;\r\n  let i, value;\r\n\r\n  for (i = 0; i < ilen; ++i) {\r\n    value = values[i];\r\n    map[value] = i;\r\n\r\n    ticks.push({\r\n      value,\r\n      major: false\r\n    });\r\n  }\r\n\r\n  // We set the major ticks separately from the above loop because calling startOf for every tick\r\n  // is expensive when there is a large number of ticks\r\n  return (ilen === 0 || !majorUnit) ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\r\n}\r\n\r\nexport default class TimeScale extends Scale {\r\n\r\n  static id = 'time';\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = {\r\n    /**\r\n     * Scale boundary strategy (bypassed by min/max time options)\r\n     * - `data`: make sure data are fully visible, ticks outside are removed\r\n     * - `ticks`: make sure ticks are fully visible, data outside are truncated\r\n     * @see https://github.com/chartjs/Chart.js/pull/4556\r\n     * @since 2.7.0\r\n     */\r\n    bounds: 'data',\r\n\r\n    adapters: {},\r\n    time: {\r\n      parser: false, // false == a pattern string from or a custom callback that converts its argument to a timestamp\r\n      unit: false, // false == automatic or override with week, month, year, etc.\r\n      round: false, // none, or override with week, month, year, etc.\r\n      isoWeekday: false, // override week start day\r\n      minUnit: 'millisecond',\r\n      displayFormats: {}\r\n    },\r\n    ticks: {\r\n      /**\r\n       * Ticks generation input values:\r\n       * - 'auto': generates \"optimal\" ticks based on scale size and time options.\r\n       * - 'data': generates ticks from data (including labels from data {t|x|y} objects).\r\n       * - 'labels': generates ticks from user given `data.labels` values ONLY.\r\n       * @see https://github.com/chartjs/Chart.js/pull/4507\r\n       * @since 2.7.0\r\n       */\r\n      source: 'auto',\r\n\r\n      callback: false,\r\n\r\n      major: {\r\n        enabled: false\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n\t * @param {object} props\r\n\t */\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    /** @type {{data: number[], labels: number[], all: number[]}} */\r\n    this._cache = {\r\n      data: [],\r\n      labels: [],\r\n      all: []\r\n    };\r\n\r\n    /** @type {Unit} */\r\n    this._unit = 'day';\r\n    /** @type {Unit=} */\r\n    this._majorUnit = undefined;\r\n    this._offsets = {};\r\n    this._normalized = false;\r\n    this._parseOpts = undefined;\r\n  }\r\n\r\n  init(scaleOpts, opts = {}) {\r\n    const time = scaleOpts.time || (scaleOpts.time = {});\r\n    /** @type {DateAdapter} */\r\n    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);\r\n\r\n    adapter.init(opts);\r\n\r\n    // Backward compatibility: before introducing adapter, `displayFormats` was\r\n    // supposed to contain *all* unit/string pairs but this can't be resolved\r\n    // when loading the scale (adapters are loaded afterward), so let's populate\r\n    // missing formats on update\r\n    mergeIf(time.displayFormats, adapter.formats());\r\n\r\n    this._parseOpts = {\r\n      parser: time.parser,\r\n      round: time.round,\r\n      isoWeekday: time.isoWeekday\r\n    };\r\n\r\n    super.init(scaleOpts);\r\n\r\n    this._normalized = opts.normalized;\r\n  }\r\n\r\n  /**\r\n\t * @param {*} raw\r\n\t * @param {number?} [index]\r\n\t * @return {number}\r\n\t */\r\n  parse(raw, index) { // eslint-disable-line no-unused-vars\r\n    if (raw === undefined) {\r\n      return null;\r\n    }\r\n    return parse(this, raw);\r\n  }\r\n\r\n  beforeLayout() {\r\n    super.beforeLayout();\r\n    this._cache = {\r\n      data: [],\r\n      labels: [],\r\n      all: []\r\n    };\r\n  }\r\n\r\n  determineDataLimits() {\r\n    const options = this.options;\r\n    const adapter = this._adapter;\r\n    const unit = options.time.unit || 'day';\r\n    // eslint-disable-next-line prefer-const\r\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\r\n\r\n    /**\r\n\t\t * @param {object} bounds\r\n\t\t */\r\n    function _applyBounds(bounds) {\r\n      if (!minDefined && !isNaN(bounds.min)) {\r\n        min = Math.min(min, bounds.min);\r\n      }\r\n      if (!maxDefined && !isNaN(bounds.max)) {\r\n        max = Math.max(max, bounds.max);\r\n      }\r\n    }\r\n\r\n    // If we have user provided `min` and `max` labels / data bounds can be ignored\r\n    if (!minDefined || !maxDefined) {\r\n      // Labels are always considered, when user did not force bounds\r\n      _applyBounds(this._getLabelBounds());\r\n\r\n      // If `bounds` is `'ticks'` and `ticks.source` is `'labels'`,\r\n      // data bounds are ignored (and don't need to be determined)\r\n      if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {\r\n        _applyBounds(this.getMinMax(false));\r\n      }\r\n    }\r\n\r\n    min = isFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\r\n    max = isFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\r\n\r\n    // Make sure that max is strictly higher than min (required by the timeseries lookup table)\r\n    this.min = Math.min(min, max - 1);\r\n    this.max = Math.max(min + 1, max);\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _getLabelBounds() {\r\n    const arr = this.getLabelTimestamps();\r\n    let min = Number.POSITIVE_INFINITY;\r\n    let max = Number.NEGATIVE_INFINITY;\r\n\r\n    if (arr.length) {\r\n      min = arr[0];\r\n      max = arr[arr.length - 1];\r\n    }\r\n    return {min, max};\r\n  }\r\n\r\n  /**\r\n\t * @return {object[]}\r\n\t */\r\n  buildTicks() {\r\n    const options = this.options;\r\n    const timeOpts = options.time;\r\n    const tickOpts = options.ticks;\r\n    const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();\r\n\r\n    if (options.bounds === 'ticks' && timestamps.length) {\r\n      this.min = this._userMin || timestamps[0];\r\n      this.max = this._userMax || timestamps[timestamps.length - 1];\r\n    }\r\n\r\n    const min = this.min;\r\n    const max = this.max;\r\n\r\n    const ticks = _filterBetween(timestamps, min, max);\r\n\r\n    // PRIVATE\r\n    // determineUnitForFormatting relies on the number of ticks so we don't use it when\r\n    // autoSkip is enabled because we don't yet know what the final number of ticks will be\r\n    this._unit = timeOpts.unit || (tickOpts.autoSkip\r\n      ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min))\r\n      : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));\r\n    this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined\r\n      : determineMajorUnit(this._unit);\r\n    this.initOffsets(timestamps);\r\n\r\n    if (options.reverse) {\r\n      ticks.reverse();\r\n    }\r\n\r\n    return ticksFromTimestamps(this, ticks, this._majorUnit);\r\n  }\r\n\r\n  afterAutoSkip() {\r\n    // Offsets for bar charts need to be handled with the auto skipped\r\n    // ticks. Once ticks have been skipped, we re-compute the offsets.\r\n    if (this.options.offsetAfterAutoskip) {\r\n      this.initOffsets(this.ticks.map(tick => +tick.value));\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * Returns the start and end offsets from edges in the form of {start, end}\r\n\t * where each value is a relative width to the scale and ranges between 0 and 1.\r\n\t * They add extra margins on the both sides by scaling down the original scale.\r\n\t * Offsets are added when the `offset` option is true.\r\n\t * @param {number[]} timestamps\r\n\t * @protected\r\n\t */\r\n  initOffsets(timestamps = []) {\r\n    let start = 0;\r\n    let end = 0;\r\n    let first, last;\r\n\r\n    if (this.options.offset && timestamps.length) {\r\n      first = this.getDecimalForValue(timestamps[0]);\r\n      if (timestamps.length === 1) {\r\n        start = 1 - first;\r\n      } else {\r\n        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;\r\n      }\r\n      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);\r\n      if (timestamps.length === 1) {\r\n        end = last;\r\n      } else {\r\n        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\r\n      }\r\n    }\r\n    const limit = timestamps.length < 3 ? 0.5 : 0.25;\r\n    start = _limitValue(start, 0, limit);\r\n    end = _limitValue(end, 0, limit);\r\n\r\n    this._offsets = {start, end, factor: 1 / (start + 1 + end)};\r\n  }\r\n\r\n  /**\r\n\t * Generates a maximum of `capacity` timestamps between min and max, rounded to the\r\n\t * `minor` unit using the given scale time `options`.\r\n\t * Important: this method can return ticks outside the min and max range, it's the\r\n\t * responsibility of the calling code to clamp values if needed.\r\n\t * @private\r\n\t */\r\n  _generate() {\r\n    const adapter = this._adapter;\r\n    const min = this.min;\r\n    const max = this.max;\r\n    const options = this.options;\r\n    const timeOpts = options.time;\r\n    // @ts-ignore\r\n    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));\r\n    const stepSize = valueOrDefault(options.ticks.stepSize, 1);\r\n    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\r\n    const hasWeekday = isNumber(weekday) || weekday === true;\r\n    const ticks = {};\r\n    let first = min;\r\n    let time, count;\r\n\r\n    // For 'week' unit, handle the first day of week option\r\n    if (hasWeekday) {\r\n      first = +adapter.startOf(first, 'isoWeek', weekday);\r\n    }\r\n\r\n    // Align first ticks on unit\r\n    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\r\n\r\n    // Prevent browser from freezing in case user options request millions of milliseconds\r\n    if (adapter.diff(max, min, minor) > 100000 * stepSize) {\r\n      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\r\n    }\r\n\r\n    const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();\r\n    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {\r\n      addTick(ticks, time, timestamps);\r\n    }\r\n\r\n    if (time === max || options.bounds === 'ticks' || count === 1) {\r\n      addTick(ticks, time, timestamps);\r\n    }\r\n\r\n    // @ts-ignore\r\n    return Object.keys(ticks).sort((a, b) => a - b).map(x => +x);\r\n  }\r\n\r\n  /**\r\n\t * @param {number} value\r\n\t * @return {string}\r\n\t */\r\n  getLabelForValue(value) {\r\n    const adapter = this._adapter;\r\n    const timeOpts = this.options.time;\r\n\r\n    if (timeOpts.tooltipFormat) {\r\n      return adapter.format(value, timeOpts.tooltipFormat);\r\n    }\r\n    return adapter.format(value, timeOpts.displayFormats.datetime);\r\n  }\r\n\r\n  /**\r\n\t * @param {number} value\r\n\t * @param {string|undefined} format\r\n\t * @return {string}\r\n\t */\r\n  format(value, format) {\r\n    const options = this.options;\r\n    const formats = options.time.displayFormats;\r\n    const unit = this._unit;\r\n    const fmt = format || formats[unit];\r\n    return this._adapter.format(value, fmt);\r\n  }\r\n\r\n  /**\r\n\t * Function to format an individual tick mark\r\n\t * @param {number} time\r\n\t * @param {number} index\r\n\t * @param {object[]} ticks\r\n\t * @param {string|undefined} [format]\r\n\t * @return {string}\r\n\t * @private\r\n\t */\r\n  _tickFormatFunction(time, index, ticks, format) {\r\n    const options = this.options;\r\n    const formatter = options.ticks.callback;\r\n\r\n    if (formatter) {\r\n      return call(formatter, [time, index, ticks], this);\r\n    }\r\n\r\n    const formats = options.time.displayFormats;\r\n    const unit = this._unit;\r\n    const majorUnit = this._majorUnit;\r\n    const minorFormat = unit && formats[unit];\r\n    const majorFormat = majorUnit && formats[majorUnit];\r\n    const tick = ticks[index];\r\n    const major = majorUnit && majorFormat && tick && tick.major;\r\n\r\n    return this._adapter.format(time, format || (major ? majorFormat : minorFormat));\r\n  }\r\n\r\n  /**\r\n\t * @param {object[]} ticks\r\n\t */\r\n  generateTickLabels(ticks) {\r\n    let i, ilen, tick;\r\n\r\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\r\n      tick = ticks[i];\r\n      tick.label = this._tickFormatFunction(tick.value, i, ticks);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)\r\n\t * @return {number}\r\n\t */\r\n  getDecimalForValue(value) {\r\n    return value === null ? NaN : (value - this.min) / (this.max - this.min);\r\n  }\r\n\r\n  /**\r\n\t * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)\r\n\t * @return {number}\r\n\t */\r\n  getPixelForValue(value) {\r\n    const offsets = this._offsets;\r\n    const pos = this.getDecimalForValue(value);\r\n    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);\r\n  }\r\n\r\n  /**\r\n\t * @param {number} pixel\r\n\t * @return {number}\r\n\t */\r\n  getValueForPixel(pixel) {\r\n    const offsets = this._offsets;\r\n    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\r\n    return this.min + pos * (this.max - this.min);\r\n  }\r\n\r\n  /**\r\n\t * @param {string} label\r\n\t * @return {{w:number, h:number}}\r\n\t * @private\r\n\t */\r\n  _getLabelSize(label) {\r\n    const ticksOpts = this.options.ticks;\r\n    const tickLabelWidth = this.ctx.measureText(label).width;\r\n    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\r\n    const cosRotation = Math.cos(angle);\r\n    const sinRotation = Math.sin(angle);\r\n    const tickFontSize = this._resolveTickFontOptions(0).size;\r\n\r\n    return {\r\n      w: (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation),\r\n      h: (tickLabelWidth * sinRotation) + (tickFontSize * cosRotation)\r\n    };\r\n  }\r\n\r\n  /**\r\n\t * @param {number} exampleTime\r\n\t * @return {number}\r\n\t * @private\r\n\t */\r\n  _getLabelCapacity(exampleTime) {\r\n    const timeOpts = this.options.time;\r\n    const displayFormats = timeOpts.displayFormats;\r\n\r\n    // pick the longest format (milliseconds) for guestimation\r\n    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\r\n    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);\r\n    const size = this._getLabelSize(exampleLabel);\r\n    // subtract 1 - if offset then there's one less label than tick\r\n    // if not offset then one half label padding is added to each end leaving room for one less label\r\n    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;\r\n    return capacity > 0 ? capacity : 1;\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  getDataTimestamps() {\r\n    let timestamps = this._cache.data || [];\r\n    let i, ilen;\r\n\r\n    if (timestamps.length) {\r\n      return timestamps;\r\n    }\r\n\r\n    const metas = this.getMatchingVisibleMetas();\r\n\r\n    if (this._normalized && metas.length) {\r\n      return (this._cache.data = metas[0].controller.getAllParsedValues(this));\r\n    }\r\n\r\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\r\n      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));\r\n    }\r\n\r\n    return (this._cache.data = this.normalize(timestamps));\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  getLabelTimestamps() {\r\n    const timestamps = this._cache.labels || [];\r\n    let i, ilen;\r\n\r\n    if (timestamps.length) {\r\n      return timestamps;\r\n    }\r\n\r\n    const labels = this.getLabels();\r\n    for (i = 0, ilen = labels.length; i < ilen; ++i) {\r\n      timestamps.push(parse(this, labels[i]));\r\n    }\r\n\r\n    return (this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps));\r\n  }\r\n\r\n  /**\r\n\t * @param {number[]} values\r\n\t * @protected\r\n\t */\r\n  normalize(values) {\r\n    // It seems to be somewhat faster to do sorting first\r\n    return _arrayUnique(values.sort(sorter));\r\n  }\r\n}\r\n","import TimeScale from './scale.time.js';\r\nimport {_lookupByKey} from '../helpers/helpers.collection.js';\r\n\r\n/**\r\n * Linearly interpolates the given source `val` using the table. If value is out of bounds, values\r\n * at edges are used for the interpolation.\r\n * @param {object} table\r\n * @param {number} val\r\n * @param {boolean} [reverse] lookup time based on position instead of vice versa\r\n * @return {object}\r\n */\r\nfunction interpolate(table, val, reverse) {\r\n  let lo = 0;\r\n  let hi = table.length - 1;\r\n  let prevSource, nextSource, prevTarget, nextTarget;\r\n  if (reverse) {\r\n    if (val >= table[lo].pos && val <= table[hi].pos) {\r\n      ({lo, hi} = _lookupByKey(table, 'pos', val));\r\n    }\r\n    ({pos: prevSource, time: prevTarget} = table[lo]);\r\n    ({pos: nextSource, time: nextTarget} = table[hi]);\r\n  } else {\r\n    if (val >= table[lo].time && val <= table[hi].time) {\r\n      ({lo, hi} = _lookupByKey(table, 'time', val));\r\n    }\r\n    ({time: prevSource, pos: prevTarget} = table[lo]);\r\n    ({time: nextSource, pos: nextTarget} = table[hi]);\r\n  }\r\n\r\n  const span = nextSource - prevSource;\r\n  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\r\n}\r\n\r\nclass TimeSeriesScale extends TimeScale {\r\n\r\n  static id = 'timeseries';\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = TimeScale.defaults;\r\n\r\n  /**\r\n\t * @param {object} props\r\n\t */\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    /** @type {object[]} */\r\n    this._table = [];\r\n    /** @type {number} */\r\n    this._minPos = undefined;\r\n    /** @type {number} */\r\n    this._tableRange = undefined;\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  initOffsets() {\r\n    const timestamps = this._getTimestampsForTable();\r\n    const table = this._table = this.buildLookupTable(timestamps);\r\n    this._minPos = interpolate(table, this.min);\r\n    this._tableRange = interpolate(table, this.max) - this._minPos;\r\n    super.initOffsets(timestamps);\r\n  }\r\n\r\n  /**\r\n\t * Returns an array of {time, pos} objects used to interpolate a specific `time` or position\r\n\t * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is\r\n\t * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other\r\n\t * extremity (left + width or top + height). Note that it would be more optimized to directly\r\n\t * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need\r\n\t * to create the lookup table. The table ALWAYS contains at least two items: min and max.\r\n\t * @param {number[]} timestamps\r\n\t * @return {object[]}\r\n\t * @protected\r\n\t */\r\n  buildLookupTable(timestamps) {\r\n    const {min, max} = this;\r\n    const items = [];\r\n    const table = [];\r\n    let i, ilen, prev, curr, next;\r\n\r\n    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {\r\n      curr = timestamps[i];\r\n      if (curr >= min && curr <= max) {\r\n        items.push(curr);\r\n      }\r\n    }\r\n\r\n    if (items.length < 2) {\r\n      // In case there is less that 2 timestamps between min and max, the scale is defined by min and max\r\n      return [\r\n        {time: min, pos: 0},\r\n        {time: max, pos: 1}\r\n      ];\r\n    }\r\n\r\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\r\n      next = items[i + 1];\r\n      prev = items[i - 1];\r\n      curr = items[i];\r\n\r\n      // only add points that breaks the scale linearity\r\n      if (Math.round((next + prev) / 2) !== curr) {\r\n        table.push({time: curr, pos: i / (ilen - 1)});\r\n      }\r\n    }\r\n    return table;\r\n  }\r\n\r\n  /**\r\n\t * Returns all timestamps\r\n\t * @return {number[]}\r\n\t * @private\r\n\t */\r\n  _getTimestampsForTable() {\r\n    let timestamps = this._cache.all || [];\r\n\r\n    if (timestamps.length) {\r\n      return timestamps;\r\n    }\r\n\r\n    const data = this.getDataTimestamps();\r\n    const label = this.getLabelTimestamps();\r\n    if (data.length && label.length) {\r\n      // If combining labels and data (data might not contain all labels),\r\n      // we need to recheck uniqueness and sort\r\n      timestamps = this.normalize(data.concat(label));\r\n    } else {\r\n      timestamps = data.length ? data : label;\r\n    }\r\n    timestamps = this._cache.all = timestamps;\r\n\r\n    return timestamps;\r\n  }\r\n\r\n  /**\r\n\t * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)\r\n\t * @return {number}\r\n\t */\r\n  getDecimalForValue(value) {\r\n    return (interpolate(this._table, value) - this._minPos) / this._tableRange;\r\n  }\r\n\r\n  /**\r\n\t * @param {number} pixel\r\n\t * @return {number}\r\n\t */\r\n  getValueForPixel(pixel) {\r\n    const offsets = this._offsets;\r\n    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\r\n    return interpolate(this._table, decimal * this._tableRange + this._minPos, true);\r\n  }\r\n}\r\n\r\nexport default TimeSeriesScale;\r\n","export * from './controllers/index.js';\r\nexport * from './core/index.js';\r\nexport * from './elements/index.js';\r\nexport * from './platform/index.js';\r\nexport * from './plugins/index.js';\r\nexport * from './scales/index.js';\r\n\r\nimport * as controllers from './controllers/index.js';\r\nimport * as elements from './elements/index.js';\r\nimport * as plugins from './plugins/index.js';\r\nimport * as scales from './scales/index.js';\r\n\r\nexport {\r\n  controllers,\r\n  elements,\r\n  plugins,\r\n  scales,\r\n};\r\n\r\nexport const registerables = [\r\n  controllers,\r\n  elements,\r\n  plugins,\r\n  scales,\r\n];\r\n"],"names":["anims","numSteps","callbacks","fn","chart","initial","_request","remaining","_charts","forEach","items","i","item","_active","_total","date","draw","_notify","length","running","_lastDate","charts","get","complete","progress","start","Date","acc","cur","Math","transparent","interpolators","boolean","from","to","factor","number","helpersColor","Animation","constructor","target","cfg","currentValue","resolve","_duration","_loop","_target","_prop","prop","_from","_to","_promises","undefined","update","elapsed","_start","floor","max","loop","tick","duration","promises","Promise","res","rej","method","Animations","config","_chart","_properties","Map","configure","isObject","animationOptions","Object","keys","defaults","animation","animatedProps","getOwnPropertyNames","key","resolved","option","isArray","properties","has","set","newOptions","charAt","animations","value","assign","anim","active","push","options","$shared","$animations","min","reverse","yScale","allowedOverflow","x","y","top","right","bottom","left","toClip","t","r","b","l","disabled","ilen","metasets","applyStack","otherValue","datasetIndex","stack","isFinite","sign","convertObjectDataToArray","adata","data","scale","indexScale","id","meta","getUserBounds","minDefined","Number","maxDefined","stacks","subStack","getLastIndexInStack","vScale","getMatchingVisibleMetas","type","positive","iAxis","vAxis","axis","iScale","itemStacks","_stacks","_top","_bottom","visualValues","_visualValues","scales","parent","createContext","index","mode","raw","element","parsed","cloneIfNotShared","getSortedDatasetIndices","values","DatasetController","_ctx","ctx","_cachedMeta","_drawCount","enableOptionSharing","supportsDecimation","$context","_syncList","datasetElementType","dataElementType","linkScales","_stacked","addElements","console","updateIndex","dataset","yid","rid","indexAxis","vAxisID","getScaleForId","vid","valueOrDefault","datasets","_data","unlistenArrayEvents","clearStacks","_parsed","oldStacked","isStacked","listenArrayEvents","stackChanged","resetNewElements","_parsing","sorted","parsePrimitiveData","prev","count","updateStacks","labels","parse","xScale","resolveObjectKey","getParsed","updateRangeFromParsed","parsedValue","range","otherScale","_skip","label","elements","area","context","dataIndex","_resolveElementOptions","cache","_cachedDataOpts","cacheKey","cached","elementType","scopes","getOptionScopes","names","resolveNamedOptions","_sharedOptions","resolveDataElementOptions","previouslySharedOptions","getSharedOptions","firstOpts","updateSharedOptions","sharedOptions","includeOptions","defined","removeHoverStyle","setHoverStyle","_resyncElements","arg2","numData","numMeta","_insertElements","_removeElements","move","arr","end","removed","args","newCount","_onDataUnshift","arguments","getAllScaleValues","_cache","$bar","visibleMetas","concat","controller","getAllParsedValues","_arrayUnique","sort","a","updateMinAndPrev","curr","getPixelForValue","ticks","thickness","size","stackCount","ratio","chunk","pixels","next","percent","categoryPercentage","abs","barPercentage","parseFloatBar","endValue","barStart","barEnd","startValue","parseValue","parseArrayOrPrimitive","entry","isFloatBar","borderProps","base","setBorderSkipped","edge","enableBorderRadius","parseEdge","swap","startEnd","v2","v1","setInflateAmount","inflateAmount","grouped","offset","grid","beginAtZero","yAxisKey","obj","custom","updateElements","getBasePixel","horizontal","ruler","head","vpixels","ipixels","center","stacked","skipNull","val","isNullOrUndef","isNaN","indexOf","opts","barThickness","computeMinSampleSize","getDataVisibility","barSign","startPixel","getPixelForDecimal","endPixel","halfGrid","_calculateBarIndexPixels","stackIndex","maxBarThickness","rects","BubbleController","parseArrayData","_custom","getLabelAndValue","reset","point","updateElement","radius","offsetX","offsetY","circumference","startX","cos","startAngle","startY","sin","endX","endAngle","endY","calcMax","angle","_angleBetween","calcMin","maxX","maxY","HALF_PI","minX","PI","minY","ratioX","ratioY","animateRotate","animateScale","spacing","_scriptable","_indexable","name","aspectRatio","generateLabels","fillStyle","strokeStyle","color","lineWidth","pointStyle","hidden","onClick","legend","innerRadius","getDataset","getter","getDatasetMeta","toRadians","TAU","chartArea","arcs","getMaxBorderWidth","cutout","toPercentage","rotation","radiusLength","outerRadius","toDimension","animationOpts","centerX","arc","centerY","metaData","total","calculateCircumference","formatNumber","getMaxOffset","ringWeightOffset","isDatasetVisible","_getRingWeightOffset","LineController","showLine","spanGaps","line","_getStartAndCountOfVisiblePoints","_scaleRangesChanged","resolveDatasetElementOptions","animated","animationsDisabled","_dataset","segment","maxGapLength","isNumber","directUpdate","pointsCount","skip","iPixel","vPixel","border","firstPoint","lastPoint","PolarAreaController","style","e","toggleDataVisibility","display","circular","pointLabels","parseObjectData","_parseObjectDataRadialScale","datasetStartAngle","defaultAngle","_computeAngle","getDistanceFromCenterForValue","PieController","DoughnutController","RadarController","fill","_fullLoop","points","pointPosition","getPointPositionForValue","ScatterController","_datasetIndex","POSITIVE_INFINITY","prevParsed","members","init","formats","abstract","endOf","DateAdapterBase","lookupMethod","lo","_rlookupByKey","_lookupByKey","hi","handler","deltaX","isPointInArea","position","_isPointInArea","evaluateInteractionItems","minDistance","evaluationFunc","inRange","distance","intersectsItem","intersect","includeInvisible","getRelativePosition","array","v0","weight","wrapBoxes","pos","box","boxes","stackWeight","layoutBoxes","buildStacks","STATIC_POSITIONS","includes","_stack","layouts","fullSize","layout","height","hBoxMaxHeight","width","vBoxMaxWidth","buildLayoutBoxes","sortByWeight","filterByPosition","centerHorizontal","filterDynamicPositionByAxis","centerVertical","vertical","getCombinedMax","maxPadding","boxPadding","updateDims","params","updateMaxPadding","getPadding","newWidth","newHeight","widthChanged","heightChanged","other","handleMaxPadding","updatePos","change","marginForPositions","margin","fitBoxes","w","refit","same","refitBoxes","setBoxDims","placeBoxes","userPadding","verticalBoxes","horizontalBoxes","each","visibleVerticalBoxCount","padding","availableWidth","availableHeight","toPadding","touchend","pointerleave","pointerout","renderHeight","getAttribute","renderWidth","boxSizing","displayWidth","canvas","displayHeight","readUsedSize","addListener","addEventListener","eventListenerOptions","EVENT_TYPES","event","nodeListContains","nodeList","trigger","listener","observe","childList","subtree","observer","entries","dpr","drpListeningCharts","resize","unlistenDevicePixelRatioChanges","delete","window","removeEventListener","onWindowResize","container","throttled","clientWidth","_getParentNode","proxy","EXPANDO_KEY","proxies","createAttachObserver","createDetachObserver","createResizeObserver","releaseObserver","devicePixelRatio","getMaximumSize","_detectPlatform","_isDomSupported","OffscreenCanvas","BasicPlatform","DomPlatform","Element","defaultRoutes","tooltipPosition","useFinalPosition","getProps","hasValue","props","final","ret","ticksLimit","majorIndices","newTicks","numMajorIndices","determineMaxTicks","tickLength","maxScale","maxChart","_maxLength","_factorize","result","majorStart","round","diff","reverseAlign","align","offsetFromEdge","getTicksLimit","ticksLength","maxTicksLimit","validIndex","_startPixel","epsilon","lineValue","caches","gc","gcLen","splice","toFont","font","fallback","lines","_toLeftRightCenter","titleArgs","titleY","titleX","_alignStartEnd","positionAxisID","maxWidth","maxHeight","paddingTop","paddingLeft","labelRotation","_endPixel","_borderValue","_dataLimitsCached","_userMin","_suggestedMax","_userMax","finiteOrDefault","_suggestedMin","metas","getLabels","call","margins","beforeSetDimensions","samplingEnabled","_convertTicksToLabels","beforeFit","afterFit","afterUpdate","reversePixels","isHorizontal","_reversePixels","_addGrace","_callHooks","determineDataLimits","afterBuildTicks","tickOpts","minRotation","maxRotation","tickWidth","labelSizes","maxLabelWidth","afterAutoSkip","titleHeight","titleOpts","minSize","first","tickPadding","angleRadians","labelHeight","mirror","labelWidth","_limitValue","toDegrees","_margins","_calculatePadding","last","isRotated","paddingRight","paddingBottom","sampleSize","fontString","tickFont","_resolveTickFontOptions","_measureText","lineHeight","nestedLabel","widths","heights","widestLabelSize","widest","highest","decimal","pixel","createTickContext","rot","autoSkipPadding","h","tl","setContext","borderOpts","alignBorderValue","_alignPixel","borderValue","y2","tx2","y1","tx1","axisHalfWidth","step","ceil","limit","optsAtIndexBorder","borderDashOffset","tickBorderDashOffset","getPixelForGridLine","alignedLineValue","ty2","x1","lineColor","borderDash","tickColor","optionTicks","tickAndPadding","hTickAndPadding","_getYAxisLabelAlignment","textAlign","_getXAxisLabelAlignment","textBaseline","getPixelForTick","lineCount","strokeColor","optsAtIndex","strokeWidth","tickTextAlign","crossAlign","textOffset","backdrop","labelPadding","backgroundColor","save","fillRect","restore","getLineWidthForValue","_isVisible","_gridLineItems","p2","lineDashOffset","drawLine","x2","lastLineWidth","moveTo","lineTo","clipArea","getLabelItems","renderTextOptions","renderText","unclipArea","title","text","titleAlign","translation","drawBorder","tz","gz","bz","drawBackground","drawGrid","fontSize","scope","override","create","isForType","registerDefaults","overrides","parentScope","merge","descriptors","propertyParts","split","sourceName","join","sourceScope","isIChartComponent","proto","plugins","_typedRegistries","typedRegistry","reg","_capitalize","component","camelMethod","descriptor","callCallback","plugin","_oldCache","previousDescriptors","localIds","all","getOpts","pluginOpts","local","createResolver","scriptable","indexable","allKeys","getIndexAxis","datasetDefaults","datasetOptions","getAxisFromDefaultScaleID","getDefaultScaleIDFromAxis","idMatchesAxis","axisFromPosition","determineAxis","scaleOptions","toLowerCase","Error","getAxisFromDataset","retrieveAxisFromDatasets","boundDs","filter","d","xAxisID","yAxisID","mergeScaleConfig","chartDefaults","configScales","chartIndexAxis","scaleConf","error","_proxy","warn","defaultId","defaultScaleOptions","mergeIf","defaultID","initOptions","initData","initConfig","keyCache","keysCached","Set","cachedKeys","generate","add","addIfFound","Config","_config","_scopeCache","_resolverCache","platform","clearCache","clear","datasetType","mainScope","Array","resolver","needContext","subResolver","_attachContext","hasFunction","isScriptable","compare2Level","onAnimationsComplete","onAnimationProgress","onProgress","getCanvas","intKey","inChartArea","Chart","register","registry","invalidatePlugins","userConfig","getChart","updateConfig","uid","_aspectRatio","currentDevicePixelRatio","_lastEvent","_plugins","PluginService","$proxies","_hiddenIndices","attached","_animationsDisabled","_doResize","debounce","_dataChanges","instances","animator","retinaScale","clearCanvas","stop","_resize","newSize","newRatio","scalesOptions","axisOptions","axisID","scaleOpts","updated","dposition","scaleClass","scaleType","hasUpdated","addBox","newControllers","order","visible","ControllerClass","chartOptionScopes","cancelable","notifyPlugins","minPadding","_minPadding","_updateHoverStyles","removeBox","buildOrUpdateScales","setsEqual","newEvents","_getUniformDataChanges","moveNumericKeys","makeSet","idx","noArea","_layers","_resizeBeforeDraw","isFunction","layers","filterVisible","_drawDataset","clip","useClip","getDatasetArea","getElementsAtEventForMode","_sorted","_updateVisibility","_metasets","remove","destroy","responsive","listeners","_eventHandler","_responsiveListeners","_remove","_add","detached","updateHoverStyle","prefix","changed","_elementsEqual","lastActive","notify","deactivated","replay","activated","hoverOptions","eventFilter","clipArc","pixelMargin","angleMargin","beginPath","closePath","toRadiusCorners","_readValueToProps","parseBorderRadius","innerLimit","halfThickness","computeOuterLimit","innerStart","innerEnd","spacingOffset","alpha","beta","outerStart","outerEnd","outerEndAdjustedRadius","outerStartAdjustedAngle","innerStartAdjustedAngle","innerStartAdjustedRadius","innerEndAdjustedAngle","innerEndAdjustedRadius","outerMidAdjustedAngle","outerEndAdjustedAngle","rThetaToXY","pCenter","innerMidAdjustedAngle","p8","outerStartAdjustedRadius","outerEndX","outerEndY","drawArc","pathArc","borderWidth","borderJoinStyle","inner","borderAlign","setLineDash","lineJoin","fullCircles","stroke","ArcElement","chartX","chartY","_circumference","betweenAngles","_isBetween","getCenterPoint","getAngleFromPoint","halfRadius","halfAngle","translate","fix","radiusOffset","borderColor","cubicInterpolationMode","_bezierCurveTo","_steppedLineTo","pathVars","segmentStart","paramsEnd","segmentEnd","outside","paramsStart","lineMethod","avgX","countX","drawX","prevX","truncX","useFastPath","_steppedInterpolation","_bezierInterpolation","_pointInLine","strokePathWithCache","path","strokePathDirect","usePath2D","capBezierPoints","stepped","tension","_points","_updateBezierControlPoints","_segments","segments","property","p1","interpolated","_computeSegments","segmentMethod","_boundSegments","el","hitRadius","PointElement","hoverBorderWidth","hoverRadius","mouseX","pow","mouseY","drawPoint","bar","half","skipOrLimit","o","toTRBL","maxH","maxW","enableBorder","toTRBLCorners","topLeft","topRight","boundingRects","bounds","bottomLeft","bottomRight","skipX","skipY","hasRadius","rect","inflateRect","amount","refRect","BarElement","borderSkipped","borderRadius","outer","addRectPath","addRoundedRectPath","getRange","BORDER_COLORS","BACKGROUND_COLORS","map","replace","getBorderColor","getBackgroundColor","colorizeDefaultDataset","colorizeDoughnutDataset","colorizePolarAreaDataset","getColorizer","containsColorsDefinitions","k","containsColorsDefinition","enabled","forceOverride","beforeLayout","_args","chartOptions","colorizer","lttbDecimation","decimated","sampledIndex","samples","avgRangeStart","avgRangeEnd","j","avgY","avgRangeLength","pointAx","maxArea","rangeOffs","rangeTo","maxAreaPoint","nextA","minMaxDecimation","endIndex","xMax","xMin","intermediateIndex1","intermediateIndex2","startIndex","lastIndex","minIndex","cleanDecimatedDataset","_decimated","defineProperty","configurable","enumerable","writable","cleanDecimatedData","algorithm","xAxis","tpoints","parts","_findSegmentEnd","_getBounds","source","targetSegments","tgt","subBounds","fillSources","_boundSegment","fillSource","_getEdge","_normalizeAngle","_pointsFromSegments","boundary","linePoints","visited","decodeTargetIndex","firstCh","addPointsBelow","sourcePoints","below","postponed","pointValue","simpleArc","pathSegment","interpolate","computeLinearBoundary","computeCircularBoundary","_drawfill","_getTarget","lineOpts","fillOption","above","doFill","clipVertical","clipY","lineLoop","src","notShape","clipBounds","interpolatedLineTo","targetLoop","interpolatedPoint","_decodeFill","sources","_resolveTarget","beforeDraw","drawTime","updateControlPoints","beforeDatasetsDraw","getSortedVisibleDatasetMetas","beforeDatasetDraw","propagate","labelOpts","boxHeight","boxWidth","itemHeight","itemsEqual","lineWidths","setDimensions","legendItems","labelFont","_fitRows","_fitCols","row","hitboxes","itemWidth","totalHeight","legendHitBoxes","columnSizes","currentColHeight","totalWidth","currentColWidth","col","rtlHelper","getRtlAdapter","hitbox","leftForLtr","defaultColor","drawTitle","drawLegendBox","legendItem","lineCap","SQRT2","xPlus","halfFontSize","yBoxTop","some","xBoxLeft","strikethrough","overrideTextDirection","measureText","cursor","realX","fillText","fontLineHeight","_textX","restoreTextDirection","titleFont","titlePadding","topPaddingPlusHalfFontSize","_getLegendItemAt","lh","isListened","hoveredItem","previous","_hoveredItem","calculateItemSize","calculateItemWidth","calculateItemHeight","_itemHeight","legendItemText","reduce","Legend","beforeUpdate","ci","onHover","onLeave","usePointStyle","fontColor","Title","_padding","textSize","_drawArgs","fontOpts","titleBlock","WeakMap","len","eventPosition","nearestElement","tp","distanceBetweenPoints","str","formattedValue","bodyFont","footerFont","titleLineCount","footerLineCount","bodyLineItemCount","combinedBodyLength","tooltip","footerMarginTop","maxLineWidth","body","bodyItem","determineYAlign","doesNotFitWithAlign","caretSize","xAlign","determineXAlign","yAlign","paddingAndSize","caretPadding","pushOrConcat","callback","createTooltipContext","tooltipItems","overrideCallbacks","beforeTitle","noop","tooltipItem","labelColor","labelTextColor","labelPointStyle","getStyle","beforeFooter","arg","dataPoints","initialize","_cachedAnimations","invokeCallbackWithFallback","afterTitle","before","scoped","bodyItems","footer","afterFooter","labelColors","labelPointStyles","labelTextColors","positioners","_createItems","getTitle","getBeforeBody","getBody","getTooltipSize","alignment","backgroundPoint","caretX","caretY","external","drawCaret","caretPosition","getCaretPosition","cornerRadius","ptX","ptY","tooltipPoint","y3","x3","titleSpacing","string","pt","getAlignedX","colorY","yOffSet","rtlColorX","innerX","v","bodySpacing","bodyAlign","displayColors","bodyLineHeight","rtl","fillLineOfText","xLinePadding","bodyAlignForCalculation","textColor","beforeBody","drawFooter","footerAlign","tooltipSize","quadraticCurveTo","animX","animY","positionAndSize","determineAlignment","getBackgroundPoint","opacity","drawBody","_positionChanged","positionChanged","Tooltip","afterInit","afterDraw","bodyColor","footerColor","easing","defaultCallbacks","addIfString","addedLabels","unshift","findOrAddLabel","lastIndexOf","_getLabelForValue","CategoryScale","Scale","_valueRange","added","_addedLabels","getLabelForValue","getValueForPixel","MIN_SPACING","rmax","numSpaces","maxSpaces","niceNum","precision","niceMin","niceMax","rmin","countDefined","almostWhole","includeBounds","almostEquals","tickValue","generationOptions","relativeLabelSize","rad","minSpacing","_startValue","minSign","setMax","setMin","maxTicks","getTickLimit","dataRange","_range","_setMinAndMaxByKey","generateTicks","LinearScale","LinearScaleBase","Ticks","handleTickRangeOptions","log10Floor","log10","changeExponent","m","isMajor","tickVal","remain","steps","rangeExp","rangeStep","startExp","exp","stepSize","significand","major","lastTick","_zero","getDecimalForPixel","getTickBackdropHeight","backdropPadding","measureLabelSize","_longestText","determineLimits","orig","valueCount","pointLabelOpts","additionalAngle","centerPointLabels","getPointPosition","plFont","getIndexAngle","hLimits","vLimits","updateLimits","limits","setCenterPoint","_pointLabelItems","buildPointLabelItems","_pointLabels","extra","outerDistance","pointLabelPosition","getTextAlignForAngle","labelCount","backdropColor","backdropLeft","backdropTop","backdropWidth","backdropHeight","pathRadiusLine","xCenter","drawRadiusLine","angleLines","showLabelBackdrop","yCenter","generateTickLabels","fitWithPointLabels","rightMovement","topMovement","bottomMovement","angleMultiplier","NaN","drawingArea","scalingFactor","scaledDistance","getPointLabelContext","getContext","pointLabel","distanceFromCenter","getBasePosition","getPointLabelPosition","drawPointLabels","drawLabels","second","common","adapter","interval","UNITS","unit","INTERVALS","majorUnit","setMajorTicks","_lookup","adapters","parser","_normalized","time","isoWeekday","_applyBounds","timeOpts","initOffsets","timestamps","getDecimalForValue","startOf","hasWeekday","minor","addTick","format","minorFormat","offsets","ticksOpts","tickLabelWidth","cosRotation","sinRotation","exampleLabel","_majorUnit","capacity","normalize","prevSource","nextSource","table","nextTarget","prevTarget","TimeScale","_table","_tableRange","getDataTimestamps","registerables","controllers"],"mappings":"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"}